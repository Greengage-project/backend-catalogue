/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * __________________
 *
 *  Copyright 2016 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

window.xfalib.$ = window.$;
window.xfalib.jQuery = window.jQuery;
window.xfalib._ = window._;
/*******************************************************************************
 * ADOBE CONFIDENTIAL
 *   ___________________
 *
 *    Copyright 2013 Adobe Systems Incorporated
 *    All Rights Reserved.
 *
 *   NOTICE:  All information contained herein is, and remains
 *   the property of Adobe Systems Incorporated and its suppliers,
 *   if any.  The intellectual and technical concepts contained
 *   herein are proprietary to Adobe Systems Incorporated and its
 *   suppliers and are protected by all applicable intellectual property
 *   laws, including trade secret and copyright laws.
 *   Dissemination of this information or reproduction of this material
 *   is strictly forbidden unless prior written permission is obtained
 *   from Adobe Systems Incorporated.
 ******************************************************************************/


;(function ($) {
    /*
     * Form Bridge API
     * The API provides a method for external applications to connect with Xfa and formDom. The APIs are divided into two categories, synchronous and asynchronous.
     *
     * All the APIs that are internal to us must go into FormBridgeInternal.js and not here
     *
     * Each Synchronous getter API returns a XFAResultObject which represents the result of the API whereas each setter API throws an exception in case of error and
     * it is the responsibility of the API to catch those exceptions. The XFAResultObject either contains error or the return value of the API and provides easy
     * mechanism to access each of them.
     *
     * Each Asynchronous API provides callback mechanism to return the result of the API. Each API takes a Javascript Object containing error, success Handlers and a
     * context in which to invoke those functions. The syntax of the object is
     * { error: errorHandlerFunc,
     *   success: successHandlerFunc,
     *   context: ObjectContext
     * }
     * The signature of the functions is
     * function(XFAResultObject) {
     *
     *  }
     * Each of the functions is passed a XFAResultObject containing either the data of the operation or the errors.
     *
     */

    Function.prototype.bind = Function.prototype.bind || function (ctx) {
        var that = this;
        return function () {
            that.call(ctx, arguments);
        }
    };

    /* public interface XFAResultObject
     public string[] message          // error messages
     public string[] somExpression    // somExpressions that caused the errors
     public string[] errorCode        // internal
     public bool errors               // whether the result object has errors or not
     public Object data               // data returned by the function

     public getNextMessage            // returns a message Object {code,somExpression,message} or null if no error message is present
     */
    var XFAResultObject = function() {
        var _message = [],
            _errorCode = [],
            _somExpression = [];
        this.errors = false;

        this.addMessage = function (code, msg, som) {
            this.errors = true;
            _message.push(msg);
            _somExpression.push(som);
            _errorCode.push(code);
        };

        this.getNextMessage = function () {
            if (_errorCode.length == 0)
                return null;
            return {
                code: _errorCode.pop(),
                somExpression: _somExpression.pop(),
                message: _message.pop()
            };
        };
    };

    var FORM_BRIDGE_VERSION = "8.0.180";
    var FormBridge = function () {
        this._xfa = null;
        this._version = FORM_BRIDGE_VERSION;
        this._xfaInitHandler = {};
        this._$target = null;
        this.isAnalyticsEnabled = false;
        $(window).on("XfaInitialized", this._xfaInitialized.bind(this));
        $(window).on("XfaInitializationError", this._xfaError);
        this._formDoc = window.document;
        this.userConfig = {};
        // indicates if ajax call is executed in client or server
        // note: this should not be modified in client
        this.ajaxCallMode = "client";
        this._PROFILE_RESOURCE_PATH = "/content/xfaforms/profiles/default";
    };

    /*
     * Default error handler for functions in case none is provided by the caller
     * TODO : make the string localized and call the xfa Logger
     */
    var defaultErrorHandler = function (obj) {
        if (typeof(console) == "undefined")
            return;
        var d = null;
        while (d = obj.getNextMessage())
            console.error(d.message);
    };

    var _isFirstTempStorageCreationPending = false,
        TEMP_STORAGE_PATH = "/tmp/fd/xfaforms";
    var createUUIDStorage  = function(uuid){
        if(!formBridge._isLoginAnonymous()) {
            var successFlag = true;
            $.ajax({
            url: formBridge._getPathUrl(".fd.tempstorageprovider.jsp"),
                type: "POST",
                async: false,
                data: {"uuidPath": TEMP_STORAGE_PATH + "/" + uuid},
                error : function (message) {
                    successFlag = false;
                }
            });
            return successFlag;
        }

    };

    /*
     * Default function to check Validations errors after getting the data from the
     * server with getDataXML call.
     */
    var defaultValidationChecker = function (validations, obj) {
        if (validations && validations.length > 0) {
            for (var i = 0; i < validations.length; i++)
                obj.addMessage(0, validations[i], "");
            return false;
        }
        return true;
    };

    $.extend(FormBridge.prototype, {
        /*
         * Returns whether Form Dom is initialized or not.
         */
        isConnected: function () {
            return !!this._xfa;
        },
        /*
         * @public
         * Specify a function to execute after making a connection with FormBridge
         * handler: handler to execute
         * context: variable 'this' will refer to context in the handler.
         */
        connect: function (handler, context) {
            context = context || formBridge;
            if (this.isConnected())
                handler.call(context);
            else {
                this._xfaInitHandler.handler = this._xfaInitHandler.handler || [];
                this._xfaInitHandler.handler.push(handler);
                this._xfaInitHandler.context = this._xfaInitHandler.context || [];
                this._xfaInitHandler.context.push(context);
            }
        },
        /*
         * @private
         * Handler for XfaInitialized event which is fired by XFA library after Form Dom is initialized
         */
        _xfaInitialized: function (e) {
            this._xfa = xfalib.runtime.xfa;
            var obj = new XFAResultObject();
            if (this.storage) {
                if (this.storage.formState) {
                    this._xfa.host.playJson(JSON.parse(this.storage.formState.xfaDom));
                    this.storage.success.call(this.storage.context);
                    this.storage = null;
                } else if (this.storage.success) {
                    this.storage.success.call(this.storage.context);
                }
                if (this.xmlStorage && this.xmlStorage.xmlDocument) {
                    try {
                        this._xfa.Logger.debug("xfa", "Restoring Data XML after initiailzation");
                        this._xfa.host.playDataXml(this.xmlStorage.xmlDocument);
                        if(this.xmlStorage.success) {
                            this.xmlStorage.success.call(this.xmlStorage.context, obj);
                        }
                    } catch(e) {
                        if(this.xmlStorage.error) {
                            obj.addMessage(2, "Unexpected Exception: Unable to play Data XML " + e, null);
                            this.xmlStorage.error.call(this.xmlStorage.context, obj);
                        }
                    }
                } else if (this.xmlStorage && this.xmlStorage.success) {
                    this.xmlStorage.success.call(this.xmlStorage.context, obj);
                }
                this.xmlStorage = null;
            }
            if (this._xfaInitHandler.handler) {
                for (var i = 0; i < this._xfaInitHandler.handler.length; i++) {
                    this._xfaInitHandler.handler[i].call(this._xfaInitHandler.context[i]);
                }
                this._xfaInitHandler = {};
            }
        },

        /*
         * @public
         * Specify a function to decide whether the analytics will be enabled or disabled
         * public Boolean isAnalyticsEnabled: this argument determines whether the analytics will be enabled or not
         */
        enableAnalytics: function(state){
            this.isAnalyticsEnabled = state;
        },

        _xfaError: function (e) {
            this._xfa = window.xfa;
            var obj = new XFAResultObject();
            // since there is xfa init error, why should we call playJson
            if (this.storage.formState) {
                this._xfa.host.playJson(JSON.parse(this.storage.formState.xfaDom));
                this.storage = null;
            } else {
                if (this.storage.error)
                    this.storage.error.call(this.storage.context, e.message);
            }
            if (this.xmlStorage.error) {
                obj.addMessage(2, e.message, null);
                this.xmlStorage.error.call(this.xmlStorage.context, obj);
            }
        },

        _getResultObject: function() {
            return new XFAResultObject();
        },

        _checkXfa: function (obj) {
            if (!this._xfa) {
                obj.addMessage(1, "Xfa Dom not Initialized", "");
                return false;
            }
            return true;
        },
        /*
         * returns the version of library
         */
        getBridgeVersion: function () {
            return this._version;
        },

        /*
         * Registers user/portal specific configurations to FormBridge.
         * Currently supported configurations are:
         * {widgetConfig : {selector: jqWidgetName}}
         * {pagingConfig : {pagingEnabled: true}}
         * {LoggerConfig : {{"on":"true", "category":"xfa", "level":"5", "type":"console"}}
         * {postExternalMessageConfig : {postExternalHandler: fn}}
         * {contextPath : contextPath}
         * {viewportWidth : <1000>}
         * e.g.: formBridge.registerConfig("widgetConfig", {".imagefield" : "sigImageField"});
         *
         * returns a XFAResultObject. Old config against same key is stored in obj.data[0]
         */
        registerConfig: function (key, config) {
            var obj = new XFAResultObject();
            obj.data = this.userConfig[key];
            this.userConfig[key] = config;
            obj.completed = true;
            return obj;
        },


        /*
         * Returns the pagingManager handle for the current xfa view.
         * Should be called after FormBridge is in connected mode else paginManager handle would be null
         */
        pagingManager: function () {
            if (this._xfa && this._xfa.host)
                return this._xfa.host.pagingManager;
            else
                return null;
        },

        /*
         * hide the fields whose som is provided in the fieldArray
         * fieldArray: array of somExpressions
         */
        hideFields: function (fieldArray) {
            this.setFieldProperties(fieldArray, "presence", "invisible");
        },
        /*
         * Make the fields, whose som is provided in the fieldArray, visible
         * fieldArray: array of somExpressions
         */
        showFields: function (fieldArray) {
            this.setFieldProperties(fieldArray, "presence", "visible");
        },
        /*
         * set the value of the field. Throws an exception if the somExpression is incorrect
         * field: somExpressions of the field
         */
        setFieldValue: function (field, value) {
            this.setFieldProperties(field, "rawValue", value);
        },
        /*
         * get the value of the fields, whose som is provided in the fieldArray
         * fieldArray: array of somExpressions
         *
         * returns a XFAResultObject. The result is stored in obj.data[0]
         */
        getFieldValue: function (field) {
            return this.getFieldProperties(field, "rawValue");
        },
        /*
         * set the property of the fields, whose som is provided in the fieldArray, with the values provided
         * fieldArray: array of somExpressions
         * prop: property to set
         * values: array of values.
         */
        setFieldProperties: function (fieldArray, prop, values) {
            var obj = new XFAResultObject();
            if (!this._checkXfa(obj))
                throw obj.getNextMessage().message;

            if (!_.isArray(fieldArray)) {
                fieldArray = [fieldArray];
            }

            if (!_.isArray(values)){
                values = [values];
            }

            for (var i = 0; i < fieldArray.length; i++) {
                var field = this._xfa.resolveNode(fieldArray[i]);
                if (field == null)
                    throw "No field " + fieldArray[i] + " exists"
                else {
                    obj.completed = true;
                    field[prop] = values[i] || values[0];
                }
            }
            // change made to re-evaluate floating field text in draw
            if(prop && prop === "rawValue" && this._xfa.moContextNodes.length == 0) {
                this._xfa.runCalcAndValidate();
            }
        },
        /*
         * get the property value of the fields, whose som is provided in the fieldArray
         * fieldArray: array of somExpressions
         * prop: property to get
         *
         * returns a XFAResultObject whose data member is the array of returned values. If a
         * somExpression provided doesn't exists null is returned for that element in the data
         */
        getFieldProperties: function (fieldArray, prop) {
            var obj = new XFAResultObject();
            if (!this._checkXfa(obj))
                return obj;

            if (!_.isArray(fieldArray)) {
                fieldArray = [fieldArray];
            }

            obj.data = [];
            for (var i = 0; i < fieldArray.length; i++) {
                var field = this._xfa.resolveNode(fieldArray[i]);
                if (field == null) {
                    obj.addMessage(0, "No field " + fieldArray[i] + " exists", fieldArray[i])
                    obj.data.push(null);
                }
                else {
                    obj.completed = true;
                    obj.data.push(field[prop]);
                }
            }
            return obj;
        },
        hideSubmitButtons: function () {
            var obj = new XFAResultObject();
            if (!this._checkXfa(obj))
                throw obj.getNextMessage().message;
            this._xfa._hideSubmitButtons();
        },
        _getPathUrl: function (urlSuffix) {
            var url = this._PROFILE_RESOURCE_PATH + (urlSuffix || "");
            return this._getUrl(url);
        },

        _getFileWidgetIfPresent: function () {
            return xfalib.runtime.fileUploadWidget;

        },
        _getFileListFromFileWidget:  function () {
            var fileWidget = this._getFileWidgetIfPresent();
            if(fileWidget) {
                return fileWidget._getFileList();
            }
            return null;
        },
        _getCommitValueFromFileWidget: function () {
            var fileWidget = this._getFileWidgetIfPresent();
            if(fileWidget) {
                return fileWidget.getCommitValue();
            }
            return null;
        },

        /**
         *
         * @param optimize{boolean} flag to turn optimization on; if false, entire jsonModel is returned,
         * else diff of initial and current model returned.
         * @param optimize_level{0,1 or 2} : determines the aggressiveness level of size optimizations used
         *  0: returns all properties which changed between initial and current model.
         *  1: jsonModelDiff with access & presence, must be repayable via playJson on calling restoreFormState. but to keep diff sz to min.
         *      remove unplayed items from the diff. Also to maintain hierarchy must have all instance managers, and unbinded fields.
         *  2: minimal jsonModelDiff with only hierarchy skeleton and class, name and 'value's preserved for transfer during submit.
         *
         * @returns {XFAResultObject}
         * returns the string representation of the XFA Form DOM and includes all the XFA packets
         * returns a XFAResultObject whose 'data' member is the formState
         */
        getFormState: function (optimize, optimize_level) {
            var obj = new XFAResultObject();
            if (!this._checkXfa(obj)) {
                return obj;
            }
            var behaviorConfig = new xfalib.ut.Version(formBridge.userConfig["behaviorConfig"]);
            //To maintain backward compatibility
            if (behaviorConfig.isOn('disableLeanSubmit') || behaviorConfig.isOn('mfDisableLeanSubmit')) {
                optimize_level = 0;
            }
            var xfaDom = optimize === true ? this._xfa._computeJsonDiff(optimize_level).jsonDifference
                                           : this._xfa.jsonModel;

            xfaDom.isComplete = !optimize;

            //add the information required from DOM during submit in the form state
            var formAttributesData = {},
                formElement = $("#lcforms_xfaform_container")[0];
            if(formElement){
                _.each(formElement.attributes,function(attrib){
                    formAttributesData[attrib.name] = attrib.value;
                });
            }

            var additionalSubmitInformation = {
                "formAttributesData": formAttributesData,
                "userConfig": formBridge.userConfig
            };

            var xfaDomString = JSON.stringify(xfaDom);
            obj.data = {
                xfaDom: xfaDomString,
                //save renderContext in form state to enable deferred submit even if form is not open
                renderContext: xfalib.runtime.renderContext,
                customPropertyMap: xfalib.runtime.customPropertyMap,
                additionalSubmitInformation: additionalSubmitInformation
            };
            return obj;
        },
        /*
         * sets the field on focus whose somExpression is provided
         *
         * throws an exception in case of error.
         */
        setFocus: function (som) {
            var obj = new XFAResultObject();
            if (!this._checkXfa(obj))
                throw obj.getNextMessage().message;
            var node = this._xfa.resolveNode(som);
            if (node == null) {
                throw "No field " + som + " exists ";
            }
            else {
                this._xfa.host._setFocus(som);
            }
        },

        /*
         *  Helper function to ger submit service proxy url
         */
        _getSubmitServiceProxyUrl: function () {
            var submitServiceProxyConfig = this.userConfig["submitServiceProxyConfig"],
                submitServiceProxyUrl = "",
                contextPath = this.userConfig["contextPath"];
            if (submitServiceProxyConfig && submitServiceProxyConfig["submitServiceProxy"]) {
                submitServiceProxyUrl += submitServiceProxyConfig["submitServiceProxy"];
            }
            else {
                //finally hard code it
                submitServiceProxyUrl += ((contextPath && contextPath !== "/") ? contextPath : "") + "/content/xfaforms/profiles/default.submit.html";
            }
            return submitServiceProxyUrl;
        },

        /*
         * remote invocation ----
         * This method post form dom to LCFormsService and run the success handlers
         * It accepts the object with following params:
         * {
         *  url: '',
         *  type: '',
         *  contentType: '',
         *  data: '',
         *  success: '',
         *  error: ''
         *  }
         *  The called can choose to override one of more parameters of $.ajax API of JQuery
         */

        _invokeAtServer: function (options) {
            options = options || {};
            var submitServiceProxyUrl = this._getSubmitServiceProxyUrl(),
                isServerAjaxCallMode = this.ajaxCallMode === "server";

            if (options.data && !options.data["_charset_"]) {
                options.data["_charset_"] = "UTF-8"; //to let sling know data encoding
            }

            if(isServerAjaxCallMode){
                var mergedFormDom = "";
                // Done to fix: LC-9204
                // Not invoking HTTP request instead making use of server session
                try {
                    mergedFormDom = getMergedFormDomFromRhino(options.data);
                } catch(exception){
                    xfalib.runtime.xfa.Logger.error("xfa", exception.message);
                }
                // If success handler is present, invoke it, context is provided by the caller
                if(_.isFunction(options.success) && mergedFormDom) {
                    options.success(JSON.parse(mergedFormDom));
                }
            } else {
                var strContent = this.getMultipartData(options.data);  // TODO : maybe use the browser's FormData object, and handle IE as we are doing now
                options.data = strContent[1];
                var params = _.extend({
                        beforeSend: formBridge.uiFreeze,
                        complete: formBridge.uiUnFreeze,
                        async: false,
                        url: submitServiceProxyUrl,
                        type: 'POST',
                        processData: false,
                        cache: false,
                        contentType: "multipart/form-data; charset=UTF-8; boundary=" + strContent[0]
                    },
                    options);

                $.ajax(params);
            }
        },

        /**
         *
         * This function does following:
         * a) On first call, it creates the uuid storage and returns the UUID
         * b) On subsequent calls, it just returns the uuid
         * c) if uuid is not created then it returns null
         *
         */
        _getUUID: function () {
            if(this._formInstanceUUID) {
                return this._formInstanceUUID;
            }
            //Generate the UUID for the form instance on client side
            var uuid = $('body#formBody').data("tmproot"),
                uuidSuffix = Math.floor((Math.random() * 10000) + 1),
                uuidCurrentTime = new Date().getTime(),
                successFlag = true;
            this._formInstanceUUID = uuid + "_" + uuidCurrentTime + uuidSuffix;
            successFlag = createUUIDStorage(this._formInstanceUUID);
            if(successFlag){
                return this._formInstanceUUID;
            } else {
                return null;
            }
        },
        _getUrl: function (url) {
            //url provided can contain the hostname and port too, in that case return the url as it is
            if (url.indexOf("http:") == 0 || url.indexOf("https:") == 0) {
                return url;
            }
            var baseUrl = this.userConfig["baseUrl"],
                contextPath = this.userConfig["contextPath"];
            if (baseUrl) {
                return baseUrl + url;
            }
            else if (contextPath && contextPath!== "/" && url.indexOf(contextPath)!== 0 &&(url.length ===0 || url.indexOf("/") === 0)){
                //if url does not have contextPath and starts with /, pre-pend contextPath
                // Also url.length check because I need to pass "" to getUrl and get context path
                return contextPath + url;
            }
            return url;
        },
        getFileAttachmentsInfo: function (options) {
            var fileAttachmentsList = [],
                list;


            function collectFileUrls(event) {
                list = [];
                //TODO: need to modularize collectFileUrs()
                // here this is the context of the function who calls it
                _.each(this.attachments, function (att) {
                    //this.fileUrl is null when no file is uploaded. att contains path - "fileupload/™a.jpg" if not uploaded
                    // if att starts with "/", this means that the attachment has already been uploaded.
                    if(!_.isEmpty(this.fileUrl) && att.indexOf("/")!=0 ) {
                        list.push({name: att.split("/")[1], path: this.fileUrl + "/" + att});
                    } else {
                        list.push({name: att.substring(att.lastIndexOf("/")+1), path: att});
                    }
                }, this);
                if (this.options.success) {
                    this.options.success.call(this.options.context, list);
                }
            }

            this._getAttachments(fileAttachmentsList, options.fileUploadPath || this.getTempPath(), collectFileUrls, options);

        },

        _getAttachments: function (fileAttachmentDomElement, fileUploadPath, callback, options) {

            var allFiles = [],
                attachments = [],
                fileUrl = null,
                fileCount = 0,
                didSubmit = false,
                contextRoot = this._getContextRoot(),
                FILE_COMPONENT_NAME = "fileupload";

            /*
             * In the case of draft, url comes with context root. Need to remove it so that correct value gets stored in model
             */
            if (contextRoot) {
                if (fileUploadPath.indexOf(contextRoot) === 0) {
                    fileUploadPath = fileUploadPath.substring(contextRoot.length);
                }
            }

            var currentCount = 0;
            var fileNameList = formBridge._getCommitValueFromFileWidget();

            if (fileNameList.length > 0) {
                var fileNames = fileNameList;
                var fileList = $.extend(true, [], formBridge._getFileListFromFileWidget());
                _.each(fileList, function (file, index) {
                    var nameOfFile = fileNames[index],
                        completeNameOfFile = null;
                    if (nameOfFile != null && file != null) { //file can be null when you click save two times continuously without change in guide context
                        completeNameOfFile = FILE_COMPONENT_NAME + "/" + nameOfFile;
                        // case: if there is a file dome
                        if (!_.isString(file)) {
                            // Check if the value exist in the file, this is done because in IE9 and IE10 the list will
                            // have an extra empty dom
                            if ($(file).val().length > 0) {
                                $(file).attr('name', completeNameOfFile);
                                attachments[fileCount] = completeNameOfFile;
                                allFiles[fileCount++] = $(file);
                            }
                        } else {
                            // since there is no file dom in case of draft usecase, make it null
                            attachments[fileCount] = file;
                            allFiles[fileCount++] = null;
                        }
                    }
                }, this);


                if (allFiles.length > 0) {

                    // since there can be a dom element which is null, in case of draft usecase
                    // get the first non null file dom
                    var firstNonNullFileDom = _.indexOf(allFiles, _.find(allFiles, function (item) {
                        return item !== null;
                    }));
                    var uploaderPluginName = formBridge.userConfig.uploaderPluginName || "adobeFileUploader";
                    if (firstNonNullFileDom !== -1) {
                        fileUrl = allFiles[firstNonNullFileDom][uploaderPluginName]("uploadFile", {
                            'fileName': attachments,
                            'fileDom': allFiles,
                            'fileUploadPath': fileUploadPath,
                            'multiple': true,
                            '_uuidGenerator': function () { return formBridge._getUUID.apply(this); },
                            _getUrl: formBridge._getUrl("")
                        });

                        /*The file url returned by file upload widget can contain context root. Remove it so that correct value gets stored in model.*/
                        if (contextRoot) {
                            if (fileUrl.indexOf(contextRoot) === 0) {
                                fileUrl = fileUrl.substring(contextRoot.length);
                            }
                        }

                        allFiles[firstNonNullFileDom].one("adobeFileUploader.multipleFileUploaded", $.proxy(callback,
                            {
                                "attachments": attachments,
                                "fileUrl": fileUrl,
                                "options": options,
                                "_uuidGenerator": function () { return formBridge._getUUID.apply(this); }
                            })
                        );
                        didSubmit = true;
                    }
                }

            }

            if (!didSubmit) {
                // if there are no files attached, still call the callback to submit the json contents
                // if there is only one file attachment component with no files, in this case else is important
                callback.apply({
                    "attachments": attachments,
                    "fileUrl": fileUrl,
                    "options": options
                });

            }

        },
        _isFileAttachmentEnabled: function () {
            return xfalib.runtime.renderContext.mfAllowAttachments === 'true';
        },
        _isLoginAnonymous: function (value) {
            var flag;
                if(xfalib.runtime) {
                    flag = xfalib.runtime._isAnonymous;
                    if(_.isUndefined(value)) {
                        return flag;
                    }
                    xfalib.runtime._isAnonymous = value;
                    return flag;
                }
        },

        _getContextRoot: function() {
            return this.userConfig["contextPath"];
        },

        getTempPath: function() {
            return "/tmp/fd/xfaforms/" + this._getUUID();
        },
        _getFileNamePathMap: function(valueList) {
            var fileWidget = this._getFileWidgetIfPresent();
            if(fileWidget) {
                return fileWidget._getFileNamePathMap(valueList);
            }
            return {};
        },






        getMultipartData: function (data) {
            //Start multipart formatting
            var initBoundary = this.randomString();
            var strBoundary = "--" + initBoundary;
            var strMultipartBody = "";
            var strCRLF = "\r\n";

            //Create multipart for each element of the form
            for (var key in data) {
                if (data.hasOwnProperty(key)) {
                    var value = typeof data[key] == "string" ? data[key] : JSON.stringify(data[key]);
                    strMultipartBody +=
                        strBoundary
                        + strCRLF
                        + "Content-Disposition: form-data; name=\"" + key + "\""
                        + strCRLF
                        + strCRLF
                        + value
                        + strCRLF;
                }
            }
            //End the body by delimiting it
            strMultipartBody += strBoundary + "--" + strCRLF;
            //Return boundary without -- and the multipart content
            return [initBoundary, strMultipartBody];
        },

        randomString: function () {
            var chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";
            var string_length = 8;
            var randomString = '';
            for (var i = 0; i < string_length; i++) {
                var rnum = Math.floor(Math.random() * chars.length);
                randomString += chars.substring(rnum, rnum + 1);
            }
            return randomString;
        },

        /*
         * returns the input data in XML Form. The call is asynchronous and recieves the following options apart from the default
         * ones provided earlier
         *      validationChecker //function to call for checking validation errors received from server
         *                          The signature for the functions is
         *                              function(validations)
         *                              {
         *                                  // validations is an array of error strings.
         *                              }
         *      formState       // The state of the XFA Form, if saved by the user, otherwise the current one
         */
        getDataXML: function (options) {
            options = options || {};
            var obj = new XFAResultObject();
            if (!options.formState && !this._checkXfa(obj)) {
                options.error.call(options.context, obj);
                return;
            }
            if(!options.formState && xfalib.ut.XfaUtil.prototype.getOrElse(xfalib.runtime, "customPropertyMap.xmlOnClient", "0") === "1") {
                try {
                    var xml = this.generateDataXML();
                    obj.data = xml;
                    if (options.success) {
                        options.success.call(options.context, obj);
                    }
                } catch(exception) {
                    var msg = "Unable to generate xml on client. Use Server option to generate the xml. " + exception;
                    this._xfa.Logger.error("xfa", msg);
                    obj.completed = false;
                    obj.addMessage(2, msg, "");
                    if(options.error) {
                        options.error.apply(options.context, [obj]);
                    }
                }
                return;
            }
            var formState = options.formState || this.getFormState(true, 2).data;
            //clone the object to avoid polluting the old copy
            var params = _.extend({formDom: formState.xfaDom, requestDataXml : "true"}, formState.renderContext);
            this._invokeAtServer({
                data: params,
                dataType: 'text',
                success: function (result) {
                    obj.completed = true;
                    if (!result) {
                        obj.addMessage(0, "There was an error in getting data xml", "");
                        options.error.call(options.context, obj);
                        return;
                    }
                    obj.data = result;
                    if (options.validationChecker) {
                        if (!options.validationChecker.call(options.context, result.validationErrors)) {
                            options.error.call(options.context, obj);
                            return;
                        }
                    }
                    if (options.success)
                        options.success.call(options.context, obj,formState);
                },
                error: function (xhr, txtStatus, errorThrown) {
                    var msg = formBridge._getDataXMLError(xhr, txtStatus, errorThrown);
                    obj.completed = false;
                    obj.addMessage(2, msg, "");
                    if (options.error) {
                        options.error.call(options.context, obj);
                    }
                    if (formBridge._xfa) {
                        formBridge._xfa.host.messageBox(msg);
                    }
                }
            });
        },

        _getDataXMLError: function (xhr, txtStatus, errorThrown) {
            var msg;
            switch (xhr.status) {
                case 0:
                    msg = xfalib.locale.LogMessages["ALC-FRM-901-008"];
                    if(this._xfa) {
                        this._xfa.Logger.error("xfa", msg + " " + xhr.statusText);
                    }
                    break;
                default:
                    msg = xfalib.locale.LogMessages["ALC-FRM-901-016"];
                    if(this._xfa) {
                        this._xfa.Logger.error("xfa", msg + " " + xhr.statusText);
                    }
                    break;
            }
            return msg;

        },

        _identifyConnectionError: function (xhr, txtStatus) {
            var msg = "";
            switch (xhr.status) {
                case 0:
                    msg = xfalib.locale.LogMessages["ALC-FRM-901-008"];
                    if(this._xfa) {
                        this._xfa.Logger.error("xfa", msg + " " + xhr.statusText);
                    }
                    break;
                case 404:
                    msg = xfalib.locale.LogMessages["ALC-FRM-901-008"];
                    if(this._xfa) {
                        this._xfa.Logger.error("xfa", msg + " " + xhr.statusText);
                    }
                    break;
            }
            return msg;


        },

        _getAllowAttachmentsFromFormState: function (formState) {
            return formState.renderContext.mfAllowAttachments === 'true';
        },

        /**
         * @public
         * This performs an ajax submit to a url.
         * This API creates a form data object and submits this object.
         * @param options
         */
        doAjaxSubmit: function(options){

            if(window.FormData){

                var psuedoForm = $("<form>"),
                    formState = options.formState || this.getFormState(true, 2).data,
                    submitServiceProxyConfig = formState.additionalSubmitInformation.userConfig["submitServiceProxyConfig"],
                    action = options.action || this._getSubmitServiceProxyUrl();

                _.each(formState.additionalSubmitInformation.formAttributesData, function (value, key) {
                    psuedoForm.attr(key, value);
                }, this);

                psuedoForm.attr("action", action);
                var $charSetField = $("<input>").attr({"type": "hidden", "name": "_charset_", "value": "UTF-8"});
                $(psuedoForm).append($charSetField);

                _.each(submitServiceProxyConfig, function (fieldValue, fieldName) {
                    var newField = $("<input>").attr("type", "hidden")
                        .attr("name", fieldName)
                        .val(fieldValue);
                    $(psuedoForm).append($(newField));
                });

                //clone the object to avoid polluting the old copy
                var params = _.extend({}, formState.customPropertyMap, {formDom: formState.xfaDom}, formState.renderContext);

                for (var param in params) {
                    if (params.hasOwnProperty(param)) {
                        newField = $("<input>").attr("type", "hidden")
                            .attr("name", param)
                            .val(params[param]);

                        $(psuedoForm).append($(newField));
                    }
                }

                var fileAttachmentEnabled = formBridge._getAllowAttachmentsFromFormState(formState);
                if (fileAttachmentEnabled) {
                    if (options.fileAttachmentMap) {
                        var fileAttachmentMapInput = $("<input>").attr("type", "hidden")
                            .attr("name", "fileAttachmentMap")
                            .val(JSON.stringify(options.fileAttachmentMap));
                        $(psuedoForm).append($(fileAttachmentMapInput));
                    } else {
                        var fileAttachmentMap = formBridge._getFileNamePathMap(),
                            fileAttachmentInputs = formBridge._getFileListFromFileWidget(),
                            fileAttachmentMapInput;

                        _.each(formBridge._getCommitValueFromFileWidget(), function (nameOfFile, index) {
                            if (_.isObject(fileAttachmentInputs[index]) && _.isString(nameOfFile) && !nameOfFile.match(/\//g)) {
                                fileAttachmentInputs[index].attr("name", nameOfFile);
                                if (!fileAttachmentMap[nameOfFile]) {
                                    fileAttachmentMap[nameOfFile] = "";
                                    $(psuedoForm).append(fileAttachmentInputs[index]);
                                }
                            }
                        });
                        fileAttachmentMapInput = $("<input>").attr("type", "hidden")
                            .attr("name", "fileAttachmentMap")
                            .val(JSON.stringify(fileAttachmentMap));
                        $(psuedoForm).append($(fileAttachmentMapInput));
                    }
                }
                //the XFAResultObject that will be passed to the success and error handler
                var obj = new XFAResultObject();

                var fd = new FormData(psuedoForm[0]);
                //set contentType to false to prevent jquery from setting it to default value
                //Setting processData to false to prevent jQuery from automatically transforming the data into a query string
                // set dataType to "text" to retrieve the xml as string.
                // The ajax call returns dataXml that is passed inside XFAResultObject.
                $.ajax({
                    url: formBridge._getUrl(action),
                    data: fd,
                    processData: false,
                    dataType:'text',
                    contentType: false,
                    type: 'POST',
                    success: function (result) {
                        obj.completed = true;
                        if (!result) {
                            obj.addMessage(0, "There was an error in submitting the form", "");
                            options.error.call(options.context, obj);
                            return;
                        }
                        obj.data = result;
                        if (options.validationChecker) {
                            if (!options.validationChecker.call(options.context, result.validationErrors)) {
                                options.error.call(options.context, obj);
                                return;
                            }
                        }
                        if (options.success) {
                            options.success.call(options.context, obj);
                        }
                    },
                    error: function (xhr, txtStatus, errorThrown) {
                        var msg = formBridge._getDataXMLError(xhr, txtStatus, errorThrown);
                        obj.completed = false;
                        obj.addMessage(2, msg, "");
                        if (options.error) {
                            options.error.call(options.context, obj);
                        }
                        if (formBridge._xfa) {
                            formBridge._xfa.host.messageBox(msg);
                        }
                    }
                });

            } else {
                options.error.call(options.context);
            }
        },

        /*
         * submits the form data to a url provided in Config or Form Template
         * The API calls getDataXML, checks validation errors and either submits the data itself
         * or passes the data to the success handler provided by the caller
         *
         */
        submitForm: function (options) {
            options = options || {};
			options.error = options.error || defaultErrorHandler;
            options.context = options.context || formBridge;
            options.validationChecker = options.validationChecker || defaultValidationChecker;
            //formBridge.keyValuePairSubmission = true;

            this.uiFreeze();   // Bug: LC-6068 To show cursor in wait state and also freezing the ui by marking root subform access as readOnly.
            var originalSuccess = options.success;
            var originalError = options.error || defaultErrorHandler;
            var originalContext = options.context;
            var that = this;

            options.error = (function () {
                return function () {
                    that.uiUnFreeze();  // Bug: LC-6068 To restore cursor from wait state and also restoring the ui by marking root subform access as its old access.
                    if (originalError) {
                        originalError.apply(originalContext, arguments);
                    }
                };
            })();
            var obj = new XFAResultObject();

            // if cancelAction property is set to true in preSubmit, execPreSubmit return false
            if (this._xfa && this._xfa.form.execPreSubmit() == false ) {
                var msg = "Submit cancelled";
                this._xfa.host.messageBox(msg);
                obj.addMessage(0, msg, "xfa");
                options.error.call(options.context, obj);
                return;
            }

            if (this._xfa && this._xfa.host._validate() == false) {
                obj.addMessage(0, "client side validations failed", "xfa"); //TODO: handlesomExpression passing
                options.error.call(options.context, obj);
                return;
            } else {
                xfalib.ut.XfaUtil.prototype._triggerOnBridge("submitStart", this, "submit");
            }
            if (options.success /*|| formBridge.keyValuePairSubmission*/) {
                /*var defaultSuccessHandler = function(obj) {
                 var formState = options.formState || this.getFormState().data;
                 //clone the object to avoid polluting the old copy
                 var params = _.extend({formDom: formState.xfaDom}, formState.renderContext);

                 for(var p in params) {
                 var field = $("<input>").attr("type", "hidden").attr("name",p).val(params[p]);
                 $("#lcforms_xfaform_container").append($(field));
                 }
                 var dataField = $("<input>").attr("type", "hidden").attr("name","data").val(obj.data);
                 $("#lcforms_xfaform_container").append($(dataField));

                 var submitServiceProxyConfig = this.userConfig["submitServiceProxyConfig"];
                 var submitUrl = options.action || submitServiceProxyConfig.submitUrl;
                 $("#lcforms_xfaform_container").attr("action", submitUrl);
                 $("#lcforms_xfaform_container").submit();
                 }
                 options.success = options.success || defaultSuccessHandler*/
                //Submit from form bridge api

                options.success = (function () {
                    return function () {
                        that.uiUnFreeze();  // Bug: LC-6068 To restore cursor from wait state and also restoring the ui by marking root subform access as its old access.
                        if (originalSuccess) {
                            originalSuccess.apply(originalContext, arguments);
                        }
                    };

                })();
                formBridge.doAjaxSubmit(options);
            }
            else {
                //Always submit form state to submitServiceProxy and then the proxy will in-turn submit the data xml to the submitUrl on behalf of MobileForm
                //create a psuedo form element and do submission
                var cont = true;
                var behaviorConfig = new xfalib.ut.Version(formBridge.userConfig["behaviorConfig"]);
                //To maintain backward compatibility
                if (!behaviorConfig.isOn('disableHeadRequest') && !behaviorConfig.isOn('mfDisableHeadRequest')) {
                    $.ajax({
                        async: false,
                        url: this._getSubmitServiceProxyUrl(),
                        type: 'HEAD',
                        complete: function (xhr, txtStatus) {
                            var msg = formBridge._identifyConnectionError(xhr, txtStatus);
                            if (msg) {
                                obj.completed = false;
                                obj.addMessage(2, msg, "");
                                if (options.error) {
                                    options.error.call(options.context, obj);
                                }
                                if (formBridge._xfa) {
                                    formBridge._xfa.host.messageBox(msg);
                                }
                                cont = false
                            }
                        }
                    });
                }

                if (cont) {
                    var action = this._getSubmitServiceProxyUrl();

                    var submitServiceProxyConfig = this.userConfig["submitServiceProxyConfig"];

                    var psuedoForm = $("<form>");

                    var formState = options.formState || this.getFormState(true, 3).data;

                    //add the additionalInformation
                    _.each(formState.additionalSubmitInformation.formAttributesData,function(value,key){
                        psuedoForm.attr(key, value);
                    },this);

                    //override action
                    psuedoForm.attr("action", action);

                    //Add _charset_ to let sling know that it should decode in UTF-8
                    var $charSetField = $("<input>").attr("type", "hidden").attr("name", "_charset_").val("UTF-8");
                    $(psuedoForm).append($charSetField);

                    behaviorConfig = this.userConfig["behaviorConfig"];

                    //add supporting fields to psuedo form
                    submitServiceProxyConfig.submitUrl = options.action || submitServiceProxyConfig.submitUrl;
                    for (var fieldName in submitServiceProxyConfig) {
                        if (submitServiceProxyConfig[fieldName]) {
                            var newField = $("<input>").attr("type", "hidden")
                                .attr("name", fieldName)
                                .val(submitServiceProxyConfig[fieldName]);

                            $(psuedoForm).append($(newField));
                        }
                    }
                    var fileAttachmentEnabled = formBridge._isFileAttachmentEnabled();
                    if (!fileAttachmentEnabled) {

                        //clone the object to avoid polluting the old copy
                        var params = _.extend({}, formState.customPropertyMap, {formDom: formState.xfaDom}, formState.renderContext);

                        for (var param in params) {
                            if (params[param]) {
                                var newField = $("<input>").attr("type", "hidden")
                                    .attr("name", param)
                                    .val(params[param]);

                                $(psuedoForm).append($(newField));
                            }
                        }

                        //for IE as you cannot submit a form without attaching it to document.
                        $("#lcforms_xfaform_container").append($(psuedoForm));
                        $(psuedoForm).submit();

                    } else {

                        var fileAttachmentMap = formBridge._getFileNamePathMap(),
                            fileAttachmentInputs = formBridge._getFileListFromFileWidget(),
                            fileAttachmentMapInput ;
                        //clone the object to avoid polluting the old copy
                        params = _.extend({}, formState.customPropertyMap, {formDom: formState.xfaDom}, formState.renderContext);

                        for (param in params) {
                            if (params[param]) {
                                var newField = $("<input>").attr("type", "hidden")
                                    .attr("name", param)
                                    .val(params[param]);

                                $(psuedoForm).append($(newField));
                            }
                        }
                        _.each(formBridge._getCommitValueFromFileWidget(), function (nameOfFile, index) {
                            if( _.isObject(fileAttachmentInputs[index]) && _.isString(nameOfFile) && !nameOfFile.match(/\//g)) {
                                fileAttachmentInputs[index].attr("name", nameOfFile);
                                if(!fileAttachmentMap[nameOfFile]) {
                                    fileAttachmentMap[nameOfFile] ="";
                                    $(psuedoForm).append(fileAttachmentInputs[index]);
                                }
                            }
                        });
                        fileAttachmentMapInput =  $("<input>").attr("type", "hidden")
                            .attr("name", "fileAttachmentMap")
                            .val(JSON.stringify(fileAttachmentMap));
                        $(psuedoForm).append($(fileAttachmentMapInput));

                        //for IE as you cannot submit a form without attaching it to document.
                        $("#lcforms_xfaform_container").append($(psuedoForm));
                        $(psuedoForm).submit();

                    }
                }
            }
            //if submit is successful, we navigate to another page so no need to call uiUnFreeze.
        },

        uiFreeze: function () {
            var $xfa_ui_freeze = $('#lcforms_xfaform_container > #xfa_ui_freeze');
            if ($xfa_ui_freeze.length > 0) {
                $xfa_ui_freeze.show()
            } else {
                $('#lcforms_xfaform_container').append('<div id="xfa_ui_freeze"></div>');
            }
        },

        uiUnFreeze: function () {
            $('#lcforms_xfaform_container > #xfa_ui_freeze').hide();
        },

        /**
         * Get all the fields in the form.
         * @param filter filter function to tell which fields to return. The
         *               function will be passed each field in the form and if
         *               it returns true the field will be returned otherwise not.
         *               **Doesn't return Master Page Fields**
         *               **Renders all pages in the process**
         * @return {Array}
         */
        getAllFields: function (filter) {
            var allFields = [];
            for (var page = 0; page < this._xfa.layout.pageCount(); page++) {
                var pageFields = this._xfa.layout.pageContent(page, "field");
                for (var i = 0; i < pageFields.length; i++) {
                    var field = pageFields.item(i);
                    if (_.isUndefined(filter) || _.isNull(filter) || filter.apply(window, [field]) === true) {
                        allFields.push(field);
                    }
                }
            }
            return allFields;
        },

        /**
         * Get the current field in focus.
         * @return {*}
         */
        getFocus: function () {
            if (this._xfa.host.getFocus) {
                var obj = this._xfa.host.getFocus();
                if (obj)
                    return this._xfa.host.getFocus().somExpression;
                return null;
            }
            else
                return "unsupported";
        },

        /*
         * Validate the form.
         * Run client side validations.
         *
         *
         */
        validateForm: function (options) {
            options = options || {};
            options.error = options.error || defaultErrorHandler;
            options.context = options.context || this;
            var valMessages = [];
            var validationsValue = this._xfa.host._validate({
                valMessages: valMessages
            });

            var obj = new XFAResultObject();
            if (!this._checkXfa(obj))
                throw obj.getNextMessage().message;

            if (validationsValue == false) {
                obj.addMessage(0, "client side validations failed", "xfa");
                _.each(
                    _.filter(valMessages, function (msg) {
                        return msg.severity === "error"
                    }),
                    function (msg) {
                       obj.addMessage(1, msg.message, msg.ref)
                    }
                );
                options.error.call(options.context, obj);
            }
            else if (options.success)
                options.success.call(options.context, obj);

            return validationsValue;
        },
        //--checking for browser compatibility
        _isBrowserCompatible: function () {
            var isWin = false;
            var isMac = false;
            var isiPad = false;
            var isAndroid = false;
            var isWebKit = false;
            if (navigator.appVersion.indexOf("Win") != -1)
                isWin = true;
            else if (navigator.appVersion.indexOf("Mac") != -1)
                isMac = true;
            else if (navigator.userAgent.match(/iPad/i) != null)
                isiPad = true;
            else if (navigator.userAgent.toLowerCase().indexOf("android") > -1)
                isAndroid = true;
            if (navigator.userAgent.toLowerCase().indexOf("webkit") > -1)
                isWebKit = true;

            var browserVersion = parseInt($.browser.version, 10);
            if (isWin && ($.browser.msie && (browserVersion == 6 || browserVersion == 7 || browserVersion == 8)))
                return false;
            else if (isWin && (isWebKit || $.browser.mozilla || ($.browser.msie && (browserVersion == 9 || browserVersion == 10)))) {
                return true;
            }
            else if ((isMac || isiPad || isAndroid) && isWebKit) {
                return true;
            }
            else {
                return false;
            }
        },
        /*
         * Restores the Form State to a previous state. This is a Asynchronous call and recieves a formState from the
         * caller. The state will be applied and success or error handlers will be called after the operation is
         * completed.
         */
        restoreFormState: function (options) {
            if (window.atob && options.base64FormState !== undefined) {
                // Decode base 64 encoded string to form the form DOM object.
                var utftext = atob(options.base64FormState),
                    string = "",
                    i = 0,
                    c = 0,
                    c1 = 0,
                    c2 = 0,
                    c3 = 0;
                while ( i < utftext.length ) {
                    c = utftext.charCodeAt(i);
                    if (c < 128) {
                        string += String.fromCharCode(c);
                        i++;
                    }
                    else if((c > 191) && (c < 224)) {
                        c2 = utftext.charCodeAt(i+1);
                        string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                        i += 2;
                    }
                    else {
                        c2 = utftext.charCodeAt(i+1);
                        c3 = utftext.charCodeAt(i+2);
                        string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
                        i += 3;
                    }
                }
                utftext = string;
                var formDom = JSON.parse(utftext);
                options.formState = formDom;
            }

            /*
             * We have to merge the runtime renderContext with the renderContext of the formState passed
             * so that no custom properties that were set in the context(present in the form state) are ignored.
             */
            xfalib.runtime.renderContext = xfalib.runtime.renderContext || {};
            _.extend(xfalib.runtime.renderContext, options.formState.renderContext);
            if (!this._xfa) {
                this.storage = {};
                this.storage.formState = options.formState;
                this.storage.error = options.error;
                this.storage.success = options.success;
                this.storage.context = options.context;
            } else {
                this._xfa.host.playJson(JSON.parse(options.formState.xfaDom));
                this.customContextProperty(options.formState.customPropertyMap);
                if(_.isFunction(options.success)) {
                    options.success.call(this);
                }
            }
        },
        customContextProperty: function(property,value) {
            var customPropertyMap = xfalib.runtime.customPropertyMap || {};
            if(_.isUndefined(value)) {
                if(_.isObject(property)) {
                    _.extend(customPropertyMap, property);
                    xfalib.runtime.customPropertyMap=customPropertyMap;
                } else {
                return customPropertyMap[property];
                }
            } else {
                var oldValue = customPropertyMap[property];
                customPropertyMap[property]=encodeURIComponent(value);
                xfalib.runtime.customPropertyMap=customPropertyMap;
                return oldValue;
            }
        },
        /*
         * @private
         */
        _getStorage: function () {
            var s = null;
            if (this.storage) {
                var s = this.storage.formState
                this.storage.formState = null;
            }
            return s;
        },

        _getXmlStorage: function () {
            var s = null;
            if (this.xmlStorage) {
                var s = this.xmlStorage.xmlDocument;
                this.xmlStorage.xmlDocument = null;
            }
            return s;
        },

        /*
         * @private
         */
        _getHTMLElement: function (somExpression, full) {
            var obj = this._getHTMLElementInternal(somExpression, full,this._formDoc);
            return obj;
        },

        _getHTMLElementInternal: function(somExpression, full,referenceDocument){
            somExpression = full === true ? somExpression : "xfa[0].form[0]." + somExpression;
            var obj = new XFAResultObject();
            if (!this._checkXfa(obj))
                return obj;
            var elem = this._xfa.resolveNode(somExpression);
            if (_.isEmpty(elem)){
                obj.addMessage(0, somExpression + " not found", somExpression);
            } else {
                var elemId = xfalib.ut.XfaUtil.prototype.jqId(elem.htmlId);
                $(elemId, referenceDocument).children();
                switch (elem.className) {
                    case "instanceManager":
                        obj.addMessage(0, "No HTML Element exists for instanceManagers", somExpression);
                        break;
                    case "subform":
                        obj.data = {elem: $(elemId, referenceDocument)[0]}
                        break;
                    case "field":
                        var data = $(elemId, referenceDocument);
                        var child = data.children();

                        obj.data = {
                            elem: data[0],
                            caption: child[0],
                            widget: { elem: child[1],
                                child: $("input,select", child[1])[0]
                            }
                        };
                        if (!obj.data.widget) {
                            obj.data.widget = {
                                elem: child[0],
                                child: $("input,select", child[0]) [0]
                            }
                        }
                        break;
                    default:
                        obj.data = {elem: $(elemId, referenceDocument)[0]};
                        break;
                }
            }
            return obj;
        },

        _postExternalMessage: function (message) {
            if (this.userConfig["postExternalMessageConfig"] && _.isFunction(this.userConfig["postExternalMessageConfig"]["postExternalHandler"])) {
                var externalHandler = this.userConfig["postExternalMessageConfig"]["postExternalHandler"];
                externalHandler(message);
            }
        },

        scaleForm: function (viewportWidth) {
            if (viewportWidth) {
                this.userConfig["viewportWidth"] = viewportWidth;
                window.xfaViewRegistry.scaleForm();
            }
        },

        /**
         * This function hides the toolbar where required.
         * @memberof FormBridge
         */
        hideToolbar: function(){
          $(".toolbarheader").hide();
        },

        /**
         * Used to Register an event listener for specific Form Bridge Event.
         * @param eventName {string} name of the event for which listener has to be added. It must be one of the events
         * mentioned in the documentation.
         * @param handler {function} event listener which is called when the event is triggered.
         * @param [context] {object} context is used as the <i>this</i> object inside handler function
         */

        on: function (eventName, handler, context) {
            this._$target.on(eventName, handler, context);
        },


        /**
         * Unregister the event registered using the {@link FormBridge.on|on} function
         *
         * @param eventName {string} name of the event to un-register.
         * @param [selector] {string} selector which should match the one originally passed to FormBridge's on() while registering handlers
         * @param [handler] {function} handler which needs to un-registered. If not provided all the event listeners
         * will be unregistered
         */

        off: function (eventName, selector, handler) {
            this._$target.off(eventName, selector, handler);
        },

        /**
         * Internal API
         *
         * @private
         */

        trigger: function (eventName, extraParamerts) {
            if(this.isAnalyticsEnabled || eventName == xfalib.template.Constants.scribbleChangeEvent) {
                this._$target.trigger(eventName, extraParamerts);
            }
        },

        /**
         * constructs the dataSomMap and returns that. If a valid object is provided as the first argument then it
         * modifies and adds entries in that map only, otherwise constructs a new map.
         * @param map {object}
         * @returns {XFAResultObject} with the data parameter as the dataSomMap
         */
        getDataSomMap: function (map) {
            var obj = new XFAResultObject();
            if (!this._checkXfa(obj)) {
                return obj;
            }
            var _map = map;
            if(!_.isObject(map)) {
                _map = {};
            }
            _map = this._xfa.form._getDataSomMap(_map);
            obj.data = _map;
            return obj;
        },

        /**
         * Updates the field values with the values provided in the map. If map is not an object, returns an error.
         * @param map {object}
         * @return {XFAResultObject} with the data parameter as null.
         */
        restoreDataSomMap: function (map) {
            var obj = new XFAResultObject();
            if (!this._checkXfa(obj)) {
                return obj;
            }
            if(!_.isObject(map)) {
                obj.addMessage(0, "Invalid Argument passed. First argument has to be an object", null);
                return obj;
            }
            this._xfa.form._restoreDataSomMap(map);
            obj.data = null;
            return obj;
        },

        /**
         * Namespace resolver needed for xpath resolution. We need to add more namepsaces
         * @param prefix
         * @returns {*|null}
         */
        nsResolver : function (prefix) {
            var ns = {
                'xfa' : 'http://www.xfa.org/schema/xfa-data/1.0/',
                'xdp' : 'http://ns.adobe.com/xdp/'
            };
            return ns[prefix] || null;
        },

        /**
         * merges the Form with the xmlDocument provided
         * @param options {object} with the folllowing syntax
         *  {
         *   xmlDocument
         *   success: function() {}
         *   error: function(xfaResultObject) {}
         *   context:
         *  }
         * @return {XFAResultObject} with the data parameter as null.
         */
        playDataXML: function(options) {
            if (!this._xfa) {
                this.xmlStorage = {};
                this.xmlStorage.xmlDocument = options.xmlDocument;
                this.xmlStorage.error = options.error || defaultErrorHandler;
                this.xmlStorage.success = options.success;
                this.xmlStorage.context = options.context;
            } else {
                var obj = new XFAResultObject(),
                    options = options || {},
                    error = options.error || defaultErrorHandler,
                    success = options.success,
                    xmlDocument = options.xmlDocument,
                    rootElement;
                if(xmlDocument == null) {
                    obj.addMessage(0, "Invalid Argument Error. XML Document is not defined", null);
                    error.apply(options.context, [obj]);
                    return;
                }
                if(_.isString(xmlDocument)) {
                    this._xfa.Logger.info("xfa", "xmlDocument is of type string. converting it to document");
                    try {
                        xmlDocument = $.parseXML(xmlDocument);
                    } catch(e) {
                        obj.addMessage(2, "Unable to parse Data XML " + e, null);
                        error.apply(options.context, [obj]);
                        return;
                    }
                }
                if(!(xmlDocument instanceof Document) && !(xmlDocument instanceof Element)) {
                    obj.addMessage(1, "Invalid Argument Error. XML Document is not an instance of Document or Element", null);
                    error.apply(options.context, [obj]);
                    return;
                }
                try {
                    this._xfa.host.playDataXml(xmlDocument);
                } catch(e) {
                    obj.addMessage(2, "Unexpected Exception: Unable to play Data XML " + e, null);
                    error.apply(options.context, [obj]);
                }
                if(success) {
                    success.apply(options.context,[obj]);
                }
            }
        },

        /**
         * Returns Data XML of the Form. If dataXML is passed, it is merged with
         * the Data XML.
         * @returns {string|Node} If dataXML input is String, it returns string, otherwise
         *                        dataXML is updated and returned
         *                        Returns null in case it fails to generate data xml.
         * @param bGenerateXDPRoot whether to generate the xdp root if it doesn't exists
         * @param dataXML {Element|Document|String} If dataXML passed is document or Element, it updates that and
         * returns it. In case of string a new string is returned.
         */
        generateDataXML: function (dataXML, bGenerateXDPRoot) {
            if(_.isUndefined(document.evaluate)) {
                // need to do it here since XPathResult is also undefined in IE
                wgxpath.install();
            }
            try {
                var prefillXML = dataXML || xfalib.runtime.renderContext.data,
                    rootSubform = this._xfa.form._getRootSubform(),
                    bAddXDPRoot = !(bGenerateXDPRoot === false),
                    impl, xmlDoc, xdpElement, datasets, data, rootNode, xPathResult, newXmlDoc;
                if (prefillXML == null) {
                    impl    = document.implementation;
                    xmlDoc  = impl.createDocument ('http://ns.adobe.com/xdp/', 'xdp:xdp', null);
                    datasets = xmlDoc.createElementNS("http://www.xfa.org/schema/xfa-data/1.0/", "xfa:datasets");
                    data = xmlDoc.createElement("xfa:data");
                    rootNode = xmlDoc.createElement(rootSubform.getAttribute("name"));
                    data.appendChild(rootNode);
                    datasets.appendChild(data);
                    xmlDoc.documentElement.appendChild(datasets);
                } else {
                    xmlDoc = prefillXML;
                    if(_.isString(xmlDoc)) {
                        this._xfa.Logger.info("xfa", "xmlDocument is of type string. converting it to document")
                        xmlDoc = $.parseXML(xmlDoc);
                    }
                    rootNode = xfalib.ut.XMLUtils.getXFARootFormElementFromXML(xmlDoc);
                    var xmlDocElement = xmlDoc instanceof Element ? xmlDoc : xmlDoc.documentElement;
                    if (bAddXDPRoot && xmlDocElement.nodeName !== "xdp:xdp") {
                        impl    = document.implementation;
                        xmlDoc  = impl.createDocument ('http://ns.adobe.com/xdp/', 'xdp:xdp', null);
                        datasets = xmlDoc.createElementNS("http://www.xfa.org/schema/xfa-data/1.0/", "xfa:datasets");
                        data = xmlDoc.createElement("xfa:data");
                        rootNode = xmlDoc.importNode(rootNode, true);
                        data.appendChild(rootNode);
                        datasets.appendChild(data);
                        xmlDoc.documentElement.appendChild(datasets);
                    }
                }
                rootSubform.generateDataXML(rootNode, rootNode);
                if(prefillXML == null || _.isString(prefillXML)) {
                    return new XMLSerializer().serializeToString(xmlDoc.documentElement);
                } else {
                    return xmlDoc;
                }
            } catch(e) {
                this._xfa.Logger.error("xfa", "Error in Generating Data XML on Client " + e);
                return null;
            }
        },

        /**
         * Destroy Mobile Form so that another form can be rendered. if bFull parameter
         * is passed as true, then all the scripts are destroyed as well.
         * @param bFull
         */
        destroyForm: function (bFull) {
            $("#mfstyle").remove();
            var oldMap = xfalib.runtime.customPropertyMap;
            // In adaptive form, we never use the view layer of mobile forms, hence adding null check
            if(xfaViewRegistry != null) {
                xfaViewRegistry.rootSubformView = null;
                xfaViewRegistry.clearTemplateCache();
                xfaViewRegistry.resetLayoutManager();
            }
            xfalib.runtime = {
                xfa: null,
                app: null,
                Document: null,
                form: null,
                renderContext: null,
                _private: {},
                customPropertyMap: oldMap
            };
            if(xfalib.runtime.console) {
                xfalib.runtime.console = undefined;
            }
            this._xfa = null;
            xfalib.script.Xfa.Instance = null;
            $(window).trigger("destroy.xfa");
            $(window).off(".xfa");
            xfalib.view.util.TextMetrics._destroy();
            xfalib.view.util.traversalManager._destroy();
            xfalib.view.FieldView.prototype._clearFocusInfo();
            if(bFull === true) {
                $(window).off();
                $("body").empty();
                //this is added by FileAttachment. It should have been
                // a namespace event
                $(document).off("mousedown");
                _.each(xfalib, function (obj, key) {
                   xfalib[key] = undefined;
                });
                xfalib = null;
                wgxpath = undefined;
                FormCalc = undefined;
                // In adaptive form, we never use the view layer of mobile forms, hence adding null check
                if(xfaViewRegistry != null) {
                    xfaViewRegistry.destroy();
                    xfaViewRegistry = undefined;
                }
                $.Widget = undefined;
                $.widget = undefined;
                $.xfaWidget = undefined;
                $.fn = undefined;
                $.prototype.abstractWidget = undefined;
                $.prototype.adobeDateTimePicker = undefined;
                $.prototype.adobeFileAttachment = undefined;
                $.prototype.adobeFileUploader = undefined;
                $.prototype.dateTimeEdit = undefined;
                $.prototype.dropDownList = undefined;
                $.prototype.defaultWidget = undefined;
                $.prototype.fileUpload = undefined;
                $.prototype.imageField = undefined;
                $.prototype.listBox = undefined;
                $.prototype.nwkListBox = undefined;
                $.prototype.numericInput = undefined;
                $.prototype.signatureField = undefined;
                $.prototype.ScribbleImageField = undefined;
                $.prototype.textField = undefined;
                $.prototype.xfaButton = undefined;
                $.prototype.XfaCheckBox = undefined;
                $.expr = undefined;
                window.formBridge = undefined;
                FormBridge = undefined;
                window.renderNextPage = undefined;
                window.handleFooterLogic = undefined;
                window.handleScroll = undefined;
                optionsFromProfileNode = undefined;
                options = undefined;
                FD = undefined;
                window._ = undefined;
                $plugFileWidgetDom = undefined;
            }
        }
    });

    window.formBridge = new FormBridge();
    window.formBridge._$target = $(window.formBridge);
    try {
        var evnt = document.createEvent("CustomEvent");
        evnt.initCustomEvent("FormBridgeInitialized", true, true, {"formBridge": window.formBridge});
        window.dispatchEvent(evnt);
    }

    catch (exception) {
        // written for env rhino to execute(for server side validation)
    }

    if (!window.formBridge.userConfig["postExternalMessageConfig"]) {
        if (window !== window.parent) {
            try {
                window.parent.document.getElementById(window.name);
                //We are here means no cross domain issue. So if user has not defined custom postExternalMessageConfig and
                // then we'll create one which would just send event on parent.
                window.formBridge.registerConfig("postExternalMessageConfig", {
                    "postExternalHandler": function (message) {
                        var tmpEvent = document.createEvent("CustomEvent");
                        tmpEvent.initCustomEvent(message.name, true, true, message.data);
                        window.parent.dispatchEvent(tmpEvent);
                    }
                });
            } catch (e) {
                //ignore the error
            }
        }
    }
    window.formBridge._postExternalMessage({
        name: "FormBridgeInitialized",
        data: {
            "formBridge": window.formBridge
        }
    });
})($);

/**
 * This should house all the internal APIs added tp FormBridge
 * Created by sasdutta on 12/23/2014.
 */

(function ($, _, formBridge) {
    formBridge.internal = {

        /**
         * Get SOM expressions of all the fields in the form, including master page fields
         *
         * @return {Array} of som expressions as strings.
         */
        getAllFieldsSom: function () {
            var fieldsSom = [];
            function getAllFieldsSomVisitor(target) {
                if (target instanceof xfalib.script.Field) {
                    fieldsSom.push(target.somExpression);
                }
            }

            formBridge._xfa.form._getRootSubform()._visitAllmoChildren(getAllFieldsSomVisitor);
            return fieldsSom;
        },

        /**
         * @param pageNum {int} scroll to specified pg no if available
         * @returns nothing
         * @private
         */
        scrollToPage: function (pageNum) {
            if (pageNum > 0 && pageNum <= formBridge.pagingManager().pageCount()) {
                formBridge.pagingManager()._makePage(pageNum);

                var $targetPg = $("#lcforms_xfaform_container .page").eq(pageNum - 1); // zero based index in JQ

                setTimeout(function () {
                    $(window).scrollTop($targetPg.offset().top); // newly added pages need time to render
                });
            }
        },

        resolveNode: function (somExpression) {
            return formBridge._xfa.resolveNode(somExpression);
        },

        pageCount: function () {
            return formBridge.pagingManager().pageCount();
        },

        page: function (fieldNode) {
            return formBridge._xfa.$layout.page(fieldNode);
        },

        normalizeSom: function (som) {
            // adding index and prefix to the som expression as obtained from designer
            if(!_.isString(som)) {
                return null;
            }
            som = som.replace(/\s/g, '');
            var xfaPrefix = "xfa[0].form[0].",
                normalizedSom = (som + ".").replace(/(\])?\./g, function ($0, $1) { return $1 ? $0 : '[0].'; }).slice(0, -1);

            if(normalizedSom.slice(0,xfaPrefix.length) !== xfaPrefix) {
                normalizedSom = xfaPrefix + normalizedSom;
            }
            return normalizedSom;
        }
    };
}($, _, window.formBridge));

/*******************************************************************************
 * ADOBE CONFIDENTIAL
 *  ___________________
 *
 *   Copyright 2013 Adobe Systems Incorporated
 *   All Rights Reserved.
 *
 *  NOTICE:  All information contained herein is, and remains
 *  the property of Adobe Systems Incorporated and its suppliers,
 *  if any.  The intellectual and technical concepts contained
 *  herein are proprietary to Adobe Systems Incorporated and its
 *  suppliers and are protected by all applicable intellectual property
 *  laws, including trade secret and copyright laws.
 *  Dissemination of this information or reproduction of this material
 *  is strictly forbidden unless prior written permission is obtained
 *  from Adobe Systems Incorporated.
 ******************************************************************************/

/**
 * This object hosts FormCalc build-in functions
 */
FormCalc = function(){};


FormCalc.convertArgumentsToArray = function() {
    var args= [];
    for (var i = 0;i<arguments.length;i++) {
        if(arguments[i] instanceof Array) {
            args = args.concat(arguments[i])
        }
        else {
            args.push(arguments[i])
        }
    }
    return args;
}

////Arithmetic Built-in Functions
/**
 * Returns the average of the non-null elements of a given set of numbers.
 */
FormCalc.avg = function(){
    var args = this.convertArgumentsToArray.apply(this,arguments);
	return FormCalc.runWithNumericArgs(function(){
        var sum = 0 ;
        var valid_count = 0;
        for(var idx=0; idx<arguments.length; idx++ ){
        		sum += arguments[idx];
        		valid_count++;
        }
        return valid_count ? sum/valid_count :null;
	}, args);
};

/**
 * Returns the count of the non-null elements of a given set of numbers.
 */
FormCalc.count = function(){
    var args = this.convertArgumentsToArray.apply(this,arguments);
    var argus = FormCalc.limitAllNullArgs(args);
	return argus.length ? argus.length : 0
};

/**
 * Returns the max of the non-null elements of a given set of numbers.
 */
FormCalc.max = function(){
    var args = this.convertArgumentsToArray.apply(this,arguments);
    return FormCalc.runWithNumericArgs(Math.max, args);
};

/**
 * Returns the min of the non-null elements of a given set of numbers.
 */
FormCalc.min = function(){
    var args = this.convertArgumentsToArray.apply(this,arguments);
    return FormCalc.runWithNumericArgs(Math.min, args);
};

/**
 * Returns the modulus of one number divided by another..
 */
FormCalc.mod = function(a,b){
	if(b==0 ){
		throw "<missing or illegal parameter(s).>";
	}
	return a%b;
};

/**
 * Returns the sum of the non-null elements of a given set of numbers.
 */
FormCalc.sum = function(){
    var args = this.convertArgumentsToArray.apply(this,arguments);
    return FormCalc.runWithNumericArgs(function(){
    	var result = 0;
        for(var idx=0;idx<arguments.length;idx++ ){
        	result += arguments[idx];
        }
        return result;
	}, args);
};

/**
 * Returns a number rounded to a given number of decimal places
 */
FormCalc.round = function(n1,n2){
	if(!FormCalc.isNumeric(n1)){
		return 0;
	}
	if(arguments.length == 1) {
        return Math.round(n1);
    }else if(arguments.length == 2){
    	if(n2==null){
    		return null;
    	}
    	
    	n1 = parseFloat(n1);
    	if(n2 > 12){
    		n2 = 12;
    	}
    	if(isNaN(n1) || !isFinite(n1)){
    		return n1;
    	}else{
    		return n1.toFixed(n2);    		
    	}	
    }
};

/**
 * Returns the radian value of a given number.
 */
FormCalc.deg2Rad = function(angle){
	return FormCalc.isNumeric(angle) ? (angle / 180) * Math.PI :null;
};

/**
 * Returns the degree value of a given number.
 */
FormCalc.rad2Deg = function(radio){
	return FormCalc.isNumeric(radio) ? radio * 180 / Math.PI : null;	
};
////String Built-in Functions 
/**
 * Locates the starting character position of string s2 within string s1.
 */
FormCalc.at = function(n1,n2){
	return n1.indexOf(n2) + 1;
};

/**
 * Returns the string concatenation of a given set of strings.
 */
FormCalc.concat = function(){
	var sArray = new Array();
	for(var i=0;i<arguments.length;i++){
		if(arguments[i]!=null){
			sArray[sArray.length] = arguments[i].toString();
		}
	}

	if(sArray.length == 0){
		return null;
	}else{
		return sArray.join("");
	}
};

/**
 * Extracts a number of characters from a given string, 
 * starting with the first character on the left.
 */
FormCalc.left = function(s,n){
	if(s==null){
		return null;
	}
	return s.substring(0,n);
};

/**
 * Extracts a number of characters from a given string, 
 * beginning with the last character on theright.
 */

FormCalc.right = function(s,n){
	if(s==null){
		return null;
	}
	return s.substring(s.length-n,s.length);
};

/**
 * Returns the number of characters in a given string.
 */
FormCalc.len = function(s){
	if(s==null){
		return 0;
	}else{
		return s.toString().length;		
	}
};

/**
 * Returns a string with all leading white space characters removed.
 */
FormCalc.ltrim = function(s){
	if(s==null){
		return null;
	}
	return s.replace(/^\s+/,"");
};

/**
 * Returns a string with all trailing white space characters removed.
 */
FormCalc.rtrim = function(s){
	if(s == null){
		return null;
	}
	return s.replace(/\s+$/,"");
};

/**
 * Replaces all occurrences of one string with another within a given string.
 */
FormCalc.replace = function(s1, s2, s3) {
	if(s1 == null){
		return null;
	}
	if (undefined == s3) {
		s3 = "";
	}
	return s1.replace(s2, s3);
};

/**
 * returns a string consisting of a given number of blank spaces.
 */
FormCalc.space = function(n){
	var sArray = new Array();
	var num = Math.floor(n);
	for(var i=0;i<num;i++){
		sArray[sArray.length]=" ";
	}
	return sArray.join("");
};

/**
 * Extracts a portion of a given string.
 * 
 */
FormCalc.substr = function(s1,n1,n2){
    if(n2<=0){
    	return "";
    }
    if(n1 < 1){
    	n1 = 1;
    } else if(n1 > s1.length){
    	n1 = s1.length;
    }
	return s1.substring(n1-1,n1-1+n2);
};

/**
 * Inserts a string into another string.
 * 
 */
FormCalc.stuff = function(s1, n1, n2, s2){
    if(n2<0){
    	n2=0;
    }
    if(n1 < 1){
    	n1 = 1;
    } else if(n1 > s1.length){
    	n1 = s1.length;
    }
    if(s2 == undefined){
    	s2="";
    }
	return s1.substring(0, n1-1) + s2 + s1.substring(n1 + n2-1,s1.length);
};

/**
 * Returns a string where all given uppercase characters are converted to lowercase.
 */
FormCalc.lower = function(s1){
	if(s1==null){
		return null;
	}else{
		return s1.toLowerCase();		
	}
};

/**
 * Returns a string with all given lowercase characters converted to uppercase.
 */
FormCalc.upper = function(s1){
	if(s1==null){
		return null;
	}else{
		return s1.toUpperCase();		
	}
};

/**
 * Selects a value from a given set of parameters.
 */
FormCalc.choose = function(n1,s1){
	if(n1 < 1){
		return "";
	}
	if(n1 < arguments.length){
		return arguments[n1];
	} else {
		return "";
	}
};
	
/**
 * Returns true if a value is in a given set.
 */
FormCalc.oneof = function(s1, s2){
	for(var idx = 1; idx < arguments.length; idx++){
		if(s1 == arguments[idx]){
			return true;
		}
	}
	return false;
};

/**
 * This logical function returns true if a value is within a given range.
 */
FormCalc.within = function(s1, s2, s3){
	return (s1>=s2 && s1<=s3);
}

/**
 * 
 */
FormCalc.iffun = function(s1, s2, s3){
	FormCalc.checkMinArgs(arguments.length, 2);
	FormCalc.checkMaxArgs(arguments.length, 3);
	if(s1){
		return s2;
	}else{
		return s3;
	}
};


/**
 * Returns the annual percentage rate for a loan.
 */
FormCalc.apr = function(nPrincipal, nPayment, nPeriods) {
	FormCalc.checkMinArgs(arguments.length, 3);
	FormCalc.checkMaxArgs(arguments.length, 3);
	if (nPrincipal <= 0 || nPayment <= 0 || nPeriods < 0) {
		throw "<missing or illegal parameter(s).>";
	}
	
	var maxIterations = 500;
	var eps = 0.005;
	var delta = 0.0000001;
	var nInterest = 0.05;
	var nPmtZero = nPrincipal / nPeriods;
	var nPmtCur = FormCalc.loanPmt(nPrincipal, nInterest, nPeriods);
	var i = 1;

	do {
		if (Math.abs(nPmtCur - nPmtZero) < delta)
			break;
		nInterest *= (nPayment - nPmtZero) / (nPmtCur - nPmtZero);
		nPmtCur = FormCalc.loanPmt(nPrincipal, nInterest, nPeriods);
	} while (!(++i > maxIterations || Math.abs(nPayment - nPmtCur) < eps));
	var nRate = (Math.abs(nPmtCur - nPmtZero) < delta) ? 0 : 12 * nInterest;
	return FormCalc.checkResult(nRate);
};

/**
 * Returns the number of periods needed for an investment earning a fixed, but compounded,
 * interest rate to grow to a future value.
 */
FormCalc.cterm = function(nInterest, nFuture, nPresent) {
	FormCalc.checkMinArgs(arguments.length, 3);
	FormCalc.checkMaxArgs(arguments.length, 3);
	if (nInterest <= 0 || nFuture <= 0 || nPresent < 0) {
		throw "<missing or illegal parameter(s).>";
	}
	var nPeriods = Math.log(nFuture / nPresent) / Math.log(1 + nInterest);
	return FormCalc.checkResult(nPeriods);
};

/**
 * Returns the future value of periodic constant payments at a constant interest rate.
 */
FormCalc.fv = function(nPayment, nInterest, pnPeriods) {
	FormCalc.checkMinArgs(arguments.length, 3);
	FormCalc.checkMaxArgs(arguments.length, 3);
	var nPeriods = parseInt(pnPeriods);
	if (nPeriods <= 0 || nPayment <= 0 || nInterest < 0) {
		throw "<missing or illegal parameter(s).>";
	}

	var nVal;
	if (nInterest == 0) {
		nVal = nPayment * nPeriods;
	} else {
		nVal = nPayment * (1 + nInterest)
				* (FormCalc.intRate(nInterest, nPeriods - 1) - 1) / nInterest + nPayment;
	}

	return FormCalc.checkResult(nVal);
};

/**
 * Returns the amount of interest paid on a loan over a period of time.
 *
 */
FormCalc.ipmt = function(nPrincipal, nInterest, nPayment, nStart, nMonths) {
	FormCalc.checkMinArgs(arguments.length, 5);
	FormCalc.checkMaxArgs(arguments.length, 5);
    if(nPrincipal <=0 || nInterest <=0 ||nPayment <=0  ||nStart<1 ||nMonths<1){
    	throw "<missing or illegal parameter(s).>";
    }
	
	nInterest /= 12;
	nStart = parseFloat(nStart);
	nMonths = parseFloat(nMonths);
	if (nPayment <= nPrincipal * nInterest) {
		return 0;
	} else if (nMonths + nStart - 1 > FormCalc.loanTerm(nPrincipal, nInterest, nPayment)) {
		return 0;
	} else {
		var nPrincipalRemaining = nPrincipal;
		var nPrincipalPaidInPeriod = 0;
		var nInterestPaidInPeriod = 0;
		for ( var i = 1; i < nStart; i++) {
			nInterestPaidInPeriod = nPrincipalRemaining * nInterest;
			nPrincipalPaidInPeriod = nPayment - nInterestPaidInPeriod;
			nPrincipalRemaining -= nPrincipalPaidInPeriod;
			if (nPrincipalRemaining <= 0)
				break;
		}
		var nInterestPaid = 0.;
		for ( var i = nStart; i < nStart + nMonths; i++) {
			nInterestPaidInPeriod = nPrincipalRemaining * nInterest;
			nPrincipalPaidInPeriod = nPayment - nInterestPaidInPeriod;
			nPrincipalRemaining -= nPrincipalPaidInPeriod;
			nInterestPaid += nInterestPaidInPeriod;
			if (nPrincipalRemaining <= 0)
				break;
		}
		return FormCalc.checkResult(nInterestPaid);
	}
};

/**
 * Returns the net present value of an investment based on a discount rate, and a series of
 * periodic future cash flows.
 *
 */
FormCalc.npv = function(){
	FormCalc.checkMinArgs(arguments.length, 1);

	var nDiscountRate = FormCalc.parseFloat(arguments[0]);
    if(nDiscountRate<=0){
    	throw "<missing or illegal parameter(s).>";
    }	
	
	var nVal = 0;
	var nDenom = 1;
	for ( var i = 1; i < arguments.length; i++) {
		if(null == arguments[i]){
			return null;
		}
		nDenom *= (1 + nDiscountRate);
		nVal += FormCalc.parseFloat(arguments[i]) / nDenom;
	}
	return FormCalc.checkResult(nVal);

};

/**
 * Returns the payment for a loan based on constant payments and a constant interest rate.
 */
FormCalc.pmt = function(nPrincipal, nInterest, nPeriods) {
	FormCalc.checkMinArgs(arguments.length, 3);
	FormCalc.checkMaxArgs(arguments.length, 3);
	if(nPrincipal <=0 || nInterest<=0 || nPeriods <=0){
    	throw "<missing or illegal parameter(s).>";
    }
	var nPayment = FormCalc.loanPmt(parseFloat(nPrincipal), parseFloat(nInterest),
			parseInt(nPeriods));
	return FormCalc.checkResult(nPayment);

};

/**
 * Returns the amount of principal paid on a loan over a period of time.
 * 
 */
FormCalc.ppmt = function(nPrincipal, nInterest, nPayment, nStart, nMonths) {
	FormCalc.checkMinArgs(arguments.length, 5);
	FormCalc.checkMaxArgs(arguments.length, 5);
    if(nPrincipal <=0 || nInterest <=0 ||nPayment <=0  ||nStart<1 ||nMonths<1){
    	throw "<missing or illegal parameter(s).>";
    }
	
	nPrincipal = parseFloat(nPrincipal);
	nInterest = parseFloat(nInterest);
	nPayment = parseFloat(nPayment);
	nStart = parseInt(nStart);
	nMonths = parseInt(nMonths);

	nInterest /= 12;
	if (nPayment <= nPrincipal * nInterest) {
		return 0;
	} else if (nMonths + nStart - 1 > FormCalc.loanTerm(nPrincipal, nInterest, nPayment)) {
		return 0;
	} else {
		var nPrincipalRemaining = nPrincipal;
		var nPrincipalPaidInPeriod = 0;
		var nInterestPaidInPeriod = 0;
		for ( var i = 1; i < nStart; i++) {
			nInterestPaidInPeriod = nPrincipalRemaining * nInterest;
			nPrincipalPaidInPeriod = nPayment - nInterestPaidInPeriod;
			nPrincipalRemaining -= nPrincipalPaidInPeriod;
			if (nPrincipalRemaining <= 0)
				break;
		}
		var nPrinciplePaid = 0;
		for ( var i = nStart; i < nStart + nMonths; i++) {
			nInterestPaidInPeriod = nPrincipalRemaining * nInterest;
			nPrincipalPaidInPeriod = nPayment - nInterestPaidInPeriod;
			nPrincipalRemaining -= nPrincipalPaidInPeriod;
			nPrinciplePaid += nPrincipalPaidInPeriod;
			if (nPrincipalRemaining <= 0)
				break;
		}
		return FormCalc.checkResult(nPrinciplePaid);
	}
};

/**
 * Returns the present value of an investment of periodic constant payments at a constant 
 * interest rate.
 *
 */
FormCalc.pv = function(nPayment, nInterest, nPeriods) {
	FormCalc.checkMinArgs(arguments.length, 3);
	FormCalc.checkMaxArgs(arguments.length, 3);
	if (nPayment <= 0 || nPeriods <= 0 ) {
		throw "<missing or illegal parameter(s).>";
	}
	if(nPayment==null || nInterest==null){
		return null;
	}
	var nPayment = parseFloat(nPayment);
	var nInterest = parseFloat(nInterest);
	var nPeriods = parseInt(nPeriods);

	var nVal;
	if (nInterest == 0) {
		nVal = nPayment * nPeriods;
	} else {
		nVal = nPayment * (1 - 1 / FormCalc.intRate(nInterest, nPeriods)) / nInterest;
	}
	return FormCalc.checkResult(nVal);
};

/**
 * Returns the compound interest rate per period required for an investment to grow from
 * present to future value in a given period.
 * 
 */
FormCalc.rate = function(nFuture, nPresent, nPeriods) {
	if (nFuture <= 0. || nPresent <= 0. || nPeriods <= 0) {
		throw "<missing or illegal parameter(s).>";
	}

	var nFuture = parseFloat(nFuture);
	var nPresent = parseFloat(nPresent);
	var nPeriods = parseInt(nPeriods);

	var nRate = Math.exp(Math.log(nFuture / nPresent) / nPeriods) - 1;
	return FormCalc.checkResult(nRate);
};

/*
 * Term This function returns the number of periods needed for an investment
 * earning a fixed, but compounded interest rate to grow to a future value.
 */
FormCalc.term = function(nPayment, nInterest, nFuture) {
	var nPayment = FormCalc.parseFloatOrThrowError(nPayment);
	var nInterest = FormCalc.parseFloatOrThrowError(nInterest);
	var nFuture = FormCalc.parseFloatOrThrowError(nFuture);

	if (nPayment <= 0. || nInterest <= 0. || nFuture <= 0.) {
		throw "<missing or illegal parameter(s).>";
	}
	
	var nPeriods;
	if (nFuture <= nPayment) {
		nPeriods = 1;
	} else {
		nPeriods = Math.log((nFuture - nPayment) / nPayment * nInterest
				+ (1 + nInterest))
				/ Math.log(1 + nInterest);
	}
	return FormCalc.checkResult(nPeriods);
};

FormCalc.loanTerm = function(nPrincipal, nInterest, nPayment) {
	var nRemaining = nPrincipal;
	var nMonths = 0;
	while (nRemaining > 0.0) {
		nRemaining = nRemaining - nPayment + nRemaining * nInterest;
		nMonths++;
	}
	return FormCalc.checkResult(nMonths);
};
/**
 * This function returns a Universally Unique Identifier (UUID).
 */
FormCalc.uuid = function(n1) {
    var S4 = function() {
        return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
    };
    if(n1==1){
        return (S4()+S4()+"-"+S4()+"-"+S4()+"-"+S4()+"-"+S4()+S4()+S4());
    }else{
    	return (S4()+S4()+S4()+S4()+S4()+S4()+S4()+S4());
    }
};
// Private functions

FormCalc.loanPmt = function(nPrincipal, nInterest, nPeriods) {
	return (nPrincipal * nInterest / ((1 - 1 / FormCalc.intRate(nInterest, nPeriods))));
};

FormCalc.intRate = function(nInterest, nPeriods) {
	return Math.pow((1 + nInterest), nPeriods)
};

FormCalc.parseFloatOrThrowError = function(obj) {
	var num = Number(obj);
	if(isNaN(num)){
		throw "<missing or illegal parameter(s).>";
	}else{
		return num;
	}
};

FormCalc.parseFloat = function(obj) {
	var num = Number(obj);
	if(isNaN(num)){
		return 0;
	}else{
		return num;
	}
};

FormCalc.checkResult = function(result) {
	if (result == Number.POSITIVE_INFINITY || result == Number.NEGATIVE_INFINITY){
	   throw "<arithmetic over/underflow.>";
	}else{
		return result;
	}
};

FormCalc.isNumeric = function(input){
	return input!=null && !isNaN(Number(input));
};

FormCalc.checkMinArgs = function(actual, expected) {
	if(actual < expected){
		throw "<missing or illegal parameter(s).>";
	}
};

FormCalc.checkMaxArgs = function(actual, expected) {
	if(actual > expected){
		throw "<missing or illegal parameter(s).>";
	}
};

FormCalc.limitAllNullArgs = function(arrayArgus) {
	var result = new Array();
	for(var i=0;i<arrayArgus.length;i++){
		if(arrayArgus[i]!=null){
			result.push(arrayArgus[i]);
		}
	}
	return result;
};

FormCalc.runWithoutNullArgs = function(func, arrayArgus) {
	var argus = FormCalc.limitAllNullArgs(arrayArgus);
	return argus.length ? func.apply(null,argus) : null;	
};

FormCalc.runWithNumericArgs = function(func, arrayArgus) {
	var argus = new Array();
	for(var i=0;i<arrayArgus.length;i++){
		if(arrayArgus[i]!=null){
        	var el = parseFloat(arrayArgus[i]);
        	if(!isNaN(el)){
        		argus.push(el);
        	}
		}
	}

	return argus.length ? func.apply(null,argus) : null;	
};

/**
 * This function returns the English text equivalent of a given number.
 * 
 */
FormCalc.WordNum=function(){
	var Ones= new Array("Zero","One","Two","Three","Four","Five",
			"Six","Seven","Eight","Nine");
	var Teens =new Array ("Ten","Eleven","Twelve","Thirteen","Fourteen",
			"Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen");
	var Tens= new Array (
			"Zero",  "Ten",   "Twenty",  "Thirty", "Forty",
			"Fifty", "Sixty", "Seventy", "Eighty", "Ninety", "Hundred" );
	var Thousands = new Array (
			"Thousand", "Million",     "Billion",
			"Trillion", "Quadrillion", "Quintillion" );
	var Cents = new Array("Cent"); 
	var Comma=new Array("");
	var Ands  =new Array ("", "And " /* used by FF99 */ );
	var Dollars=new Array ( "Dollar" );
	var Space = " ";
	var Hyphen = "-";
	var QUINTILLION = 1000000000000000000;
	var n=arguments[0];
	var f=arguments[1];
	if(n === null) {
        return null;
    }
    if(isNaN(n)||!isFinite(n)||n<0){
		return "**************"; 
	}
	
	if (f < 0 || 2 < f) {
		f = 0;
	}
	
	var dollars =   n;
	var cents =    Math.floor(((n -  Math.floor(dollars)+ 0.005) * 100));  
	if (cents >= 100) {
		dollars += 1;
		cents -= 100;
	}
	
	var s= new Array();
	var thousands = 6;
	for (var div = QUINTILLION; div >= 1 ; div/=1000) { 
		var number = Math.floor(dollars / div) ; 
		var hundreds = Math.floor(number/ 100) ;
		var tens = Math.floor((number- hundreds * 100) / 10);
		var ones = Math.floor(number- hundreds * 100 - tens * 10);  
                if(number>=1){
                    dollars -= (div * number ); 
                 }
                
                
		if (hundreds >=1) {
			s.push(Ones[hundreds]);
			s.push(Space);
			s.push(Tens[10]);
			s.push(Space);
			if (tens > 0 || ones > 0)
				s.push(Ands[0]);
		}
		if (tens >=1 ) {
			s.push((tens == 1) ? Teens[ones] : Tens[tens]);
			s.push((ones > 0 && tens != 1) ? Hyphen : Space);
		}
		if (ones >=1 && tens != 1) { 
			if (tens > 0 && ones > 0) {
				// safe since Ones contains true literal constants
				var o = Ones[ones];
				//s+=FormCalc.MylowerCase(o);  
				s.push(o.toLowerCase()); 
			}
			else {
				s.push(Ones[ones]);
			}
			s.push(Space);
		}
		thousands--;
		if (thousands >= 0 && number >= 1) {
			s.push(Thousands[thousands]);
			s.push(Comma[0]);
			s.push(Space);
		}
 
  
	}
	//
	// If less than one then use zero.
	//
	if (n < 1.) {
		s.push(Ones[0]);
		s.push(Space);
	}
	//
	// Factor in format:
	//     0 => "One Hundred Twenty-three"
	//     1 => "One Hundred Twenty-three Dollars"
	//     2 => "One Hundred Twenty-three Dollars And Forty Cents"
	//
	if (f == 1 || f == 2) {
		//
		// Append dollar CalcSymbol.
		//
		s.push(Dollars[0]);
		if ( Math.floor(n) != 1)
			s.push('s');
		//
		// Append cents.
		//
		if (f == 2) {
			s.push(Space);
			s.push(Ands[1]);
			var tens =  Math.floor(cents / 10);
			var ones =  Math.floor(cents - tens * 10);
			if (tens > 0) {
				s.push((tens == 1) ? Teens[ones] : Tens[tens]);
			}
			if (tens != 1) {
				if (tens > 0 && ones > 0) {
					// safe since Ones contains true literal constants
					var o = Ones[ones];
					s.push(Hyphen);
					s.push(o.toLowerCase());
				}
				else if (tens == 0) {
					s.push(Ones[ones]);
				}
			}
			s.push(Space);
			s.push(Cents[0]);
			if (cents != 1.)
				s.push('s');
		}
	}
	if(s[s.length-1] == ' '){
		s.pop();		
	}
	return s.join("");
};

FormCalc._Accessor = function(a) {
    if(a && typeof(a) === "object") {
        if(a.className === "field" || a.className === "exclGroup")
            return a.rawValue;
    }
    return a;
};

FormCalc._ArrayAccessor = function(a) {
    if(typeof(a) == "string") {
        var indexArray = a.lastIndexOf("]")+ 1,
            node = a.substr(0, indexArray),
            propIndex = a.indexOf(".",indexArray),
            prop = propIndex == -1 ? "" : a.substr(propIndex + 1, a.length),
            ctxNode = xfalib.runtime.xfa._contextNode(),
            list = ctxNode.resolveNodes(node),
            retArray = []
        for(var i = 0;i<list.length;i++) {
            var item = list.item(i),
                val = prop.length ? this._Accessor(item[prop]) :this._Accessor(item);
            retArray.push(val);
        }
        if(retArray.length == 1)
            return retArray[0]
        else
            return retArray;
    }
    return a;
};

FormCalc.epoch = new Date(1900,0,1)
FormCalc.epochTime = FormCalc.epoch.getTime()
FormCalc.numMillisInDay = 24*60*60*1000
FormCalc.DateFormats= ["med","short","med","long","full"]

FormCalc.num2date = function(n,fmt,locale) {
    function pad2(num) {
        return (+num)>9 ? num+"" : "0"+num;
    }
    locale = locale || "en_US"
    fmt = fmt || FormCalc.DateFmt(0,locale);
    var epoch = new Date(1900,0,1)
    epoch.setDate(n);
    var inputDate = epoch.getFullYear()+"-"+pad2((epoch.getMonth()+1))+"-"+pad2(epoch.getDate());
    return xfalib.ut.PictureFmt.formatDate(inputDate,fmt,locale);
}

FormCalc.date = function() {
    return Math.ceil((new Date().getTime() - this.epochTime)/this.numMillisInDay)
}

FormCalc.DateFmt = function(symbol,locale) {
    symbol = symbol || 0
    locale = locale || "en_US"
    return xfalib.script.Xfa.Instance._getLocaleSymbols(locale,"datePatterns."+FormCalc.DateFormats[symbol])
};
/*
 * ***********************************************************************
 * ADOBE CONFIDENTIAL
 * __________________
 *
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 * ***********************************************************************
 */

(function ($) {
    $.uaMatch = function( ua ) {
        ua = ua.toLowerCase();
        var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
            /(webkit)[ \/]([\w.]+)/.exec( ua ) ||
            /(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
            /(msie) ([\w.]+)/.exec( ua ) ||
            ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) || [];
        return {
            browser: match[ 1 ] || "",
            version: match[ 2 ] || "0"
        };
    };
    // Not clobbering any existing $.browser
    if ( !$.browser ) {
        var
            matched = $.uaMatch( navigator.userAgent ),
            browser = {};
        if ( matched.browser ) {
            browser[ matched.browser ] = true;
            browser.version = matched.version;
        }
        // Chrome is Webkit, but Webkit is also Safari.
        if ( browser.chrome ) {
            browser.webkit = true;
        } else if ( browser.webkit ) {
            browser.safari = true;
        }
        $.browser = browser;
    }
})($);
/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by all applicable intellectual property
 * laws, including trade secret and copyright laws.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/


/**
 * @package xfalib.ut.Class
 */
(function(_, xfalib){

    xfalib.ns = xfalib.ns || function (namespaceString) {
        var parts = namespaceString.split('.'),
            parent = window,
            currentPart = '';

        for(var i = 0, length = parts.length; i < length; i++) {
            currentPart = parts[i];
            parent[currentPart] = parent[currentPart] || {};
            parent = parent[currentPart];
        }

        return parent;
    };

    var Class = xfalib.ut.Class = function(options) {
        this.options = _.extend({}, this.options, options);
        if(!this.options.jsonModel)
            this.options.jsonModel = {};
        //For perf reason, we are setting jsonModel as direct property instead of using property descriptor
        this.jsonModel = this.options.jsonModel;
        this.initialize.apply(this, arguments);
    };

    _.extend(Class.prototype, {
        initialize : function(){
        },

        xfaUtil :function(){
          return xfalib.ut.XfaUtil.prototype;
        },

        copyArray : function(src,dst,options) {
            var keepReference = this.getOrElse(options, "keepReference", true);
            if(src instanceof Array)
            {
                for (var i = 0;i<src.length;i++)
                {
                    var obj;
                    if(src[i] instanceof Array)
                    {
                        obj = this._createDestination(dst, i, keepReference, []);
                        this.copyArray(src[i],obj,options);
                    }
                    else if(typeof src[i] == "object")
                    {
                        obj = this._createDestination(dst, i, keepReference, {});
                        this.copyObject(src[i],obj,options);
                    } else {
                        obj = src[i];
                    }
                    dst[i] = obj;
                }
                if(dst.length > src.length){
                    dst.splice(src.length, (dst.length - src.length));  //Remove ths rest of the extra destination items
                }
            }
        },

        /**
         *
         * @param src
         * @param dst
         * @param options e.g. {keepReference: true, exceptions:["htmlId"], transformMaps: {"dataId", function(src, options){ return src "33"+src; }}}
         */
        copyObject : function(src,dst,options) {
            var keepReference = this.getOrElse(options, "keepReference", true);
            var exceptions = this.getOrElse(options, "exceptions", []);
            var transformMaps = this.getOrElse(options, "transformMaps", {});
            if(typeof src == "object") {
                for (var child in src) {
                    if(exceptions.indexOf(child) == -1) {
                        if(src[child] instanceof Array) {
                            dst[child] = this._createDestination(dst, child, keepReference, []);
                            this.copyArray(src[child],dst[child],options);
                        }
                        else if(typeof src[child] == "object" && src[child] != null) {
                            dst[child] = this._createDestination(dst, child, keepReference, {});
                            this.copyObject(src[child],dst[child],options);
                        }
                        else{
                            if(!_.isUndefined(transformMaps[child])){
                                dst[child] = transformMaps[child](src[child], options, src);
                            }
                            else
                                dst[child] = src[child];
                        }
                    }
                }
            }
        },

        _createDestination : function(obj, property, keepReference, defaultValue) {
            if(!keepReference)
                return defaultValue;
            else if(_.isObject(obj) && !obj.hasOwnProperty(property))
                return defaultValue;
            else
                return obj[property] || defaultValue ;  //Would handle both, Array and objects
        },

        /**
         * will replace functions in the object with noop function based on a predicate function's result.
         * If no predicate is passed all functions will be disabled.
         * Warning once disabled object cant be re-enabled.
         *
         * sample predicate to disable all 'public' functions : function (funcName) { return funcName[0] != '_'}
         *
         * @param predicate
         * @private
         */
        _disableFunctions: function (predicate) {
            var noop = function () {},
                disableAll = !_.isFunction(predicate);

            _.each(_.functions(this), function (funcName) {
                if (disableAll || predicate(funcName)) {
                    this[funcName] = noop;
                }
            }, this);
        },

        /**
         * getOrElse can take multiple arguments.
         * arg1(obj): base Object
         * arg2: string representing property chain where properties are concatenated via dot
         * arg3: default value
         **/

        getOrElse : function(obj){
            var currObject = obj;
            if(arguments.length < 2)
                return currObject;
            else if(arguments.length == 2) {
                if(!_.isUndefined(currObject)){
                    return currObject;
                } else {
                    return _.clone(arguments[1]);
                }
            }
            else {
                var propChain = (arguments[1] || "").split(".");
                var defaultValue = arguments[2];
                _.each(propChain, function(prop){
                    if(_.isObject(currObject))
                        currObject = currObject[prop];
                    else
                        currObject = undefined;
                }, this);

                if(!_.isUndefined(currObject))
                    return currObject;
                else {
                    return _.clone(defaultValue) ; //May have to do deep clone in future. TODO: support for conditional clone
                }
            }
        },

        jqId: function (id) {
            return xfalib.ut.XfaUtil.prototype.jqId(id);
        },

        logger : function(){
            return this.xfaUtil().getLogger();
        },

        validateInput : function(param, dataType,fallback){
        	if(typeof param !== "undefined" && param !== null) {
        		switch(dataType) {
        		case "string":
        			param = param+"";
        			break;
        		case "object":
        			if(typeof param !== "object")
        				param = fallback;
        			break;
        	    case "integer":
                    param = parseInt(param);
                    if(isNaN(param))
                        param = fallback;
                    break;
               case "measurement":
                     break;
        		default:
        			if(dataType instanceof Array) {
                        if(!~dataType.indexOf(param))
                            param = fallback
                    }
        		}
        	}
        	return param;
        }

    });

    _.extend(Class, {
        defineProps : function(propsMap){
            _.each(propsMap, function(propDesc, propName){
                //Check property can be resolved using resolveNode
                if(propDesc.resolve) {
                    //Check whether prototype owns the object resolveProperties
                    if(!this.prototype.hasOwnProperty("resolveProperties")) {
                        //check whether prototype inherits the object resolveProperties
                        if(this.prototype.resolveProperties) {
                            //clone the object since we do not want to modify parent's prototype
                            this.prototype.resolveProperties = _.clone(this.prototype.resolveProperties);
                        }
                        else
                            this.prototype.resolveProperties = [];
                    }
                    this.prototype.resolveProperties.push(propName)
                }
                Object.defineProperty(this.prototype, propName, propDesc);

            }, this);
        },
        extend : function(props){
            var child = inherits(this, props);
            child.extend = this.extend;
            return child;
        },
        addMixins : function(mixinBakers){
            if(!_.isArray(mixinBakers)){
                mixinBakers = [mixinBakers];
            }
            _.each(mixinBakers, function(mixinBaker){
                if(mixinBaker.normalProperties){
                    _.extend(this.prototype, mixinBaker.normalProperties);
                }
                if(mixinBaker.propertyDescriptors){
                    this.defineProps(mixinBaker.propertyDescriptors);
                }
            }, this);
        }
    });

    // Shared empty constructor function to aid in prototype-chain creation.
    var ctor = function(){};

    // Helper function to correctly set up the prototype chain, for subclasses.
    // Similar to `goog.inherits`, but uses a hash of prototype properties and
    // class properties to be extended.
    function inherits(parent, protoProps, staticProps) {
        var child;
        var _super = parent.prototype;
        // The constructor function for the new subclass is either defined by you
        // (the "constructor" property in your `extend` definition), or defaulted
        // by us to simply call the parent's constructor.
        if (protoProps && protoProps.hasOwnProperty('constructor')) {
            child = protoProps.constructor;
        } else {
            child = function(){ parent.apply(this, arguments); };
        }

        // Inherit class (static) properties from parent.
        _.extend(child, parent);

        // Set the prototype chain to inherit from `parent`, without calling
        // `parent`'s constructor function.
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child._super = parent.prototype;
        child._superClass = parent;

        // Add prototype properties (instance properties) to the subclass,
        // if supplied.
        if (protoProps) { //_.extend(child.prototype, protoProps);
            // Copy the properties over onto the new prototype
            for (var name in protoProps) {
                if(name == "_defaults"){
                    protoProps[name] = _.extend({}, _super[name], protoProps[name]);
                }
                child.prototype[name] = protoProps[name];
            }
        }


        // Add static properties to the constructor function, if supplied.
        if (staticProps) _.extend(child, staticProps);

        // Correctly set child's `prototype.constructor`.
        child.prototype.constructor = child;

        // Set a convenience property in case the parent's prototype is needed later.
        child.__super__ = parent.prototype;

        return child;
    };
})(_, window.xfalib);
/**
 * Created by vdua on 2/18/2015.
 */
(function (_, xfalib) {
    var XMLUtils = {
        dataSom2xpath: function (dataSom) {
            var xpath = "";

            if (!_.isEmpty(dataSom)) {
                // any dot preceded by ], takes care of dot-s in name,
                // and remove constant prefix "xfa[0].datasets[0].data[0]" and form root name, then join using '/'
                _.each(dataSom.split(/\]\./).slice(4),
                    function (part) {
                        var openBracketPos = part.lastIndexOf('[');
                        xpath += part.substring(0, openBracketPos + 1) +
                            (parseInt(part.substring(openBracketPos + 1)) + 1) + // increment index by 1 for xpath query
                            "]/";
                    });

                if (_.isEmpty(xpath)) {
                    xpath = dataSom;
                } else if (xpath[xpath.length - 1] === '/') {
                    xpath = xpath.slice(0, -1);
                }
            }

            return xpath;
        },

        /**
         * Converts an xPathResult of type iterator to an array
         * @param xPathResult
         * @returns {Array}
         */
        iteratorToArray: function (xPathResult) {
            var result = [];
            // in some browsers, if xpath is invalid xPath result is null whereas some browsers return XpathResult with empty iterator
            var node = xPathResult ? xPathResult.iterateNext() : null;
            while (node != null) {
                result.push(node);
                node = xPathResult.iterateNext();
            }
            return result;
        },
        /**
         * Wrapper API for document.evaluate to provide cross-browser support.
         * @param xpath
         * @param node
         * @param nsResolver
         * @param resultType
         * @param result
         * @returns {Object|*}
         */
        evaluateXPath: function (xpath, node, nsResolver, resultType, result) {
            try {
                if(_.isEmpty(xpath) || !_.isString(xpath) || !(node instanceof Node)) {
                    return null;
                }

                if (_.isUndefined(document.evaluate)) {
                    wgxpath.install();
                }
                var documentToSearch = node instanceof Document ? node : node.ownerDocument,
                    documentToEval = documentToSearch.evaluate ? documentToSearch : document;
                xpath = this.sanitizeXPath(xpath);

                return documentToEval.evaluate(xpath, node, nsResolver, resultType, result);

            } catch (exception) {
                xfalib.ut.XfaUtil.prototype.getLogger().error("Could not evaluate xpath: " + xpath  + exception);

            }

        },
         /**
         *Removes all [*] other than ['numeric'] from xpath
         *@param xpath
         *@returns xpath after removing "[*]"
         */
         sanitizeXPath: function(xpath) {
             var xpathArray=xpath.split("/"),
                 resultXpath = _.map(xpathArray, function (path) {
                 return path.replace(/\[(.*\D+.*)\]|\[\]/g,"");
             }).join("/");
             return resultXpath;
         },

        /**
         * Creates all the Elements (if they don't exist) in the xpath leading to the node being searched for in the
         * xpath relative to the element. Optionally creates the node as well if bParentsOnly is false
         * @param xpath
         * @param element
         * @param bParentsOnly whether to create only the parents or the node as well
         * @returns node that is being represented by the xpath relative to the element.
         */
        createElementsFromXPath: function (xpath, element, bParentsOnly) {
            if (xpath != null || element != null) {
                var parts = xpath.split("/"),
                    actualParts = bParentsOnly ? _.initial(parts) : parts,
                    el = element;
                _.each(actualParts, function (part, index) {
                    var som = part.match(/^([^[]+)(\[(\d+)\])?/),
                        childEl;
                    if (som == null) {
                        xfalib.ut.XfaUtil.prototype.getLogger().error("Unsupported expression in Bindref " + part);
                        return null;
                    }
                    //only the last element can be attribute
                    childEl = this.findOrCreateElement(part, el, index === actualParts.length - 1);
                    el = childEl;
                }, this);
                return el;
            }
            return null;
        },

        /**
         * Form an xpath part returns the index as well as the tagName. Index can be * as well
         * @param xpathName
         * @returns {*}
         * @private
         */
        _getElementNameAndIndexFromXPathPart: function (xpathName) {
            var som  =  xpathName.match(/^([^[]+)(?:\[(\d+|\*)\])?/);
            if (som !== null) {
                return {
                    name: som[1],
                    index: som[2] || 0
                };
            }
            return null;
        },

        /**
         * create an element with the tagName elementName for the ownerDocument of element.
         * @param elementName
         * @param element
         * @returns {HTMLElement}
         */
        createElement: function (elementName, element) {
            var el = element.ownerDocument.createElement(elementName);
            return el;
        },

        /**
         * Searches for the nodeXpath relative to element. If it doesn't exists creates it and returns the node
         * @param element
         * @param nodeXpath
         * @param bAttribute if true then check for attribute otherwise not.
         * @returns {Node|*}
         */
        findOrCreateElement: function (nodeXpath, element, bAttribute) {
            try {
                if (element == null) {
                    return null;
                }
                var result = this.evaluateXPath(nodeXpath, element, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null),
                    el = result.iterateNext(),
                    res;
                if (el == null) {
                    res = this._getElementNameAndIndexFromXPathPart(nodeXpath);
                    if (res != null) {
                        if (bAttribute && res.name.match(/^@/)) {
                            var attrName = res.name.replace(/^@/, "");
                            el = element.ownerDocument.createAttribute(attrName);
                            element.setAttributeNode(el);
                        } else {
                            el = element.ownerDocument.createElement(res.name);
                            element.appendChild(el);
                        }
                    }
                }
                return el;

            } catch (exception) {
                xfalib.ut.XfaUtil.prototype.getLogger().error("Following exception "
                    +  "occurred while executing findOrCreateElement " + exception);
            }

        },

        /**
         * Returns the Root Form Elment from the xmlDocumentElement
         * @param xmlDocumentElement It can be a document or Element. If the root element is xdp element, it returns
         *        the grand grand child of that element. otherwise the root element is returned. The root
         *        Element can be either the element itself or documentElement of the element.
         */
        getXFARootFormElementFromXML: function (xmlDocumentElement) {
            if(_.isUndefined(document.evaluate)) {
                wgxpath.install();
            }
            var isElement = xmlDocumentElement instanceof Element,
                docElemName = isElement ? xmlDocumentElement.nodeName : xmlDocumentElement.documentElement.nodeName,
                rootElement = isElement ? xmlDocumentElement : xmlDocumentElement.documentElement,
                nodeList;

            if ("xdp:xdp" === docElemName || "xdp" === docElemName) {
                if (xfalib.ut.XfaUtil.prototype.isIE()) {
                    //IE doesn't support evaluating namespace elements
                    var datasets = rootElement.firstElementChild,
                        data = datasets.firstElementChild;
                    rootElement = data.firstElementChild;
                } else {
                    // assumption is that the xml will be of format <xdp><datasets><data><form1>
                    // TODO: change first * to xfa:datasets
                    nodeList = this.evaluateXPath("*/xfa:data/*", rootElement, formBridge.nsResolver,
                                            XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
                    rootElement = nodeList.iterateNext();
                }
            }
            return rootElement;
        },

        /**
         * Returns an object containing the prefix and namespaces present in the rootElement. For default namespace the
         * prefix is "_default"
         * @param rootElement {Element} xml element which has to be looked for namespaces
         * @returns {object} object whose keys are the prefix and values are the namespace
         */
        getNamespaces: function (rootElement) {
            var namespaces = {
                "_default" : null
            };
            _.each(rootElement.attributes, function (attr) {
                var name = attr.name,
                    parsedAttrName = name.match(/^xmlns(?:\:(.*))?/),
                    isNamespace = parsedAttrName != null,
                    namespaceName = isNamespace ? parsedAttrName[1] || "_default" : null;
                if (namespaceName) {
                    namespaces[namespaceName] = attr.value;
                }
            });
            return namespaces;
        },

        /**
         * Returns a namespace resolver given a element. The nsResolver returns the namespace given a prefix by
         * using the namespaces mentioned in the element.
         * @param rootElement element from which to create the nsResolver
         * @returns {function} the function returns the namespace given a prefix.
         */
        getNsResolver: function (rootElement) {
            var namespaces = this.getNamespaces(rootElement),
                nsResolver = (function (namespaces) {
                    return function (nsPrefix) {
                        var namespace = formBridge.nsResolver(nsPrefix) || namespaces[nsPrefix];
                        return namespace;
                    };
                }(namespaces));
            return nsResolver;
        },

        /**
         * Removes default namespaces from xml, basically the namespace defined as xmlns="some namespace". The
         * side-effect of the API is it removes the string "xmlns='some namespace'" from any attribute value as well.
         * @param xml {string}
         * @returns {string}
         */
        removeDefaultNamespace: function (xml) {
            var stringRegex = "(\\s+)" + // any number of spaces
                             "(xmlns=" + // then xmlns=
                            "('[^']*'|\"[^\"]*\"))" + // then value in single quotes ('[^']') or
                                                    //                 double quotes ("[^"]")
                            "(?=[^<>]*>)",  // followed by closing tag (implies attribute) and before another
                                           // opening tag(implies text)
                regex = new RegExp(stringRegex, "g");
            return xml.replace(regex, "$1");
        }
    };
    xfalib.ut.XMLUtils = XMLUtils;
}(_, xfalib));
/**
 * @package xfalib.ut.Logger
 * @import xfalib.ut.Class
 */

(function(_, xfalib, $){
    var categoryAcronyms = {
                            "a": "xfa",
                            "b": "xfaView",
                            "c": "xfaPerf"
        },
        loggerTypes = ["off", "console", "server", "consoleServer"];
    var Logger = xfalib.ut.Logger = xfalib.ut.Class.extend({

//      Count of log messages so far.
        LOG_COUNT : {
            level : {
                "FATAL" : 0,
                "ERROR" : 0,
                "WARN" : 0,
                "INFO" : 0,
                "DEBUG" : 0,
                "TRACE" : 0,
                "ALL" : 0
            },
            category : {
                "xfa" : 0,
                "xfaView" : 0,
                "xfaPerf" : 0,
                "Unknown" : 0
           }
        },

        /**
         * Log level to turn logging off (default).
         * @static
         * @final
         * @type Number
         */
        OFF : 0,

        /**
         * Log level for fatal error messages.
         * @static
         * @final
         * @type Number
         */
        FATAL : 1,

        /**
         * Log level for error messages.
         * @static
         * @type Number
         * @final
         */
        ERROR : 2,

        /**
         * Log level for warning messages.
         * @static
         * @type Number
         * @final
         */
        WARN : 3,

        /**
         * Log level for info messages.
         * @static
         * @type Number
         * @final
         */
        INFO : 4,

        /**
         * Log level for debug messages.
         * @static
         * @type Number
         * @final
         */
        DEBUG : 5,

        /**
         * Log level for trace messages.
         * @static
         * @type Number
         * @final
         */
        TRACE : 6,

        /**
         * Log level for all messages.
         * @static
         * @type Number
         * @final
         */
        ALL : 7,


        logLevelNames : ["OFF", "FATAL", "ERROR", "WARN", "INFO", "DEBUG", "TRACE", "ALL"],

        initialize : function(){
            var str = "",
                that =this;
            Logger._super.initialize.call(this);
            this.logs = {};
            this.logMessages = "";
            this.logServiceProxy = this.options.logServiceProxy;
            this.contextPath = this.options.contextPath;
            this.renderContext =  this.options.renderContext;
            if(this.jsonModel.logConfigString) {
                _.extend(this.jsonModel, this.parse(this.jsonModel.logConfigString));
            }
            _.each(this.jsonModel.category, function(category) {
                that.LOG_COUNT.category[category] = 0;
            })
        },

        /**
         * parses a log config string of the form <0,1,2,3>-<category string><level integer>-<category string><level integer>..
         * and returns an a config object that logger uses. The function is a private and not to be called outside
         * this function
         *
         * category can not contain numbers and only valid characters are a-zA-Z
         * level can be any integer.
         *
         * category string is converted into actual category for the logger by using default categoryAcronyms
         * [a : xfa, b: xfaView, c: xfaPerf} and the categoryAcronyms passed to the options while instantiating the
         * object. If not found in both the acronyms then the value category string is used as actual category
         *
         * For example for the input string 1-a9-b9-c9 return object is
         * {on: true, category: [xfa,xfaView, xfaPerf], level: [9, 9, 9], type: console}
         *
         * For the input string 1-a9-b9-c9-d9-e11 with options.categoryAcronyms {a:a, d:AF} return object is
         * {on: true, category: [xfa,xfaView, xfaPerf, AF, e], level: [9, 9, 9, 9, 11], type: console}
         */
        parse : function(configString) {
            var arr = configString.split("-"),
                logType = _.first(arr),
                logConfig = _.rest(arr),
                res = {
                    on: logType === "0" ? "false": "true",
                    category: [],
                    level:[],
                    type:loggerTypes[parseInt(logType)]
                };
           _.each(logConfig, function(item, index) {
                var config = item.match(/^([A-Za-z]+)(\d+)$/),
                    category;
                if (config && config.length === 3) {
                    category = this.getOrElse(categoryAcronyms, config[1],
                                    this.getOrElse(this.jsonModel, "categoryAcronyms." + config[1], config[1]));
                    res.category.push(category);
                    res.level.push(parseInt(config[2]));
                } else {
                    //calling this because logger is not initialized as of now
                    this.consoleHandler(this.resolveMessage(xfalib.locale.LogMessages["ALC-FRM-901-020"],
                                                    [item, configString]))
                }
            }, this);
            return res;
        },

        /*
         *
         */
        resolveMessage : function(message, snippets) {
            snippets = snippets || [];
            return message.replace(/{(\d+)}/g, function(match, number) {
                return typeof snippets[number] != 'undefined'
                    ? snippets[number]
                    : match
                    ;
            });
        },

        /**
         * Writes a message to the console.
         * @private
         * @param {Number} level The log level
         * @param {String} message The log message
         * @param {String/String[]} snippets (optional) The texts replacing
         *        <code>{n}</code>
         * @return The log message
         * @type String
         */
        log : function(category, level, message, snippets) {
            var d= new Date();
            var day = d.getDate();
            var month = d.getMonth() + 1;
            var year = d.getFullYear();
            var mili = d.getMilliseconds();
            var sec = d.getSeconds();
            var min = d.getMinutes();
            var hour = d.getHours();
            var date = day + "." + month + "." + year +" " + hour + ":" + min + ":" + sec + ":" + mili;
            if(this.jsonModel && this.jsonModel.category) {
                for(var i = 0; i<this.jsonModel.category.length; i++) {
                    if (level != 0 && this.jsonModel.level[i] >= level && this.jsonModel.category[i] == category && this.jsonModel.on == "true") {

                        var resolvedMessage = message;
                        if(snippets){
                            //resolve message with snippet
                            resolvedMessage = this.resolveMessage(message, snippets);
                        }

                        var text = "";
                        text += date ;
                        text += " *" + this.logLevelNames[level] + "*";
                        text += " [" +  category + "]" ;
                        text += "  " + resolvedMessage + "\r\n" ;
                        this.logMessages += text ;
                        if(this.jsonModel.type == "console" || this.jsonModel.type == "consoleServer" ) {
                            ++this.LOG_COUNT.category[category || 'Unknown'];
                            ++this.LOG_COUNT.level[this.logLevelNames[parseInt(level) < 8? level:7]];
                            this.consoleHandler(text, level);
                        }
                    }
                }
            }
        },

        consoleHandler : function(text, level){
            if(typeof console != "undefined") {
                var levelName = typeof this.logLevelNames[level] === "string"
                    ? this.logLevelNames[level].toLowerCase()
                    : "log",
                    logFunction = console.log;
                if (typeof console[levelName] === "function") {
                    logFunction = console[levelName]
                }
                logFunction.call(console, "\n\n\n" + text);
                //Error log already shows the call stack for debugging.
                if(levelName !== "error") {
                    try {
                        n.test
                    } catch (exception) {
                        if (exception.stack) {
                            logFunction.call(console, exception.stack.replace("ReferenceError: n is not defined", ""));
                        }
                    }
                }
            }

        },

        /*
         *  Helper function to ger submit service proxy url
         */
        _getLogServiceProxyUrl: function() {
            var logServiceProxyUrl = "";
            if(this.logServiceProxy)
                logServiceProxyUrl += this.logServiceProxy;
            else //finally hard code it
                logServiceProxyUrl += ((this.contextPath && this.contextPath != "/") ? this.contextPath : "") + "/content/xfaforms/profiles/default.log.html";
            return logServiceProxyUrl;
        },

        _invokeAtServer: function(options) {
            var localSubmitUrl =  this._getLogServiceProxyUrl();
            var params = {
                    async: true,
                    url: localSubmitUrl,
                    type: 'POST',
                    contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
                    data: options
                };
            $.ajax(params);
        },

        isServerLoggingEnabled : function(){
            if((this.jsonModel.on == "true") && (this.jsonModel.type == "server" || this.jsonModel.type == "consoleServer"))
                return true;
            else
                return false;
        },

        serverHandler :function() {
            var options = {'logMessages' : this.logMessages, 'renderContext' : this.renderContext};
            this._invokeAtServer(options);
            this.logMessages = "" ;
        },

        /**
         * Writes a message to the console if log level is set to
         * {@link #FATAL} or higher.
         * @static
         * @param {String} message The log message
         * @param {String/String[]} snippets (optional) The texts replacing
         *        <code>{n}</code>
         */
        fatal : function(category, message, snippets) {
            this.log(category, this.FATAL, message, snippets);
        },

        /**
         * Writes a message to the console if log level is set to
         * {@link #ERROR} or higher.
         * @static
         * @param {String} message The log message
         * @param {String/String[]} snippets (optional) The texts replacing
         *        <code>{n}</code>
         */
        error : function(category, message, snippets) {
            this.log(category, this.ERROR, message, snippets);
        },

        /**
         * Writes a message to the console if log level is set to
         * {@link #WARN} or higher.
         * @static
         * @param {String} message The log message
         * @param {String/String[]} snippets (optional) The texts replacing
         *        <code>{n}</code>
         */
        warn : function(category, message, snippets) {
            this.log(category, this.WARN, message, snippets);
        },

        /**
         * Writes a message to the console if log level is set to
         * {@link #INFO} or higher.
         * @static
         * @param {String} message The log message
         * @param {String/String[]} snippets (optional) The texts replacing
         *        <code>{n}</code>
         */
        info : function(category, message, snippets) {
            this.log(category, this.INFO, message, snippets);
        },

        /**
         * Writes a message to the console if log level is set to
         * {@link #DEBUG} or higher.
         * @static
         * @param {String} message The log message
         * @param {String/String[]} snippets (optional) The texts replacing
         *        <code>{n}</code>
         */
        debug : function(category, message, snippets) {
            this.log(category, this.DEBUG, message, snippets);
        },

        /**
         * Writes a message to the console if log level is set to
         * {@link #TRACE} or higher.
         * @static
         * @param {String} message The log message
         * @param {String/String[]} snippets (optional) The texts replacing
         *        <code>{n}</code>
         */
        trace :  function(category, message, snippets) {
            this.log(category, this.TRACE, message, snippets);
        },

        isLogEnabled : function(category, level) {
            if(this.jsonModel.on == "true") {
                var pos = this.jsonModel.category.indexOf(category) ;
                if(this.jsonModel.level[pos] >= level)
                    return true;
            }
            return false;
        }

    });
})(_, xfalib, $);
/**
 * @package xfalib.ut.EventClass
 * @import xfalib.ut.Class
 */
(function(_, xfalib){
    // Regular expression used to split event strings
    // Regular expression used to split event strings
    var eventSplitter = /\s+/;

    // A module that can be mixed in to *any object* in order to provide it with
    // custom events. You may bind with `on` or remove with `off` callback functions
    // to an event; trigger`-ing an event fires all callbacks in succession.
    //
    var EventClass = xfalib.ut.EventClass =  xfalib.ut.Class.extend({

        // Bind one or more space separated events, `events`, to a `listener`
        // object. The object should implement `handleEvent` function which will be
        // called on event dispatch
        on: function(event, listener, context) {

            var calls, list,retVal = true;
            var fnCallback = _.isFunction(listener) ? listener : null;
            if (!listener || (!listener["handleEvent"] && !fnCallback)) return false;

            calls = this._callbacks || (this._callbacks = {});

            list = calls[event] || (calls[event] = []);
            if(fnCallback){
                context = context || this;
                var found = _.find(list, function(callback){
                    return (callback.fn == fnCallback && callback.context == context);
                }, this);
                if(found)
                    return false;
                else {
                    list.push({"fn" : fnCallback, "context": context});
                }
            }
            else{
                if(~list.indexOf(listener))
                    return false;
                else
                    list.push(listener);
            }

            return  true;
        },

        // Remove one or many callbacks. If `listener` is null, removes all listener for the
        // event. If `events` is null, removes all bound callbacks for all events.
        off: function(events, listener, context) {
            var event, calls, node;

            // No events, or removing *all* events.
            if (!(calls = this._callbacks)) return;
            if (!(events || listener)) {
                delete this._callbacks;
                return this;
            }

            var fnCallback = _.isFunction(listener) ? listener : null;
            // Loop through the listed events and contexts and remove the required ones.
            events = events ? events.split(eventSplitter) : _.keys(calls);
            while (event = events.shift()) {
                node = calls[event];
                calls[event] = _.filter(calls[event],function(elem) {
                    if(typeof(listener) !== "undefined"){
                        if(fnCallback && elem.fn == fnCallback && elem.context == context)
                            return false;
                        else if(!fnCallback && listener === elem)
                            return false;
                    }
                    else{
                        return false;
                    }
                    return true;
                });
                if(!calls[event].length)
                    delete calls[event];
            }

            return this;
        },

        // Trigger one or many events, firing all bound callbacks. Callbacks are
        // passed the same arguments as `trigger` except the first
        trigger: function(events) {
            var event, calls, rest;
            if (!(calls = this._callbacks)) return this;
            events = events.split(eventSplitter);
            var payLoad = _.rest(arguments);
            while (event = events.shift()) {
                _.each(calls[event],function(callback) {
                    if(callback.fn && callback.context){
                        callback.fn.apply(callback.context, payLoad);
                    }
                    else if (_.isFunction(callback.handleEvent)){
                        callback.handleEvent.apply(callback, payLoad);
                    }
                });
            }

            return this;
        }

    });


})(_, xfalib);


(function (_, $, xfalib) {
    var XfaUtil = xfalib.ut.XfaUtil = function () {
        },
        registeredLocaleProperties = null,
        timeoutListenerAttached = false,
        timeouts = [],
        attachClearTimeoutListener = function (timeout) {
            timeouts.push(timeout);
            if (timeoutListenerAttached === false) {
                $(window).one("destroy.xfa", function () {
                    _.each(timeouts, function (_timeout) {
                        clearTimeout(_timeout);
                    });
                    timeouts = [];
                    timeoutListenerAttached = false;
                });
                timeoutListenerAttached = true;
            }
        };
    _.extend(XfaUtil.prototype, {
        _globalUniqueId: (new Date()).getTime(),
        logger: null,

        formScaleFactor: 1,      // used to appropriately scale the form when contained inside an iframe

        getOrElse: xfalib.ut.Class.prototype.getOrElse,
        //map of event names between XTG and Mobile Form
        //Mobile Form uses different names for some the event and let's fix those names before sending them to XTG.
        _xtgEventName: {
            "$formready": "ready",
            "$layoutready": "ready"
        },

        generateUID: function () {
            return "UID" + (++XfaUtil.prototype._globalUniqueId);
        },

        matchJsonType: function (jsonModel, _class) {   //TODO: handle getOrElse
            return (jsonModel && _class && XfaUtil.prototype.getOrElse(jsonModel._class, "").toLowerCase() == ("" + _class).toLowerCase());
        },

        $data: function (elem, name, data) {
            if (!$.data(elem, "_xfaInitialized")) {
                //Initialized data- attributes parse for once using this call.
                // Next onward don't use this. Instead use $.data which is cheap/
                $(elem).data();
                $.data(elem, "_xfaInitialized", true); //Mark the element to say that data has been initialized.
            }
            return $.data(elem, name, data);
        },

        /*
         * alternative to jQuery.css which sets style properties directly through element.style. This is much faster then
         * corresponding jQuery.css alternative.
         *
         * Warning: this only supports standard css property names and does not do any pre-processing of name and value.
         * So calling this, make sure the style names are compatible.
         */
        $css: function (elem, stylesObj) {
            // Exclude the following css properties to add px. copied from jquery.cssNumber to add hyphenated style names
            var cssNumber = {
                "fillOpacity": true,
                "fill-opacity": true,
                "fontWeight": true,
                "font-weight": true,
                "lineHeight": true,
                "line-height": true,
                "zIndex": true,
                "z-index": true,
                "opacity": true,
                "orphans": true,
                "widows": true,
                "zoom": true
            };

            for (var prop in stylesObj) {
                var value = stylesObj[prop];
                // If a number was passed in, add 'px' to the (except for certain CSS properties)
                if (_.isNumber(value) && !cssNumber[ prop ]) {
                    value += "px";
                }
                elem.style[prop] = value;
            }
        },

        isTableHF: function (iChildNode) {
            //model can be a Node object or simply a json
            var assistJson = _.find(iChildNode.children, function (jChild) {
                return jChild._class == "assist";
            }, this);
            var childRole = (assistJson || {}).role;
            if (childRole == "TH" || childRole == "TF")
                return true;
            else
                return false;
        },

        getUiOneOfChildTag: function (uiParent) {
            var uiEl = _.find(uiParent.children, function (child) {
                return child._class == "ui";
            });
            if (!uiEl)
                return undefined;
            var uiOneOfChildMap = xfalib.runtime.xfa._templateSchema._getOneOfChild("ui");
            var uiOneOfChild = _.find(uiEl.children, function (child) {
                return uiOneOfChildMap[child._class] == true;
            });
            if (!uiOneOfChild)
                return undefined;
            return uiOneOfChild._class;
        },

        //TODO: this should be removed. One of the worst function.
        dIndexOf: function (searchArray, item2Find) {
            var ind = -1;
            _.find(searchArray, function (item, index) {
                return item == item2Find && (ind = index)
            });
            return ind;
        },

        splitStringByWidth: function (value, width, refEl) {
            var i = value.length , expectedWidth;
            do {
                expectedWidth = xfalib.view.util.TextMetrics.measureExtent(value.slice(0, i), {"refEl": refEl, maxWidth: -1}).width;
                i--;
            } while (expectedWidth > width)
            if (i != value.length - 1)
                return value.slice(0, i + 1);
            return value;
        },

        isRepeatabeEl: function (elTag) {
            if (elTag == "subform" || elTag == "subformSet")
                return true;
            else
                return false;
        },

        /**
         * @function
         * stripOrCall(toStrip, diffFunc, fArgs)
         * @description
         * common utility function to handle final submission payload stripping
         * @param {bool} toStrip : flag to signify whether to optimize jsonModelDiff size, by stripping off unnecessary properties
         * @param {function} diffFunc : callback func. call in case submit is not on
         * @param {Array} fArgs : arguments to be passed to the diff func.
         * @returns {object} object containing the jsonDiff
         */
        // should ALWAYS be called with a flag signifying if a submission is in progress,
        // and a callback function to compute the json to be sent back during submission, usually an apt '_computeJsonDiff'
        stripOrCall: function (toStrip, diffFunc, fArgs) {
            if (toStrip) {
                return {
                    "changed": false,
                    "jsonDifference": {}
                };
            }
            else if (_.isFunction(diffFunc)) {
                return diffFunc.apply(this, fArgs);
            }
        },

        /**
         * @function
         * partialStripOrCall(stripLvl, diffFunc, fArgs)
         * @description
         * common utility function to handle final submission payload stripping or for output of getFormState.
         * @param {int} diff_level : flag to signify whether to optimize jsonModelDiff size, by stripping off unnecessary properties
         *                        must be 0,1, or 2, as with "diff_level" param of _computeJsonDiff.
         * @param {function} diffFunc : callback func. call in case submit is not on
         * @returns {object} object containing the jsonDiff
         */
        partialStripOrCall: function (diff_level, diffFunc) {
            var diffObj = diffFunc.call(this, diff_level);

            if (!diffObj.changed) {
                if(diff_level === 1) {
                    diffObj = {
                        "changed": true,
                        "jsonDifference": {
                            "_class": this.jsonModel._class,
                            "name": this.jsonModel.name
                        }
                    };
                } else {
                    diffObj.jsonDifference = {};  // don't need stuff for other cases
                }
            }

            return diffObj;
        },

        /**
         * @function
         * stripObject(obj, exceptionNames)
         * @description
         * Utility function to strip unnecessary properties from an object
         * @param {object} obj : the object to strip
         * @param {Array} exceptionNames : array holding names of important properties to preserve
         * @returns {boolean} : true if this obj, or any of it's descendant is returned un-stripped
         */
        stripObject: function (obj, exceptionNames) {
            if (_.isEmpty(obj) || !_.isObject(obj)) {
                return true;
            } else {
                var dontStrip = false;
                _.each(_.keys(obj), function (propName) {
                    var keepProp = false;
                    if (!_.contains(exceptionNames, propName)) {
                        if (_.isArray(obj[propName])) {
                            _.each(obj[propName], function (arrElem) {
                                var isUnStripped = XfaUtil.prototype.stripObject(arrElem, exceptionNames);
                                keepProp = keepProp || isUnStripped;
                            });
                        } else if (_.isObject(obj[propName])) {
                            keepProp = XfaUtil.prototype.stripObject(obj[propName], exceptionNames);
                        }

                        if (!keepProp) {
                            delete obj[propName];
                        } else {
                            dontStrip = true;
                        }
                    } else {
                        dontStrip = true;
                    }
                });
                return dontStrip;
            }
        },

        computeDomJsonDiff: function (domNode, diff_level) {
            var changed = true;
            if (domNode.hasOwnProperty("_modelChanged")) {
                changed = domNode._modelChanged;
            }
            var jsonDiff = {};
            if (changed) {
                this.copyObject(domNode.jsonModel, jsonDiff, {"exceptions": ["children", "{default}", "extras"]});
            } else {
                jsonDiff = {_class: domNode.className};
            }
            if (!changed && domNode.jsonModel.hasOwnProperty("name")) {
                jsonDiff.name = domNode.jsonModel.name;
            }
            if (domNode.name === "FS_EXTRAS" && diff_level === 3) {
                domNode._childModified = true;
            }
            return {
                "changed": changed,
                jsonDifference: jsonDiff
            };
        },

        getLogger: function () {
            return XfaUtil.prototype.logger || XfaUtil.prototype.getOrElse(xfalib, "runtime.xfa.Logger", null);
        },

        getErrorManager: function () {
            return XfaUtil.prototype.getOrElse(xfalib, "runtime.xfa.ErrorManager", null);
        },

        XFA_CLICK_EVENT: "xfaclick",
        XFA_EXIT_EVENT: "xfaexit",
        XFA_ENTER_EVENT: "xfaenter",
        XFA_CHANGE_EVENT: "xfachange",
        XFA_PREOPEN_EVENT: "xfapreopen",

        btwn: function (val, a, b) {
            return val > a && val < b;
        },

        // function to detect if Browser is chrome / safari (webkit)
        isWebkit: function () {
            return  !!$.browser.webkit || /webkit/.test(navigator.userAgent.toLowerCase()) || !!window.chrome || !!$.browser.chrome || /chrom(e|ium)/.test(navigator.userAgent.toLowerCase()) || !!$.browser.safari || !!window.webkitURL ||
                ( /safari/.test(navigator.userAgent.toLowerCase()) &&
                    /apple computer/.test(navigator.vendor.toLowerCase()) );

            // TODO : find a better way to do this as $.browser is deprecated and
            // userAgent may be spoofed
        },

        clearTimeoutOnDestroy: function (timeout) {
            attachClearTimeoutListener(timeout);
        },

        // function to detect if Browser is  safari
        isSafari: function () {
            return ( /safari/.test(navigator.userAgent.toLowerCase()) &&
                    /apple computer/.test(navigator.vendor.toLowerCase()) );
        },

        getLocaleStrings: function () {
            return xfalib.locale.Strings;
        },

        getLogMessages: function () {
            return xfalib.locale.LogMessages;
        },

        /*
         * This function should not be added in the prototype of any Object
         * as in the case of other functions
         */
        registerLocaleProperties: function (props) {
            registeredLocaleProperties = props;
        },

        /*
         * This function should not be added in the prototype of any Object
         * as in the case of other functions
         */
        getDefaultLocaleProperty: function (property) {
            var localeProps = registeredLocaleProperties || this.getOrElse(xfalib, "script.Xfa._defaultLocale", null);
            return this.getOrElse(localeProps, property, null);
        },

        /**
         * Encodes <script> and </script> with &lt;script&gt; and &lt;/script&gt;
         * Does same with img, video and audio tags also.
         * These tags are being removed since scripts can be run through
         * <img onerror="script" /> (same for audio and video).
         */
        encodeScriptableTags: function (str) {
            var index;
            if (_.isString(str)) {
                return str.replace(/<(\/?)(script[^<>]*)>/gi, '&lt;$1$2&gt;')
                    .replace(/<(\/?)(img[^<>]*)>/gi, '&lt;$1$2&gt;')
                    .replace(/<(\/?)(video[^<>]*)>/gi, '&lt;$1$2&gt;')
                    .replace(/<(\/?)(audio[^<>]*)>/gi, '&lt;$1$2&gt;')
            }
        },

        /**
         *
         * @param id : a string representing an HTML element id.
         *
         * return after applying an escaping '\' before each # . : [ ]
         */
        jqId: function(id) {
            return "#" + id.replace(/(#|:|\.|\[|\])/g, "\\$1");
        },

        _triggerOnBridge: function (eventName, target, property, oldVal, newVal) {
            var evnt = xfalib.script.XfaModelEvent.createEvent(eventName, target,
                property, oldVal, newVal);
            if(formBridge){
                window.formBridge.trigger(eventName, evnt);
            }
        },

        /*
         * pads the passed in String str by pre-pending padChars to convert it to a string of given width.
         * If string length is already greater that equal to given width, original string is returned.
         */
        padString : function (str, width, padChar) {
            padChar = padChar || '0';
            str = str + '';
            return str.length >= width ? str : new Array(width - str.length + 1).join(padChar) + str;
        },

        /**
         * returns true if the browser is IE otherwise false
         * @returns {boolean}
         */
        isIE: function () {
            return $.browser.msie || (navigator.appName === "Netscape" && navigator.userAgent.match(/Trident\//))
        },

        /**
         * returns false if other browser
         * if ie tries to return browser version (non falsy)
         * @returns {*}
         */

        detectIE: function () {
            // 1st try jq
            if($.browser.msie) {
                if($.browser.version && parseInt($.browser.version, 10)) {
                    return parseInt($.browser.version, 10);
                }
            }

            var ua = window.navigator.userAgent;

            // IE 10
            // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';

            // IE 11
            // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';

            // IE 12 / Spartan
            // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';

            // Edge (IE 12+)
            // ua = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Safari/537.36 Edge/13.10586';

            var msie = ua.indexOf('MSIE ');
            if (msie > 0) {
                // IE 10 or older => return version number
                return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
            }

            var trident = ua.indexOf('Trident/');
            if (trident > 0) {
                // IE 11 => return version number
                var rv = ua.indexOf('rv:');
                return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
            }

            var edge = ua.indexOf('Edge/');
            if (edge > 0) {
                // Edge (IE 12+) => return version number
                return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
            }

            // other browser
            return false;
        },
        /**
         * returns true if the browser is chrome otherwise false
         * @returns {boolean}
         */
        detectChrome : function () {
            return (!!window.chrome || !!$.browser.chrome || /chrom(e|ium)/.test(navigator.userAgent.toLowerCase()));
        },

        /**
        * @param {String} val: value to be verified
        * @returns {boolean}
        * returns true if the provided string contains DOM element
        */
        isHTML: function(val) {
            //check whether string contains tags, so that $val does not contain result of the val used as selector
            // eg: val = "a" will return result for $(val) which is not required
            if(val && /<[a-z][\s\S]*>/.test(val)) {
                try {
                    var $val = $(val);
                    return $val.length > 0;
                } catch (exception) {
                    // if jquery throws exception that means string is not a proper HTML
                    return false;
                }
            } else {
                return false;
            }
        },

        /**
         * returns true if passed key is non printable, false otherwise.
         * @param {String} key event.key property of a Keyboard event
         */
        isNonPrintableKey : function (key) {
            return (key   // In IE, event.key returns words instead of actual characters for some keys.
               && !_.contains(['MozPrintableKey','Divide','Multiply','Subtract','Add','Enter','Decimal','Spacebar','Del'],key)
               && key.length != 1 )
        },

        /**
        * returns true for ipad
        * @returns {boolean}
        */
        _isIpad : function () {
            return navigator.userAgent.match(/iPad/i) != null;
        },

        /**
        * returns true if the subform is table or having role table else false
        * @param {Object} view
        */
        _tableCheckForAccessibility : function (view) {
            var assist = view.model.getElement("assist", 0, true);
            return this.getOrElse(view, "layoutModel.layout", null) == xfalib.view.LayoutConst.LAYOUT_TABLE
                || this.getOrElse(assist, "role", null) == "Table";
        },

        /**
        * returns value of tooltip to be assigned as title based on values provided in accessibility
        * @param {Object} model
        * @returns toolTipText
        */
        _getToolTipText : function (model) {
            var assist = model.getElement("assist", 0, true),
                toolTipText = "";
            // going against xfa spec, on hover show tooltip or speak text or element name, don't show caption as it's already visible
            // assist priority doesn't matter, but selecting none will disable tooltip on hover
            if (this.getOrElse(assist, "speak.disable", 0) != 1) { // loose compare string value
                toolTipText = this.getOrElse(assist, "toolTip.value", "") ||
                    this.getOrElse(assist, "speak.value", "")   ||
                    this.getOrElse(model, "jsonModel.name", "");
            }
            return toolTipText;
        },

        /**
        * returns value of mandatory message
        * @param {Object} model
        * @returns mandatoryMessage
        */
        _getMandatoryMessage : function (model) {
            var defaultMessage = model._defaults.validate.message.defaultMessage,
                msg = this.getOrElse(model, "validate.message.nullTest", defaultMessage);
            return (msg && msg.value) ? msg.value : defaultMessage.value;
        },
        /**
        * returns boolean based on val1, val2, checkEqual
        * For comparing date, use date object
        */
        _compareVal : function (val1, val2, checkEqual) {
            if(!val1 || !val2) {
                return false;
            }

            if(checkEqual) {
                return val1 >= val2;
            } else {
                return val1 > val2;
            }
        }
    });

    //Special handling for IE.
    if ($.browser.msie || $.browser.mozilla) {
        XfaUtil.prototype.$css = function (elem, stylesObj) {
            $(elem).css(stylesObj);
        }
    }
})(_, $, xfalib);
/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/



(function (_, $, xfalib) {
    xfalib.ut.Utilities = {

        isIE11: function () {
            return !!navigator.userAgent.match(/Trident.*rv\:11\./);
        },

        checkMinMozillaVersion: function (version) {
            return (!this.isIE11() && $.browser.mozilla && parseInt($.browser.version) >= version);
        },

        getObjectFromKeyValueStringList: function (list) {
            var key, value, object = {}, tempArray;
            _.each(list, function (keyValuePair, index) {
                tempArray = keyValuePair.split("=");
                if (tempArray && tempArray.length > 1) {
                    object[tempArray[0]] = tempArray[1];
                }
            });
            return object;
        },

        _getNameWithoutMarker: function (fileName) {
            var markerIndex = fileName.indexOf("__afAttachment__");
            if (markerIndex !== -1) {
                fileName = fileName.substring(markerIndex + "__afAttachment__".length, fileName.length);
            }
            return fileName;
        },

        /*
         * This is to check support of multiple files selection in one add new dialog
         */
        _isDataContainerSupported : function () {
            try {
                var dataContainer = new DataTransfer() || (new ClipboardEvent("")).clipboardData;
                if (dataContainer && dataContainer.items) {
                    return true;
                }
            } catch(err) {
                // if err comes then dataContainer is not supported
            }
            return false;
        }
    };
})(_, $, xfalib);
/**
 * @package xfalib.ut.Scanner
 * @fileOverview helper class to scan over a string.
 * @version 0.0.1
 */

/**
 * @constructor
 * @param Object {jsonModel:{_str: String}}
 */

(function(_,xfalib){
    var Scanner = xfalib.ut.Scanner = xfalib.ut.Class.extend({

        initialize: function() {
            this._pos = 0;
        },

        isEOF : function(){
            return (this.jsonModel._str.length <= this._pos);
        },

        peek : function(){
            return (this.isEOF()) ? null : this.jsonModel._str.charAt(this._pos);
        },

        optionalConsumeChar : function(aChar){
            if(this.jsonModel._str.charAt(this._pos) == aChar){
                this._pos++;
                return aChar;
            }else{
                return null;
            }
        },

        /**
         * Gets next char ignore quoted string.
         *    |
         *   abc returns c.
         *     |
         *   abc'de'f returns f.
         * @param aChar
         */
        getNCharIQS : function(){
            this._pos++;
            if(this.jsonModel._str.length <= this._pos){
                var current = this.jsonModel._str.charAt(this._pos);
                if(current != '\''){
                    return current;
                }else{
                    if(moveNextExpectedChar('\'')){
                        return this.jsonModel._str.charAt(this._pos);
                    }
                }
            }
            return null;
        },

        moveNextExpectedChar : function(aChar){
            this._pos++;// currently point to '
            while(this._pos< this.jsonModel._str.length && this.jsonModel._str.charAt(this._pos) != aChar){
                this._pos++;
            }
            return this._pos < this.jsonModel._str.length;
        },

        readInteger : function(len){
            if(this.pos+len >this.jsonModel._str.length){
                return null;
            }
            var integer = xfalib.ut.PictureUtils.parseIntExact(this.jsonModel._str,this._pos,len);
            this._pos+=len;
            return integer;
        }
    });

    Scanner.lookupNext = function(pat, patPos, filter){
        var patLen = pat.length;
        if(patPos >= patLen){
            return null;
        }

        var token = {};
        token.startPos = patPos;

        var firstChar = pat.charAt(patPos);
        var patValid = false;
        //
        if (firstChar == '\''){
            for (var i = patPos+1; i < patLen;i++ ){
                var chr = pat.charAt(i);
                if(chr =='\''){
                    token.type=1;
                    token.len = i - patPos + 1;
                    patValid = true;
                    break;
                }
            }

        }else if( ('a' <= firstChar && firstChar <= 'z' || 'A' <= firstChar && firstChar <= 'Z') || filter.call(null, firstChar)){
            var endPos = patLen;//end is exclusive
            for (var i = 1; patPos+i < patLen;i++ ){
                if(pat.charAt(patPos+i)!=firstChar){
                    endPos = patPos+i;
                    break;
                }
            }
            token.type=2;
            token.len = endPos - patPos;
            token.patChar = firstChar;
            token.patPos = patPos;
            patValid = true;
        }else{
            if (firstChar == '?' || firstChar == '+' || firstChar == '*') {
                token.type=3;
                token.len = 1;
            }else{
                token.type=4;
                token.len = 1;
            }
            patValid = true;
        }
        if(patValid){
            return token;
        }else{
            throw "Picture is invalid.";
        }
    }
})(_,xfalib);


/**
 * @package xfalib.ut.PictureFmt
 * @fileOverview The file defines methods to parse and format data
 * according to XFA picture patterns.
 * @version 0.0.1
 */
(function(_,xfalib) {

    var PictureFmt = xfalib.ut.PictureFmt = function() {};
    PictureFmt.DatePicturePattern =  /^date(?:\([a-zA-Z]*_[a-zA-Z]*\))?\{([\w\W]*?)\}$/;
    PictureFmt.TimePicturePattern =  /^time(?:\([a-zA-Z]*_[a-zA-Z]*\))?\{([\w\W]*?)\}$/;
    PictureFmt.TextPicturePattern =  /^text\{([\w\W]*?)\}$/;
    PictureFmt.NumPicturePattern =  /^num\{([\w\W]*?)\}$/;

    /**
     * Parses a given data source according to the given picture.
     * @param sSource {string}
     * @param sPicture {string}
     * @param sLocale {string}
     * @returns {object}
     */
    PictureFmt.parse  = function(sSource, sPicture,sLocale){
        var PictureEngine = new xfalib.ut.PictureEngine({jsonModel:{locale:sLocale}});

        var match = PictureFmt.DatePicturePattern.exec(sPicture);
        if(match && match[1]){
            return PictureEngine.parseDate(sSource, match[1]);
        }
        match = PictureFmt.TimePicturePattern.exec(sPicture);
        if(match && match[1]){
            return PictureEngine.parseTime(sSource, match[1]);
        }
        match = PictureFmt.TextPicturePattern.exec(sPicture);
        if(match && match[1]){
            return PictureEngine.parseText(sSource, match[1]);
        }
        match = PictureFmt.NumPicturePattern.exec(sPicture);
        if(match && match[1]){
            return PictureEngine.parseNumeric(sSource, match[1]);
        }
        throw "Invalid picture clause "+sPicture;
    };

    /**
     * Formats a given data source according to the given picture.
     * @param date {object}
     * @param sPicture {string}
     * @param sLocale {string}
     * @returns {string}
     */
    PictureFmt.format  = function(sSource, sPicture, sLocale,bRelaxed,bFormatNumberFromasDefaultPC){
        var PictureEngine = new xfalib.ut.PictureEngine({jsonModel:{locale:sLocale}});

        var match = PictureFmt.DatePicturePattern.exec(sPicture);
        if(match && match[1]){
            return PictureEngine.formatDate(sSource, match[1]);
        }
        match = PictureFmt.TimePicturePattern.exec(sPicture);
        if(match && match[1]){
            return PictureEngine.formatTime(sSource, match[1]);
        }
        match = PictureFmt.TextPicturePattern.exec(sPicture);
        if(match && match[1]){
            return PictureEngine.formatText(sSource, match[1],bRelaxed);
        }
        match = PictureFmt.NumPicturePattern.exec(sPicture);
        if(match && match[1]){
            return PictureEngine.formatNumeric(sSource, match[1],sLocale,bRelaxed,bFormatNumberFromasDefaultPC);
        }
            throw "Invalid picture clause "+sPicture;
    };

    /**
     * Checks if a given data source is formatted according to the given picture.
     * @param date {object}
     * @param sPicture {string}
     * @param sLocale {string}
     * @returns {boolean}
     */
    PictureFmt.formatTest = function (sSource, sPicture, sLocale, bRelaxed, bFormatNumberFromasDefaultPC) {
        var formattedData;
        try {
            formattedData = PictureFmt.format(sSource, sPicture, sLocale, bRelaxed, bFormatNumberFromasDefaultPC);
        }catch(e) {
            return false;
        }

        if(!_.isString(formattedData)) {
            return false;
        } else {
            var parsedData;
            try {
                parsedData = PictureFmt.parse(formattedData, sPicture, sLocale);
            } catch (e) {
                return false;
            }
            if(!_.isString(parsedData) && parsedData !== formattedData) {
                return false;
            }
        }
        return true;
    };

    /**
     * Parses a given data source according to the given date picture
     * under the given sLocale.
     * @param sSource {string}
     * @param sPicture {string}
     * @param sLocale {string}
     * @returns {string}
     */
    PictureFmt.parseDate  = function(sSource, sPicture,sLocale){
        var picRegexp = PictureFmt.DatePicturePattern;
        var match = picRegexp.exec(sPicture);
        var PictureEngine = new xfalib.ut.PictureEngine({jsonModel:{locale:sLocale}});
        if(match && match[1]){
            return PictureEngine.parseDate(sSource, match[1]);
        }else{
            return PictureEngine.parseDate(sSource, sPicture);
        }
    };


    /**
     * Formats a given data source according to the given date picture
     * * under the given sLocale.
     * @param date {string}
     * @param sPicture {string}
     * @param sLocale {string}
     * @returns {string}
     */
    PictureFmt.formatDate  = function(date, sPicture, sLocale){
        var picRegexp =  PictureFmt.DatePicturePattern;
        var match = picRegexp.exec(sPicture);
        var PictureEngine = new xfalib.ut.PictureEngine({jsonModel:{locale:sLocale}});
        if(match && match[1]){
            return PictureEngine.formatDate(date, match[1]);
        }else{
            return PictureEngine.formatDate(date, sPicture);
        }
    };

    /**
     * Parses a given data source according to the given date picture
     * under the given sLocale.
     * @param sSource {string}
     * @param sPicture {string}
     * @param sLocale {string}
     * @returns {date}
     */
    PictureFmt.parseTime  = function(sSource, sPicture,sLocale){
        var picRegexp = PictureFmt.TimePicturePattern;
        var match = picRegexp.exec(sPicture);
        var PictureEngine = new xfalib.ut.PictureEngine({jsonModel:{locale:sLocale}});
        if(match && match[1]){
            return PictureEngine.parseTime(sSource, match[1]);
        }else{
            return PictureEngine.parseTime(sSource, sPicture);
        }
        return null;
    };


    /**
     * Formats a given data source according to the given date picture
     * * under the given sLocale.
     * @param date {string}
     * @param sPicture {string}
     * @param sLocale {string}
     * @returns {string}
     */
    PictureFmt.formatTime  = function(date, sPicture, sLocale){
        var picRegexp =  PictureFmt.TimePicturePattern;
        var match = picRegexp.exec(sPicture);
        var PictureEngine = new xfalib.ut.PictureEngine({jsonModel:{locale:sLocale}});
        if(match && match[1]){
            return PictureEngine.formatTime(date, match[1]);
        }else{
            return PictureEngine.formatTime(date, sPicture);
        }
    };

    /**
     * Parses a given data source according to the given text picture
     * under the given sLocale.
     * @param sSource {string}
     * @param sPicture {string}
     * @param sLocale {string}
     * @returns {string}
     */
    PictureFmt.parseText  = function(sSource, sPicture,sLocale){
        var picRegexp = PictureFmt.TextPicturePattern;
        var match = picRegexp.exec(sPicture);
        var PictureEngine = new xfalib.ut.PictureEngine({jsonModel:{locale:sLocale}});
        if(match && match[1]){
            return PictureEngine.parseText(sSource, match[1]);
        }else{
            return PictureEngine.parseText(sSource, sPicture);
        }
    };

    /**
     * Formats a given data source according to the given text picture
     *  under the given sLocale.
     * @param sSource {string}
     * @param sPicture {string}
     * @param sLocale {string}
     * @returns {string}
     */
    PictureFmt.formatText  = function(sSource, sPicture, sLocale,bRelaxed){
        var picRegexp =  PictureFmt.TextPicturePattern;
        var match = picRegexp.exec(sPicture);
        var PictureEngine = new xfalib.ut.PictureEngine({jsonModel:{locale:sLocale}});
        if(match && match[1]){
            return PictureEngine.formatText(sSource, match[1],bRelaxed);
        }else{
            return PictureEngine.formatText(sSource, sPicture,bRelaxed);
        }
        return null;
    };

    /**
     * Parses a given data source according to the given numeric picture
     * under the given sLocale.
     * @param sSource {string}
     * @param sPicture {string}
     * @param sLocale {string}
     * @returns {string}
     */
    PictureFmt.parseNumeric  = function(sSource, sPicture,sLocale){
        var picRegexp = PictureFmt.NumPicturePattern;
        var match = picRegexp.exec(sPicture);
        var PictureEngine = new xfalib.ut.PictureEngine({jsonModel:{locale:sLocale}});
        if(match && match[1]){
            return PictureEngine.parseNumeric(sSource, match[1]);
        }else{
            return PictureEngine.parseNumeric(sSource, sPicture);
        }
        return null;
    };

    /**
     * Formats a given data source according to the given numeric picture
     *  under the given sLocale.
     * @param sSource {string}
     * @param sPicture {string}
     * @param sLocale {string}
     * @returns {string}
     */
    PictureFmt.formatNumeric  = function(sSource, sPicture, sLocale){
        var picRegexp =  PictureFmt.NumPicturePattern;
        var match = picRegexp.exec(sPicture);
        var PictureEngine = new xfalib.ut.PictureEngine({jsonModel:{locale:sLocale}});
        if(match && match[1]){
            return PictureEngine.formatNumeric(sSource, match[1]);
        }else{
            return PictureEngine.formatNumeric(sSource, sPicture);
        }
    };




    /**
     * Parses a given data source according to the given datetime picture
     * under the given sLocale.
     * @param sSource {string}
     *            the source data.
     * @param sPicture {string}
     *            the datetime picture.
     * @param sDateMask {string}
     *            the date sub-picture.
     * @param sTimeMask {string}
     *            the time sub-picture.
     * @param sLocale
     *            the locale name.
     *
     */
    PictureFmt.parseDateTime  = function(sSource, sPicture, sDateMask, sTimeMask, sLocale){

    };
    /**
     * Formats a given data source according to the given datetime picture
     * under the given locale.
     *
     * @param sSource {string}
     *            the source data.
     * @param sPicture {string}
     *            the datetime picture.
     * @param sDateMask {string}
     *            the date sub-picture.
     * @param sTimeMask {string}
     *            the time sub-picture.
     * @param sLocale {string}
     *            the locale name.
     */
    PictureFmt.formatDateTime  = function(sSource, sPicture, sDateMask, sTimeMask, sLocale){

    };

})(_,xfalib);
/**
 * @package xfalib.ut.PictureUtils
 * @fileOverview The file defines static utilities methods.
 * @version 0.0.1
 */

(function(_,xfalib){
    var PictureUtils = xfalib.ut.PictureUtils = function() {}

    PictureUtils.padding = function(number, digits, isFw, zero){
        var leading = ["0","00","000","0000"];
        var numStr = leading[digits-1] + number;
        return numStr.slice(- digits);
    };

    PictureUtils.parseIntAggressive = function(dateString, startPos,len){
        var result = new Object();
        var parsedNum = 0; //The number value parsed from dateString
        var parsedLen = -1; //How many chars parsed according to this pattern;
        for(var idx=0; idx<len && (startPos + idx) < dateString.length; idx++){
            var chr = dateString.charAt(startPos + idx);
            if(chr >='0' && chr <='9'){
                parsedNum = parsedNum *10 + (chr- '0');
            }else{
                parsedLen = idx;
                break;
            }
        }
        if(parsedLen == -1) {
            parsedLen = len;
        }
        result.value = parsedNum;
        result.len = parsedLen;
        return result;
    };

    PictureUtils.parseIntExact = function(dateString, startPos,len){
        var result = 0;
        PictureUtils.assert(startPos+ len <= dateString.length, "mismatch");
        for(var idx=0; idx<len ; idx++){
            var chr = dateString.charAt(startPos + idx);
            if(chr >='0' && chr <='9'){
                result = result *10 + (chr- '0');
            }else{
                throw "unexpected currentChar in PictureUtils.parseInt";
            }
        }
        return result;
    };

    PictureUtils.isDigit = function(chr){
        return /[0-9]/.test(chr) ;
    };

    PictureUtils.inString = function(chr,aString){
        return (aString.indexOf(chr) >=0) ;
    };


    var regExpIsLetter = /[\u0041-\u005a\u0061-\u007a\u00aa-\u00aa\u00b5-\u00b5\u00ba-\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u0236\u0250-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ee-\u02ee\u037a-\u037a\u0386-\u0386\u0388-\u038a\u038c-\u038c\u038e-\u03a1\u03a3-\u03ce\u03d0-\u03f5\u03f7-\u03fb\u0400-\u0481\u048a-\u04ce\u04d0-\u04f5\u04f8-\u04f9\u0500-\u050f\u0531-\u0556\u0559-\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0621-\u063a\u0640-\u064a\u066e-\u066f\u0671-\u06d3\u06d5-\u06d5\u06e5-\u06e6\u06ee-\u06ef\u06fa-\u06fc\u06ff-\u06ff\u0710-\u0710\u0712-\u072f\u074d-\u074f\u0780-\u07a5\u07b1-\u07b1\u0904-\u0939\u093d-\u093d\u0950-\u0950\u0958-\u0961\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2-\u09b2\u09b6-\u09b9\u09bd-\u09bd\u09dc-\u09dd\u09df-\u09e1\u09f0-\u09f1\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a59-\u0a5c\u0a5e-\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abd-\u0abd\u0ad0-\u0ad0\u0ae0-\u0ae1\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3d-\u0b3d\u0b5c-\u0b5d\u0b5f-\u0b61\u0b71-\u0b71\u0b83-\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c-\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb5\u0bb7-\u0bb9\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c60-\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd-\u0cbd\u0cde-\u0cde\u0ce0-\u0ce1\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d28\u0d2a-\u0d39\u0d60-\u0d61\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd-\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32-\u0e33\u0e40-\u0e46\u0e81-\u0e82\u0e84-\u0e84\u0e87-\u0e88\u0e8a-\u0e8a\u0e8d-\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5-\u0ea5\u0ea7-\u0ea7\u0eaa-\u0eab\u0ead-\u0eb0\u0eb2-\u0eb3\u0ebd-\u0ebd\u0ec0-\u0ec4\u0ec6-\u0ec6\u0edc-\u0edd\u0f00-\u0f00\u0f40-\u0f47\u0f49-\u0f6a\u0f88-\u0f8b\u1000-\u1021\u1023-\u1027\u1029-\u102a\u1050-\u1055\u10a0-\u10c5\u10d0-\u10f8\u1100-\u1159\u115f-\u11a2\u11a8-\u11f9\u1200-\u1206\u1208-\u1246\u1248-\u1248\u124a-\u124d\u1250-\u1256\u1258-\u1258\u125a-\u125d\u1260-\u1286\u1288-\u1288\u128a-\u128d\u1290-\u12ae\u12b0-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0-\u12c0\u12c2-\u12c5\u12c8-\u12ce\u12d0-\u12d6\u12d8-\u12ee\u12f0-\u130e\u1310-\u1310\u1312-\u1315\u1318-\u131e\u1320-\u1346\u1348-\u135a\u13a0-\u13f4\u1401-\u166c\u166f-\u1676\u1681-\u169a\u16a0-\u16ea\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7-\u17d7\u17dc-\u17dc\u1820-\u1877\u1880-\u18a8\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1d00-\u1d6b\u1e00-\u1e9b\u1ea0-\u1ef9\u1f00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59-\u1f59\u1f5b-\u1f5b\u1f5d-\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe-\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071-\u2071\u207f-\u207f\u2102-\u2102\u2107-\u2107\u210a-\u2113\u2115-\u2115\u2119-\u211d\u2124-\u2124\u2126-\u2126\u2128-\u2128\u212a-\u212d\u212f-\u2131\u2133-\u2139\u213d-\u213f\u2145-\u2149\u3005-\u3006\u3031-\u3035\u303b-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312c\u3131-\u318e\u31a0-\u31b7\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fa5\ua000-\ua48c\uac00-\ud7a3\uf900-\ufa2d\ufa30-\ufa6a\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e-\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]/

    /**
     * TODO Implement method equivalent to Character.isLetter.
     */
    PictureUtils.isLetter = function(chr){
        return regExpIsLetter.test(chr);
    };

    PictureUtils.isLetterOrDigit = function(chr){
        return this.isLetter(chr) || this.isDigit(chr);
    };

    /**
     * Scan this string for the first character in the given set. Similar to
     * strcspn().
     *
     * @param src{String}
     *            the string to scan
     * @param sSkip{String}
     *            the characters to scan for
     * @param nOffset{number}
     *            the position where to start the scan. Default = 0.
     * @return The position, relative to nOffset, for the first character found
     *         in the given set
     */
    PictureUtils.skipUntil = function(srcStr, sSkip, nOffset) {
        var nCharsSkipped = nOffset;

        // starting at the offset position, scan the characters in this string
        // until it matches one of the characters in the given set.
        while (nCharsSkipped < srcStr.length) {
            var i = nCharsSkipped;
            if (sSkip.indexOf(srcStr.charAt(i++)) >= 0)
                break;
            nCharsSkipped = i;
        }

        return nCharsSkipped - nOffset;
    };

    PictureUtils.matchString = function(str, startPos, target){
        if(startPos + target.length > str.length){
            return false;
        }else{
            for(var idx = 0; idx<target.length; idx++){
                if(target.charAt(idx) != str.charAt(startPos + idx)) return false;
            }
            return true;
        }
    };

    PictureUtils.assert = function(condition, message){
        if(!condition){
            throw message;
        }
    };

    PictureUtils.getLocaleObject = function(locale,property) {
        if(locale !== null && xfalib.runtime.xfa) {
            return xfalib.runtime.xfa._getLocaleSymbols(locale, property);
        } else {
            return xfalib.ut.XfaUtil.prototype.getDefaultLocaleProperty(property)
        }
    }

    PictureUtils.getHashOfLocaleObject = function(locale,property) {
          if(!PictureUtils.getHashOfLocaleObject[locale+"_"+property]) {
              var hashObj = {};
              _.each(PictureUtils.getLocaleObject(locale,property), function(val) {
                  var sVal = (val+"").toLowerCase();
                  var hash = 0;
                  for(var i =0;i<sVal.length;i++) {
                      hash+=(i+1)*sVal.charCodeAt(i)
                  }
                  hashObj[hash] = hashObj[hash] || [];
                  hashObj[hash].push(sVal);
              })
              PictureUtils.getHashOfLocaleObject[locale+"_"+property] = hashObj;
          }
          return PictureUtils.getHashOfLocaleObject[locale+"_"+property]
    }

    PictureUtils.convertNumberToLocale = function(locale,number) {
        var zero = PictureUtils.getLocaleObject(locale,"numberSymbols.zero");
        var zeroCode = zero.charCodeAt(0);
        number += "";
        var newNumber = [];
        for(var i = 0;i < number.length;i++) {
            newNumber.push(String.fromCharCode(zeroCode + parseInt(number.charAt(i))));
        }
        return newNumber.join("");
    }

    PictureUtils.parsePictureClause = function (clause){
        if(clause === null || clause === undefined) {
            return [];
        }
        var insidePattern = false,
            insideQuote=false,
            insideLocale = false,
            locale = "",
            type = "",
            pattern = "",
            flag = false,
            currentChar = "",
            result = [],
            matchType = /^num$|^text$|^date$/,
            matchLocale = /^[a-zA-Z]*_[a-zA-Z]*$/,
            i = 0,
            bracketOpenCount = 0;
        for(;i<clause.length;i++) {
            currentChar = clause.charAt(i);
            if(insideQuote && currentChar !== "'") {
                pattern += currentChar;
                continue;
            }
            switch(currentChar) {
               case "'":
                   if(!insidePattern) {
                       // ' is not allowed except insidePattern
                       return null;
                   }
                   insideQuote = !insideQuote;
                   pattern += currentChar;
                   break;
               case "{":
                    if(insidePattern || insideLocale || type === "") {
                        // { is not allowed insidePattern or insideLocale
                        return null;
                    }
                   insidePattern = true;
                    break;
                case "}":
                    if(!insidePattern || (insideLocale && pattern === "") || type === "") {
                        // { is allowed only insidePattern and not insideLocale
                        return null;
                    } else {
                        bracketOpenCount = 0;
                        insidePattern = false;
                        if(matchType.exec(type) === null) {
                            return null;
                        }
                        if(locale !== "" && matchLocale.exec(locale) === null) {
                            return null;
                        }
                        result.push({
                            category: type,
                            mask: pattern,
                            locale: locale
                        })
                    }
                    break;
                case "|":
                    if(type === "" || insidePattern || insideLocale) {
                        return null;
                    } else {
                        type = pattern = locale = "";
                        insidePattern = insideLocale = false;
                    }
                    break;
                case "(" :
                    if(type === "" || bracketOpenCount === 1) {
                        // ( is not allowed inside Locale
                        return null;
                    } else {
                        if(!insidePattern) {
                            insideLocale = true;
                        } else {
                            pattern += currentChar;
                        }
                        bracketOpenCount++;
                    }
                    break;
                case ")" :
                    if((!insideLocale && !insidePattern) || bracketOpenCount === 0) {
                        return null;
                    } else {
                        if(insidePattern) {
                            pattern += currentChar;
                        }
                        insideLocale = false;
                        bracketOpenCount--;
                    }
                    break;
                default:
                    if(insidePattern) {
                        pattern += currentChar;
                    } else if(insideLocale) {
                        locale += currentChar;
                    } else if(type !== "" && (pattern !== "" || locale !== "")){
                        return null;
                    } else {
                        type += currentChar;
                    }
                    break;
           }
       }
       if(insidePattern || insideLocale || insideQuote || bracketOpenCount !== 0) {
           return null;
       }
       return result;
    }

})(_,xfalib);

/**
 * @package xfalib.ut.VisitorBase
 * @import xfalib.ut.Class
 * @fileOverview Base class for visitor
 * @version 0.0.1
 */

/**
 * @constructor
 * @param Object {jsonModel: {_sPicture: String}}
 */

(function(_,xfalib) {
    var VisitorBase = xfalib.ut.VisitorBase = xfalib.ut.Class.extend({
        consume : function(token){
            switch (token.type)
            {
                case 1:
                    this.consumeStringLiteral(token);
                    break;
                case 2:
                    this.consumeSubPattern(token);
                    break;
                case 3:
                    this.consumeStringWildCard(token);
                    break;
                case 4:
                    this.consumeCharLiteral(token);
                    break;
            }
        },
        acceptPatternChar : function(chr){
            return false;
        },
        getPicture : function(){
            return this.jsonModel._sPicture;
        },
        abstractMethod : function(){
            throw "Not implemented";
        },
        consumeStringWildCard : this.abstractMethod,
        consumeStringLiteral: this.abstractMethod,
        consumeCharLiteral: this.abstractMethod,
        consumeSubPattern: this.abstractMethod,
        getResult: this.abstractMethod
    });
})(_,xfalib);

/**
 * @package xfalib.ut.NumPictureDesc
 * @import xfalib.ut.Class
 * @fileOverview Pre-process Numeric Picture.
 * @version 0.0.1
 */

/**
 * @constructor
 * @param Object {jsonModel: {_sPicture: String}}
 */

(function(_,xfalib){
    var NumPictureDesc = xfalib.ut.NumPictureDesc = xfalib.ut.Class.extend({

        initialize: function() {
            this.hasRadix = false;
            this.hasExpon = false;
            this.hasSign = false;
            this.hasPercent = false;
            this.fracDigit = 0;
            this.intDigit = 0;

            this._mbLeftParenSeen = false;
            this._mbRightParenSeen = false;
            this._compactPattern();
            this._xlatePattern();
            NumPictureDesc._super.initialize.call(this);
        },
        
        getPicture : function(){
            return this.jsonModel._sPicture;
        },

        _match2Char : function (char1, char2, idx){
            if(idx+1 < this.jsonModel._sPicture.length){
                return (this.jsonModel._sPicture.charAt(idx) ==char1 && this.jsonModel._sPicture.charAt(idx+1) ==char2);
            }else{
                return false;
            }
        },

        _xlatePattern : function(){
            var patPos = 0;
            for(var token = xfalib.ut.Scanner.lookupNext(this.jsonModel._sPicture, patPos, this._acceptPatternChar); token != null;  ){
                this._consume(token);
                patPos = patPos + token.len;
                token = xfalib.ut.Scanner.lookupNext(this.jsonModel._sPicture, patPos, this._acceptPatternChar);
            }
        },
        
        _compactPattern : function(){
            var buf = new Array();
            for(var index =0, len = this.jsonModel._sPicture.length; index <len; index++){
                if(this._match2Char('D','B',index)){
                    buf.push('D');
                    index++;
                }else if(this._match2Char('d','b',index)){
                    buf.push('d');
                    index++;
                }else if(this._match2Char('C','R',index)){
                    buf.push('C');
                    index++;
                }else if(this._match2Char('c','r',index)){
                    buf.push('c');
                    index++;
                }else{
                    buf.push(this.jsonModel._sPicture.charAt(index));
                }
            }
            this.jsonModel._sPicture = buf.join("");
        },

        _acceptPatternChar : function(chr){
            return xfalib.ut.PictureUtils.inString(chr, "(%$,.)89BCDERSVZbcdrsvzt");
        },

        _consume : function(token){
            if(token.type == 2){
                this._subConsume(token.patChar, token.len);
            }// else not a pattern
        },

        _subConsume : function(chr, chrCnt){
            switch (chr) {
                case'E' :
                    if (chrCnt > 1 || this.hasExpon || (this.fracDigit + this.intDigit)==0)
                        throw "Illegal Numeric Picture: more than one Expon";
                    this.hasExpon = true;
                    break;
                case '(':
                    if (chrCnt > 1 || this._mbLeftParenSeen	|| this.fracDigit + this.intDigit >0 )
                        throw "Illegal Numeric Picture:  ()";
                    this._mbLeftParenSeen = true;
                    break;

                case ')':
                    if (chrCnt > 1 || ! this._mbLeftParenSeen || this._mbRightParenSeen)
                        throw "Illegal Numeric Picture:  ()";
                    this._mbRightParenSeen = true;
                    if(this.fracDigit + this.intDigit >0) this.hasSign = true;
                    break;
                case 'S':
                case 's':
                case 'C': //CR
                case 'c': //cr
                case 'D': //DB
                case 'd': //db
                    this.hasSign = true;
                    break;
                case '%' :
                    this.hasPercent = true;
                    break;
                case '.':
                case 'V':
                case 'v':
                    if (chrCnt > 1 || this.hasRadix)
                        throw "Illegal Numeric Picture: too many vV.";
                    this.hasRadix = true;
                    this._mbFracStartSeen = true;
                    break;
                case '8' :
                case '9' :
                case 'Z':
                case 'z':
                    if (this.hasRadix){
                        this.fracDigit += chrCnt;
                    } else{
                        this.intDigit += chrCnt;
                    }
                    break;
            }
        },

        parseNumberInfo : function(msText){
            var text=msText,
                num = Number(text),
                negative = false
            if(num < 0){
                negative = true;
                num = -num;
                text = text.replace("-","");
            }
            if(this.hasPercent){
                num *= 100;
                text = ""+num;
            }
            var shift = 0;
            if(this.hasExpon){
                var threshold = Math.pow(10,this.intDigit);
                if(num < threshold){
                    while(num*10 < threshold) {
                        num *= 10;
                        shift--;
                    }
                }else{
                    while(num > threshold){
                        num /= 10;
                        shift++;
                    }
                }
                text = num+"";
            }
            var radixPos = text.indexOf(".", 0),
                fractionDigit = radixPos<0 ? 0 : text.length - radixPos - 1

            if(this.fracDigit < fractionDigit) {
                num = num.toFixed(this.fracDigit);
                text = num +""
            }

            if(text.indexOf("0") == 0 && msText.indexOf("0") != 0) {
                text = text.substring(1);
            }

            radixPos = text.indexOf(".", 0)
            var integerDigit = radixPos < 0 ? text.length : radixPos,
                offset = this.intDigit - integerDigit

            if(offset <0 ){
                throw "Exit: most significant " + offset +" digit lost";
            }
            return {
                "integerDigit" : integerDigit,
                "radixPos" : radixPos ,
                "fractionDigit" :  radixPos<0 ? 0 : text.length - radixPos - 1,
                "msText" : text,
                "shift" : shift,
                "isNegative" : negative,
                "padding" :offset
            };
        }
    });

    NumPictureDesc.gsDB = "DB";
    NumPictureDesc.gsCR = "CR";
    NumPictureDesc.gsE = "E";
    NumPictureDesc.gsDSP = "  ";
    NumPictureDesc.gsSSP = " ";

})(_,xfalib);











    /**
 * @package xfalib.ut.TimeInfo
 * @import xfalib.ut.Class
 * @fileOverview A wrapper class for date related information.
 * @version 0.0.1
 */

/**
 * @constructor
 */
(function(_,xfalib){
    var TimeInfo = xfalib.ut.TimeInfo = xfalib.ut.Class.extend({

        initialize: function() {
            this.mHourOfMeriDiem = -1;
            this.mHourOfDay = -1;
            this.mMinuteOfHour = -1;
            this.mSecondOfMinute = -1;
            this.mThousandthOfSecond = -1;
        },

        getISOTime : function(){
            var timeStr = "";
            if(this.mThousandthOfSecond>0){
                timeStr = "-" + this.formatNum(this.mThousandthOfSecond,3);
            }
            if(this.mSecondOfMinute>0 || timeStr!=""){
                timeStr = this.formatNum(this.mSecondOfMinute,2)+timeStr;
                timeStr = ":"+timeStr;
            }
            if(this.mMinuteOfHour>0 || timeStr!=""){
                timeStr = this.formatNum(this.mMinuteOfHour,2)+timeStr;
                timeStr = ":"+timeStr;
            }
            timeStr = this.formatNum(this.mHourOfDay,2) + timeStr;

            return timeStr;
        },

        formatNum : function(num, digits){
            if(num<0){
                num = 0;
            }
            return xfalib.ut.PictureUtils.padding(num, digits);
        },

        getDate : function(){
            var date = new Date();
            this.setTime(date);
            return date;
        },

        setTime : function(date){
            date.setHours(this.mHourOfDay);
            date.setMinutes(this.mMinuteOfHour);
            date.setSeconds(this.mSecondOfMinute);
            date.setMilliseconds(this.mThousandthOfSecond);
        }
    });

    /**
     *
     * <p>Valid ISO8601/XFA time strings are in any one
     * of the following time patterns:
     * <ul>
     * <li> HH[MM[SS[.FFF][z]]]
     * <li> HH[MM[SS[.FFF][+HH[MM]]]]
     * <li> HH[MM[SS[.FFF][-HH[MM]]]]
     * <li> HH[:MM[:SS[.FFF][z]]]
     * <li> HH[:MM[:SS[.FFF][+HH[:MM]]]]
     * <li> HH[:MM[:SS[.FFF][-HH[:MM]]]]
     * </ul>
     */
    TimeInfo.Parse = function(isoDateStr, locale){
        var scanner = new xfalib.ut.Scanner({jsonModel:{_str:isoDateStr}});
        var hours = scanner.readInteger(2);
        var minitues = -1;
        if(!scanner.isEOF()){
            scanner.optionalConsumeChar(':');
            minitues = scanner.readInteger(2);
        }
        var seconds = -1;
        if(!scanner.isEOF()){
            scanner.optionalConsumeChar(':');
            seconds = scanner.readInteger(2);
        }
        var milliseconds = -1;
        if(!scanner.isEOF()){
            scanner.optionalConsumeChar('-');
            milliseconds = scanner.readInteger(3);
        }
        //TODO timezone
        var info = new xfalib.ut.TimeInfo();
       TimeInfo.setPropertyIfNotNull(info,hours,"mHourOfDay");
       TimeInfo.setPropertyIfNotNull(info,minitues,"mMinuteOfHour");
       TimeInfo.setPropertyIfNotNull(info,seconds,"mSecondOfMinute");
       TimeInfo.setPropertyIfNotNull(info,milliseconds,"mThousandthOfSecond");
        return info;
    };

    /**
     *
     * static method
     */
    TimeInfo.setPropertyIfNotNull = function(object, value, proName){
        if(value!=null){
            var d = Number(value);
            if(!isNaN(d)){
                object[proName] = d;
            }
        }
    };

})(_,xfalib);
/**
 * @package xfalib.ut.DateInfo
 * @import xfalib.ut.Class
 * @fileOverview A wrapper class for date related information.
 * @version 0.0.1
 */

/**
 * @constructor
 */

(function(_,xfalib) {
    var DateInfo = xfalib.ut.DateInfo = xfalib.ut.Class.extend({

        initialize: function(options) {
            if (options && !options.isParsingCall ) { // skip setting internal values when called while parsing date formats
                this.date = new Date();
                this._year = this.date.getFullYear();
                this._month = this.date.getMonth() + 1;
                this._day = this.date.getDay();
            }
            DateInfo._super.initialize.call(this);
        },

        formatNum : function(num, digits){
            if(num<0)
                num = 0;
            return xfalib.ut.PictureUtils.padding(num, digits);
        },

        getDate : function(){
            return this.date;
        },
        setDate : function() {
          this.date = new Date(this._year,this._month-1,this._day)
        },
        getISODate : function(){
            var isoDate = [];

            isoDate.push(this.formatNum(this._year, 4));
            isoDate.push("-");
            isoDate.push(this.formatNum(this._month, 2));
            isoDate.push("-");
            isoDate.push(this.formatNum(this._day, 2));

            return isoDate.join("");
        },

        year : function(y) {
            if(y && y > 0 && y <= 9999)
                this._year = y;
            else
                throw "undefined year";
        },

        month : function(m) {
            if(m && m>0 && m < 13) {
               this._month = m;
            }
            else
                throw "Invalid month " + m;
        },

        _leapYear : function() {
            var year = this._year;
            return year % 400 == 0 || (year % 100 != 0 && year % 4 == 0);
        },

        _maxDate : function(m) {
              if(this._leapYear() && m == 2)
                 return 29;
              else return DateInfo.dates[m-1];
        },

        day : function(d) {
            if(d && d > 0 && d <= this._maxDate(this._month || 0))
                this._day = d;
            else
                throw "Invalid Date "+ d + " for the month "+(this._month);
        },

        validate : function(y, m, d) {
                this.year(y);
                this.month(m);
                this.day(d);
        }
    });

    DateInfo.ParseIsoString = function(isoDateStr, locale){
		var isDateRegexp = /^(\d{4})(?:-?(\d{1,2})(?:-?(\d{1,2}))?)?(?:T((\d{2}):(\d{2}):(\d{2}))Z)?$/;
        var match = isDateRegexp.exec(isoDateStr);
        if(match && match.length >= 4){
            var dateInfo = new DateInfo();
            var date = new Date(isoDateStr);
            // TODO - check if date is invalid.
            if(match[4] && date != null) { // if time is available then use date object for conversion otherwise use previous approach to support invalid date like 2012-10-101, 2010-02-29 etc for RTC CQ-4201274
                dateInfo.year(date.getFullYear());
                dateInfo.month(date.getMonth()+1);
                dateInfo.day(date.getDate());
            } else {
                try {
                    dateInfo.year(Number(match[1]));
                    dateInfo.month(Number(match[2]));
                    dateInfo.day(Number(match[3]));
                } catch(e) {
                    return null;
                }
            }
            dateInfo.setDate();
            return dateInfo;
        }
        return null;
    };

    DateInfo.Parse = function(dateStr, locale){
        locale = locale || "en_US";
        var patterns = xfalib.ut.PictureUtils.getLocaleObject(locale,"datePatterns"),
            isoDate = this.ParseIsoString(dateStr, locale);
        if(!_.isEmpty(isoDate)) {
            return isoDate;  // in case edit pattern is present, it'll be parsed by the widget during input and return an iso date string.
        }
        _.find(patterns, function(pattern) {
              try {
                  isoDate = xfalib.ut.PictureFmt.parseDate(dateStr,pattern,locale);
                  return true;
              } catch(exception) {
                  return false;
              }
        });
        isoDate = isoDate || dateStr;
        return DateInfo.ParseIsoString(isoDate);
    };

    DateInfo.dates = [31,28,31,30,31,30,31,31,30,31,30,31];
    DateInfo.daysOfWeek = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
})(_,xfalib);
/**
 * @package xfalib.ut.PictureEngine
 * @import xfalib.ut.Scanner
 * @fileOverview The file is a facade to assembly all components together.
 * @version 0.0.1
 */
(function(_,xfalib) {

    var PictureEngine = xfalib.ut.PictureEngine = xfalib.ut.Class.extend({

        _lookupNext: xfalib.ut.Scanner.lookupNext,

        MAX_XFA_PREC	: 8,		// Max no. of fractional digits in XFA.
        MAX_DBL_DIG	:18,		// Max no. of significant digits in a double.
        MAX_INT_DIG	:10,		// Max no. of significant digits in an integer.
        MAX_DBL_WIDTH	:15,		// Max width before precision loss in a double.
        INTEGRAL_FMT :  0,
        DECIMAL_FMT : 1,
        CURRENCY_FMT : 2,
        PERCENT_FMT : 3,

        parseDate : function(sSource, sPicture, locale){
            return this._acceptVisitor(new xfalib.ut.DateParsingVisitor({jsonModel:{_sPicture:sPicture,_dataString:sSource,_locale:this.jsonModel.locale}}));
        },

        formatDate : function(dDate, sPicture){
            var dateInfo = xfalib.ut.DateInfo.Parse(dDate, this.jsonModel.locale);
            if(dateInfo == null){
                return null;
            }else{
                return this._acceptVisitor(new xfalib.ut.DateFormattingVisitor({jsonModel:{_sPicture:sPicture,_dateInfo:dateInfo,_locale:this.jsonModel.locale}}));
            }
        },

        parseTime : function(sSource, sPicture){
            return this._acceptVisitor(new xfalib.ut.TimeParsingVisitor({jsonModel:{_sPicture:sPicture,_dataString:sSource}}));
        },

        formatTime : function(dDate, sPicture){
            var timeInfo = xfalib.ut.TimeInfo.Parse(dDate, this.jsonModel.locale);
            if(timeInfo == null){
                return null;
            }else{
                return this._acceptVisitor(new xfalib.ut.TimeFormattingVisitor({jsonModel:{_sPicture:sPicture,_timeInfo:timeInfo}}));
            }
        },

        parseText : function(sSource, sPicture){
            return this._acceptVisitor(new xfalib.ut.TextParsingVisitor({jsonModel:{_sPicture:sPicture,_dataString:sSource}}));
        },

        formatText : function(sSource, sPicture,bRelaxed){
            return this._acceptVisitor(new xfalib.ut.TextFormattingVisitor({jsonModel:{_sPicture:sPicture,_text:sSource,relaxed:bRelaxed}}));
        },

        parseNumeric : function(sSource, sPicture){
            var visitor = new xfalib.ut.NumParsingVisitor({jsonModel:{_sPicture:sPicture,_dataString:sSource,_locale:this.jsonModel.locale}}); // TODO : Is locale required
            visitor.parse();
            return visitor.getResult();
        },

       formatNumeric : function(sSource, sPicture,locale,bRelaxed,bFormatNumberFromasDefaultPC){

             var sFormatPicture =sPicture;
             if( bRelaxed && bFormatNumberFromasDefaultPC){
                 sFormatPicture = this.getNumberFormat(sPicture,1, {formatOption: "WITH_GROUPINGS",
                                      "precision"  : this.getNumberPrecision(sSource),
                                    "width"      : sSource.length
                                   });
             }
             return this._acceptVisitor(new xfalib.ut.NumFormattingVisitor({jsonModel:{_sPicture:sFormatPicture,_locale:this.jsonModel.locale},text:sSource}));
        },

        _acceptVisitor : function(visitor){
            this._scanPattern(visitor);
            return visitor.getResult();
        },

        _scanPattern : function(visitor){
            var patPos = 0;
            var sPicture = visitor.getPicture();
            for(var token = this._lookupNext(sPicture, patPos, visitor.acceptPatternChar); token != null;  ){
                visitor.consume(token);
                patPos = patPos + token.len;
                token = this._lookupNext(sPicture, patPos, visitor.acceptPatternChar);
            }
        },

       /**
          * Removes n bytes from this string starting at position nOffset.
         *
          * @param nOffset - start position for the remove
          * @param nLength - the number of characters to remove
          * @return This string
          */

         _swallow : function(sString , nOffset, nLenToSwallow)
         {
             if(_.isEmpty(sString) || nLenToSwallow ==0){
                 return sString;
             }

             if( (nOffset + nLenToSwallow)> sString.length ) {
                 nLenToSwallow = (nOffset + nLenToSwallow) - sString.length;
             }
            var subStr = sString.substr(0,nOffset) + sString.substr(offset + nLenToSwallow);

             return subStr
         },
         /**
         * Replace some portion of one string with another String.
          * @param sString - the String where it has to be replaced.
          * @param sReplacement - the replacement string.
          * @param nOffset - start position for the replacement. Default value = 0.
          * @param nCutLength - the number of bytes to remove from the
          * original string.
          */

         _replaceAll : function(sString ,sReplacement , nOffset ,nCutlength) {
             return sString.substr(0,nOffset) + sReplacement  + sString.substr(nOffset + nCutlength)
         },

         //----------------------------------------------------------------------
         // SkipOver
         //
         // Scan this string for the first byte of the character not in the given set.
         // Similar to strspn().
         //----------------------------------------------------------------------
         _skipOver : function(fromString,sSkip, nOffset)
         {
             // starting at the offset position, scan the characters in this string
             // until it does not match any of the characters in the given set.
            var nCharsSkipped = nOffset;
             var i = 0;
             while (nCharsSkipped < fromString.length)
             {
                 i = nCharsSkipped;
                 if (sSkip.indexOf(fromString[i]) ==-1) {
                     break;
                 }
                 i++;
                 nCharsSkipped = i;
             }

             return nCharsSkipped - nOffset;
         },

         /*
          * Get the numeric format in the given style.
          * @param style in the range of values 0-2,
          * where (0 = integral, 1 = decimal, 2 = currency).
          * @param option in the set of format options:
          */
         getNumberFormat : function(format , style, option)
        {
             if (style < this.INTEGRAL_FMT || this.PERCENT_FMT < style) {
                 style = this.DECIMAL_FMT;
             }

             var sFormat = format;

             //
             // Use any alternate part because they handle negative values.
             //
             var  nBar = 0;
             if ((nBar = sFormat.indexOf('|')) != -1) {
                 sFormat = this._swallow(sFormat, 0, nBar + 1);
             }
             //
             // Determine position of radix (or anything like it)
             // and the replicating part of the pattern, i.e., from
             // the separator to this radix.
            //
             var nDot;
             if ( (nDot = sFormat.indexOf('.')) == -1) {
                 if ((nDot = sFormat.indexOf('v')) == -1) {
                     if ((nDot = sFormat.indexOf('V')) == -1) {
                         if ((nDot = sFormat.indexOf('E')) == -1) {
                             if ((nDot = sFormat.indexOf(' ')) == -1) {
                                 if ((nDot = sFormat.indexOf('%')) == -1) {
                                     nDot = sFormat.length;
                                 }
                             }
                         }
                     }
                 }
             }
             if (nDot) {
                 if (this._skipOver(sFormat,"89zZ", nDot - 1) != 1) {
                     nDot = sFormat.length;
                 }
             }
             var sZZZ;
             var nZed;
             if ( (nZed = sFormat.indexOf("z,")) != -1) {
                 //
                 // Watson 1230768.  Handle locales, like India, that have
                 // pictures with more than one grouping symbol.
                //
                 var nSep = nDot;
                 var nComma;
                 if ((nComma = sFormat.indexOf(',', nZed + 2)) !=-1) {
                    nSep = nComma;
                 }
                 if (nSep > nZed + 2) {
                     sZZZ = Array(nSep - nZed).join('z');
                 }
                 else {
                     sZZZ = Array(1).join('z');
                 }
             }
             else {
                nZed = 0;
             }
             //
             // If non-integral styles Then determine width and precision.
             //
             var nPrec = 0;
             var nWidth = this.MAX_INT_DIG;
             if (style != this.INTEGRAL_FMT) {
                 nPrec = option.precision; // (option >> 8) & 0xff;
                 var trim = ((nPrec & 0x80) == 0);
                 nPrec &= 0x7f;
                 if (nPrec == 0x7f) {
                     nPrec = this._skipOver(sFormat, "89zZ", nDot + 1);
                 }
                 if ((option.width) != undefined) {
                     nWidth = option.width;
                 }
                 else {
                     nWidth = this.MAX_DBL_DIG;
                 }
                 //
                 // Fix for Watson 1229423.  If the locale's format contains
                 // any sign pictures Then widen accordingly.  Also widen if
                 // precision of locale's picture format is greater than requested.
                 //
                 if (sFormat.indexOf('s')!=-1) {
                     nWidth += 1;
                 }
                 if (sFormat.indexOf('(')!=-1) {
                     nWidth += 1;
                 }
                 if (sFormat.indexOf(')') !=-1) {
                     nWidth += 1;
                 }
                var nFmtPrec = this._skipOver(sFormat,"89zZ", nDot + 1);
                 if (0 < nPrec && nPrec < nFmtPrec) {
                     nWidth += nFmtPrec - nPrec;
                 }

                 //
                 // Pare down the precision if the width is big enough to yield
                 // IEEE 754 64-bit double precision errors, which appears to be
                 // anything over 14 significant digits.
                 //
                 if (trim && nPrec > 0 && nWidth > nPrec) {
                     //
                     // Fix for Watson 1211481.  If the given precision is less
                     // than what the locale's format dictates then widen the given
                     // width.
                    //
                     if (nPrec <= sFormat.length - 1 - nDot) {
                         nWidth += sFormat.length - 1 - nDot - nPrec;
                     }
                     for (var i = nWidth - 1; i > this.MAX_DBL_WIDTH; i--) {
                         //
                         // Never pare down the precision below what the locale's
                         // format dictates.
                         //
                         if (nPrec <= sFormat.length - 1 - nDot)
                            break;
                         nPrec--;
                     }
                 }
             }
             //Watson 1483675 - If the locale's format contains
             // a dollar sign or a space then widen accordingly.
             if (style == this.CURRENCY_FMT) {
                 if (sFormat.indexOf('$')!=-1) {
                     nWidth++;
                 }

                 if (sFormat.indexOf(' ')!=-1) {
                     nWidth += 1;
                }
             }

             //
             // If percent style was wanted Then truncate after the percent character.
             //
             if (style == this.PERCENT_FMT) {
                 var nTrim = this._skipOver(sFormat,"89zZ", nDot + 1);
                 sFormat = this._replaceAll(sFormat,"",nTrim,0)
                 //sFormat.Replace(jfString::EmptyString(), nDot + 1, nTrim);

                 //Watson 1483675 - If the locale's format contains
                 // a percent sign then widen accordingly.
                 if (sFormat.indexOf('%')!=-1) {
                     nWidth++;
                 }
             }
             //
             // Else if integral style was wanted Then truncate at the radix character.
             //
             //
             // If integral style was wanted Then truncate at the radix character.
             //
             else if (style == this.INTEGRAL_FMT || nPrec == 0){// && option.formatOption == "WITHOUT_RADIX") {
                 var nTrim = this._skipOver(sFormat,"89zZ", nDot + 1);
                 sFormat = this._replaceAll(sFormat,"",nDot,nTrim+1);
             }
             //
             // Otherwise for decimal and currency styles Do
             // replace fractional 'z' pictures with '8's to requested precision,
             //
             else if (option.formatOption == "WITH_EIGHTS") {
                 var nEight = nDot + 1;
                 while ((nEight =sFormat.indexOf('z'))!=-1) {
                     this._replaceAll(sFormat, '8', nEight,'8'.length);
                 }
                 while (sFormat.Length() - nDot <= nPrec) {
                     sFormat = this._replaceAll(sFormat, "8", nDot + 1, 0);
                 }
             }
             //
             // Or replace fractional '9' pictures with 'z's to requested precision
             // Watson 1322850 - add option to keep nines, previously this function
             // would force frac. digits to be either z's or 8's with no option for 9's.
             //
             else if ((option.formatOption) == "WITH_ZEDS" && !((option.formatOption) == "KEEP_NINES")) {
                 var nNine = nDot + 1;
                 while ((nNine = sFormat.indexOf('9'))!=-1) {
                     this._replaceAll(sFormat, 'z', nNine,1);
                 }
                 while (sFormat.Length() - nDot <= nPrec) {
                     this._replaceAll(sFormat, "z", nDot + 1, 0);
                 }
             }
             //
             // Replicate section from separator to radix to requested width.
             //
             if (!sZZZ) {
                 sZZZ = "z";
             }
            else if ((option.formatOption) == "WITHOUT_GROUPINGS" ) {
                 //
                 // Watson 1230768.  Handle locales, like India, that have
                 // pictures with more than one grouping symbol.
                 //
                 var nComma = nZed + 1 ;
                 this._replaceAll(sFormat, 'z' ,nComma,1);
                 while ( nComma!= -1 && (nComma < nDot)) {
                     nComma = sFormat.indexOf(',');
                     sFormat = this._replaceAll(sFormat,'z',nComma,1);
                 }
             }
             else if ((option.formatOption == "WITH_GROUPINGS")) {
                 sZZZ = this._replaceAll(sZZZ,',',0,1);
                 nWidth += (nWidth + sZZZ.length) / sZZZ.length;
             }
             while (sFormat.length < nWidth) {
                 sFormat = this._replaceAll(sFormat, sZZZ, nZed + 1, 0);
             }
             return sFormat;
         },

         /**
          * Get the decimal precision of the given numeric string.
          * @return the decimal precision or 0 for integral values.
          */
         getNumberPrecision: function(sVal)
         {
             var nRadix = 0;
             var i = -1;
             // Reason for not using the commented line. We are always storing the value in model with . as decimal separator
             // Passing field locale/ browser locale would lead to precision width being zero for non-english locales where
             // decimal separater may be different.
             // var rIndex = xfalib.ut.PictureUtils.getLocaleObject(this.jsonModel.locale,"numberSymbols").decimal;
             // so hardcoding . for now
             var rIndex = ".";
             if( (nRadix = sVal.indexOf(rIndex))!=-1)
             {
                     for(; nRadix <=sVal.length ;nRadix++) {
                         i++;
                     }

                 return i;
             }
             return 0;
          }
    })
})(_,xfalib);
/**
 * @package xfalib.ut.FormattingVisitorBase
 * @import xfalib.ut.VisitorBase
 * @fileOverview Base class for visitor
 * @version 0.0.1
 */

/**
 * @constructor
 * @param Object {jsonModel: {_sPicture: String]}
 */

(function(_,xfalib) {
    var FormattingVisitorBase = xfalib.ut.FormattingVisitorBase = xfalib.ut.VisitorBase.extend({

        initialize: function() {
            this._buffer = []; //TODO: ASK Ren where does this _buffer comes from
            FormattingVisitorBase._super.initialize.call(this);
        },

        consumeStringWildCard : function(token){
            //'?' '*' '+
            this._buffer.push(" ");
        },

        consumeStringLiteral : function(token){
            this._buffer.push(this.jsonModel._sPicture.substr(token.startPos+1,token.len-2));
        },

        consumeCharLiteral : function(token){
            this._buffer.push(""+ this.jsonModel._sPicture.charAt(token.startPos));
        }
    })

})(_,xfalib);
/**
 * @package xfalib.ut.ParsingVisitorBase
 * @import xfalib.ut.VisitorBase
 * @fileOverview Base class for visitor
 * @version 0.0.1
 */

/**
 * @constructor
 * @param Object {jsonModel: {_sPicture: String,_dataString: String}}
 */

(function(_,xfalib){
    var ParsingVisitorBase = xfalib.ut.ParsingVisitorBase = xfalib.ut.VisitorBase.extend({

        initialize: function() {
            this._strLen = this.jsonModel._dataString.length;
            this._strPos = 0;
            ParsingVisitorBase._super.initialize.call(this);
        },

        consumeStringWildCard : function(token){
            if (chr == '?') {
                if (this._strPos < this._strLen)//&& Character.isDefined(str.charAt(strPos))
                    this._strPos += 1;
            } else if (chr == '+') {
                if (this._strPos >= this._strLen)// || ! Character.isWhitespace(str.charAt(strPos)))
                    throw "Mismatch";
                this._strPos += 1;
                while (this._strPos < this._strLen)// && Character.isWhitespace(str.charAt(strPos)))
                    this._strPos += 1;
            } else if (chr == '*') {
                while (this._strPos < this._strLen)// && Character.isWhitespace(str.charAt(strPos)))
                    this._strPos += 1;
            }

        },

        consumeStringLiteral : function(token){
            for(var offset=0; offset<token.len-2 ;offset++){ //-2, heading and trailing quote
                if(this.jsonModel._sPicture.charAt(token.startPos+offset+1) != this.jsonModel._dataString.charAt(this._strPos+offset)){
                    throw ("Mismatch" + this.jsonModel._sPicture.substr(token.startPos, token.len));
                }
            }
            this._strPos += token.len-2;

        },

        consumeCharLiteral : function(token){
            if(this.jsonModel._sPicture.charAt(token.startPos) == this.jsonModel._dataString.charAt(this._strPos)){
                this._strPos += 1;
            }else{
                throw "Mismatch";
            }
        }
    })
})(_,xfalib);

/**
 * @package xfalib.ut.DateFormattingVisitor
 * @import xfalib.ut.FormattingVisitorBase
 * @fileOverview The file provides formating logic on date pattern characters.
 * @version 0.0.1
 */


/**
 * @constructor
 * @param object {jsonModel: {_sPicture:String,_dateInfo: xfalib.ut.DateInfo}}
 */

(function(_,xfalib) {
    var PictureUtils =  xfalib.ut.PictureUtils;
    var DateFormattingVisitor = xfalib.ut.DateFormattingVisitor = xfalib.ut.FormattingVisitorBase.extend({

        consumeSubPattern : function(token){
            var chr = token.patChar;
            var chrCnt = token.len;

            switch (chr) {
                case 'D':
                    var dayOfMonth=this.jsonModel._dateInfo.date.getDate();
                    switch(chrCnt){
                        case 1:
                            break;
                        case 2:
                            dayOfMonth = PictureUtils.padding(dayOfMonth,2);
                            break;
                    }
                    this._buffer.push(PictureUtils.convertNumberToLocale(this.jsonModel._locale,dayOfMonth));
                    break;
                case 'J':

                    //this._mDayOfYear;
                    break;
                case 'M':
                    var monthOfYear = this.jsonModel._dateInfo.date.getMonth();
                    switch(chrCnt){
                        case 1:
                            this._buffer.push(PictureUtils.convertNumberToLocale(this.jsonModel._locale,monthOfYear+1));
                            break;
                        case 2:
                            this._buffer.push(PictureUtils.convertNumberToLocale(this.jsonModel._locale,PictureUtils.padding(monthOfYear+1,2)));
                            break;
                        case 3:
                            var monthNames = PictureUtils.getLocaleObject(this.jsonModel._locale,"calendarSymbols.abbrmonthNames");
                            this._buffer.push(monthNames[monthOfYear]);
                            break;
                        case 4:
                            var monthNames = PictureUtils.getLocaleObject(this.jsonModel._locale,"calendarSymbols.monthNames");
                            this._buffer.push(monthNames[monthOfYear]);
                            break;
                    }

                    break;
                case 'E':
                    var dayOfWeek = this.jsonModel._dateInfo.date.getDay();
                    var dayNames;
                    switch(chrCnt) {
                        case 1:
                            this._buffer.push(dayOfWeek);
                            break;
                        case 3:
                            dayNames =  PictureUtils.getLocaleObject(this.jsonModel._locale,"calendarSymbols.abbrdayNames");
                            this._buffer.push(dayNames[dayOfWeek]);
                            break;
                        case 4:
                            dayNames =   PictureUtils.getLocaleObject(this.jsonModel._locale,"calendarSymbols.dayNames");
                            this._buffer.push(dayNames[dayOfWeek]);
                            break;
                        default:
                            throw "unsupported Picture Clause ";
                    }
                    break;
                case 'e':
                    break;
                case 'G':
                    break;
                case 'Y':

                    var yearOfEra = this.jsonModel._dateInfo.date.getFullYear()
                    switch(chrCnt){
                        case 2:
                            if(yearOfEra>2029 || yearOfEra < 1930){
                                throw "unsupported " + yearOfEra + " by pattern YY";
                            }
                            yearOfEra = PictureUtils.padding(yearOfEra % 100, 2);
                            break;
                        case 4:
                            yearOfEra = PictureUtils.padding(yearOfEra, 4); // 2 digit(0000-9999)
                            break;
                    }
                    this._buffer.push(PictureUtils.convertNumberToLocale(this.jsonModel._locale,yearOfEra));
                    break;
                case 'w':
                    break;
                case 'W':
                    break;
                default: throw "Unsupported pattern";
            }

        },
        /**
         *
         * @override
         */
        getResult : function(){
            return this._buffer.join("");
        }

    });
})(_,xfalib);


/**
 * @package xfalib.ut.TextFormattingVisitor
 * @import xfalib.ut.FormattingVisitorBase
 * @fileOverview Formats a string according to Text Picture.
 * @version 0.0.1
 */

/**
 * @constructor
 * @param Object { jsonModel:{_sPicture: String, _text: String}}
 */
(function(_,xfalib){
    var TextFormattingVisitor = xfalib.ut.TextFormattingVisitor = xfalib.ut.FormattingVisitorBase.extend({

        initialize: function() {
            this._textPos = 0;
            this._relaxed = typeof this.jsonModel.relaxed === "undefined" ? true: this.jsonModel.relaxed;
            TextFormattingVisitor._super.initialize.call(this);
        },

        consumeSubPattern : function(token){
            var chr = token.patChar;
            var chrCnt = token.len;
            for(var index = 0; index < chrCnt && (!this._relaxed || this._textPos < this.jsonModel._text.length); index++){
                switch (chr) {
                    case '9': // Numeric
                        var cUni = this.jsonModel._text.charAt(this._textPos++);
                        if(!xfalib.ut.PictureUtils.isDigit(cUni)){
                            throw "TextFormatting: not a digit as expected";
                        }
                        this._buffer.push(cUni);
                        break;
                    case 'A': // Alphebetic
                        var cUni = this.jsonModel._text.charAt(this._textPos++);
                        if(!xfalib.ut.PictureUtils.isLetter(cUni)){
                            throw "TextFormatting: not a character as expected";
                        }
                        this._buffer.push(cUni);
                        break;
                    case 'O': // Alphanumeric
                    case '0':
                        var cUni = this.jsonModel._text.charAt(this._textPos++);
                        // cUni === "" is a hack for LC-6152
                        // To prevent extra loop[one more time than the length of the string] for which cUni was ""
                        // which was neither a letter nor a digit
                        // so we were getting textformatting error
                        //which caused email id validation to fail for chars less than picture clause
                        if(!(cUni ==="" || xfalib.ut.PictureUtils.isLetter(cUni) || xfalib.ut.PictureUtils.isDigit(cUni))){
                            throw "TextFormatting: not a character or digit as expected";
                        }
                        this._buffer.push(cUni);
                        break;
                    case 'X':
                        var cUni = this.jsonModel._text.charAt(this._textPos++);
                        this._buffer.push(cUni);
                        break;
                    case 't':
                        this._buffer.push("\t");
                        break;
                    default: this._buffer.push(chr);
                }
            }

        },

        /**
         *
         * @override
         */
        getResult : function(){
            if(this._textPos < this.jsonModel._text.length)
                throw "TextFormatting: picture clause smaller than input Text";
            return this._buffer.join("");
        },

        /**
         *
         * @override
         */
        acceptPatternChar : function(chr){
            return xfalib.ut.PictureUtils.inString(chr, "9AO0Xt");
        },

        consumeCharLiteral : function(token){
         this._buffer.push(""+ this.jsonModel._sPicture.charAt(token.startPos));
         // LC-3869 : forward the text pointer after literal is present and matched with the picture.
         if(this.jsonModel._sPicture.charAt(token.startPos) == this.jsonModel._text.charAt(token.startPos))
             this._textPos++;
        }
    })

})(_,xfalib);


/**
 * @package xfalib.ut.TextFormattingVisitor
 * @import xfalib.ut.FormattingVisitorBase
 * @fileOverview The file provides formating logic on date pattern characters.
 * @version 0.0.1
 */

/**
 * @constructor
 * @param object {jsonModel: {_sPicture:String,_timeInfo: xfalib.ut.TimeInfo}}
 */

(function(_,xfalib){
    var TimeFormattingVisitor = xfalib.ut.TimeFormattingVisitor=  xfalib.ut.FormattingVisitorBase.extend({

        consumeSubPattern : function(token){
            var chr = token.patChar;
            var chrCnt = token.len;

            switch (chr) {
                case 'H':
                case 'K':
                    var hourOfDay = this.jsonModel._timeInfo.mHourOfDay;
                    if(chr=='K'){
                        hourOfDay += 1;
                    }
                    switch(chrCnt){
                        case 1:
                            this._buffer.push(hourOfDay);
                            break;
                        case 2:
                            this._buffer.push(xfalib.ut.PictureUtils.padding(hourOfDay,2));
                            break;
                    }
                    break;

                case 'M':
                    var minuteOfHour = this.jsonModel._timeInfo.mMinuteOfHour;
                    switch(chrCnt){
                        case 1:
                            this._buffer.push(minuteOfHour);
                            break;
                        case 2:
                            this._buffer.push(xfalib.ut.PictureUtils.padding(minuteOfHour,2));
                            break;
                    }

                    break;
                case 'S':
                    var secondOfMinute = this.jsonModel._timeInfo.mSecondOfMinute;
                    switch(chrCnt){
                        case 1:
                            this._buffer.push(secondOfMinute);
                            break;
                        case 2:
                            this._buffer.push(xfalib.ut.PictureUtils.padding(secondOfMinute,2));
                            break;
                    }
                    break;
                case 'F':
                    var Milliseconds =this.jsonModel._timeInfo.mThousandthOfSecond;
                    this._buffer.push(xfalib.ut.PictureUtils.padding(Milliseconds,3));
                    break;

                default: throw "Unsupported pattern";
            };

        },

        /**
         *
         * @override
         */
        getResult : function(){
            return this._buffer.join("");
        }

    });

})(_,xfalib);


/**
 * @package xfalib.ut.NumFormattingVisitor
 * @import xfalib.ut.FormattingVisitorBase
 * @fileOverview Formats a string according to Text Picture.
 * @version 0.0.1
 */

/**
 * @constructor
 * @param Object { jsonModel:{_sPicture: String}, text: String}
 */

(function(_,xfalib){
    var PictureUtils =  xfalib.ut.PictureUtils;
    var NumFormattingVisitor = xfalib.ut.NumFormattingVisitor = xfalib.ut.FormattingVisitorBase.extend({

        initialize: function(options) {
            NumFormattingVisitor._super.initialize.call(this);
            this._textPos = 0;

            //boolean value used for internal state track
            this._mbDigitAddedToOutput = false; // at least one digit has been added to output
            this._mbSignAddedToOutput = false;
            this._nScannedPatternDigit = 0; //how many digit(98Zz) characters scanned in pattern, reset to 0 after '.Vv'
            this._mbRadixSeen = false;

            this._pictureDesc = new xfalib.ut.NumPictureDesc({jsonModel:{_sPicture:this.jsonModel._sPicture}});
            this.jsonModel._sPicture= this._pictureDesc.getPicture();
            this._numberInfo = this._pictureDesc.parseNumberInfo(options.text);

            this._mbNegative = this._numberInfo.isNegative;
            this._msText = this._numberInfo.msText;
            this._leadingPadding = this._numberInfo.padding;
            //
            this._mNumberSymbols = xfalib.ut.PictureUtils.getLocaleObject(this.jsonModel._locale,"numberSymbols");
            this._mCurrencySymbols = xfalib.ut.PictureUtils.getLocaleObject(this.jsonModel._locale,"currencySymbols");
        },

        _checkAndAddDecimalPoint: function(fw) {
            if(this._mAddRadix) {
                this._buffer.push(this._fmtStr(this._mNumberSymbols.decimal, fw));
                this._mAddRadix = false;
            }
        },

        consumeSubPattern : function(token){
            var chr = token.patChar,
                chrCnt = token.len;
            switch (chr) {
                case '9':
                case '8':
                case 'Z': // Digit or space if zero.
                case 'z':// Digit or nothing if zero.
                    if(!this._mbSignAddedToOutput)
                        this._ensureSignIsAdded();
                    while (chrCnt-- > 0 ) {
                        if(!this._mbRadixSeen){
                            if(this._leadingPadding > this._nScannedPatternDigit++){
                                var placeHolder = null;
                                if(this._mbDigitAddedToOutput){
                                    placeHolder = this._mNumberSymbols.zero;
                                }else{
                                    if(chr == '9' || chr =='8') {
                                        placeHolder = this._mNumberSymbols.zero;
                                        this._mbDigitAddedToOutput = true;
                                    }else if(chr == 'Z'){
                                        placeHolder = " ";
                                    }
                                }
                                if(placeHolder){
                                    this._buffer.push(this._matchChr(placeHolder));
                                }
                            }else {
                                var cValue = this._msText.charAt(this._textPos++);
                                this._ensureCharIsDigit(cValue);
                                this._buffer.push(PictureUtils.convertNumberToLocale(this.jsonModel._locale,cValue));
                                this._mbDigitAddedToOutput = true;
                            }
                        }else{  //handling fractional part
                            if(this._nScannedPatternDigit++  < this._numberInfo.fractionDigit ){
                                var cValue = this._msText.charAt(this._textPos++);
                                this._ensureCharIsDigit(cValue);
                                this._checkAndAddDecimalPoint();
                                this._buffer.push(PictureUtils.convertNumberToLocale(this.jsonModel._locale,cValue));
                                this._mbDigitAddedToOutput = true;
                            }else{
                                if(chr == '9'|| chr =='Z') {
                                    this._checkAndAddDecimalPoint();
                                    this._buffer.push(this._matchChr(this._mNumberSymbols.zero));
                                } else if(chr == '8') {
                                    var cValue = this._msText.charAt(this._textPos++);
                                    if(cValue != '' && this._ensureCharIsDigit(cValue)) {
                                        this._checkAndAddDecimalPoint();
                                        this._buffer.push(PictureUtils.convertNumberToLocale(this.jsonModel._locale,cValue));
                                        this._mbDigitAddedToOutput = true;
                                    }
                                }
                            }
                        }

                    }

                    break;
                case 'E': // Exponent.
                    this._buffer.push('E');
                    this._buffer.push("" + this._numberInfo.shift);
                    break;
                case 'C': // CR symbol if negative and spaces if positive.
                    this._buffer.push((this._mbNegative) ? xfalib.ut.NumPictureDesc.gsCR : xfalib.ut.NumPictureDesc.gsDSP);
                    break;
                case 'c': // CR symbol if negative and nothing if positive.
                    if (this._mbNegative){
                        this._buffer.push(xfalib.ut.NumPictureDesc.gsCR);
                    }
                    break;
                case 'D': // DB symbol if negative and spaces if positive.
                    this._buffer.push((this._mbNegative) ? xfalib.ut.NumPictureDesc.gsDB : xfalib.ut.NumPictureDesc.gsDSP);
                    break;
                case 'd': // DB symbol if negative and nothing if positive.
                    if (this._mbNegative){
                        this._buffer.push(xfalib.ut.NumPictureDesc.gsDB);
                    }
                    break;
                case 'S': // Minus sign if negative and a space if positive.
                case 's':
                    if (this._mbNegative){
                        this._buffer.push(this._fmtStr(	this._mNumberSymbols.minus));
                    }else{
                        if('S' == chr){
                            this._buffer.push(this._matchChr(' '));
                        }
                    }
                    break;
                case 'V': // Implied decimal sign if parsing.
                case '.':
                case 'v': // Implied decimal sign.
                    if (this._textPos < this._msText.length && this._msText.charAt(this._textPos) == '.'){
                        this._textPos++; //consume a '.'
                    }
                    if (chr == 'V' || chr == '.'){
                        this._mAddRadix = true;
                        //this._buffer.push(this._fmtStr(this._mNumberSymbols.decimal, ));
                    }
                    this._mbRadixSeen = true;
                    this._nScannedPatternDigit = 0;
                    break;

                case 0xFF0C: // Fullwidth ','.
                case ',': // Grouping separator.
                    while (chrCnt-- > 0) {
                        if (this._mbDigitAddedToOutput){
                            this._buffer.push(this._fmtStr(	this._mNumberSymbols.grouping ));
                        }
                        this._mbCommaSeen = true;
                    }
                    break;
                case 0xFF04: // Fullwidth '$'.
                case '$': // Currency name or symbol.
                    while (chrCnt-- > 0) {
                        this._buffer.push(this._fmtStr(	this._mCurrencySymbols.symbol ));
                    }
                    break;
                case 0xFF05: // Fullwidth '%'.
                case '%': // Percent symbol.
                    while (chrCnt-- > 0) {
                        this._buffer.push(this._fmtStr(	this._mNumberSymbols.percent));
                    }
                    break;
                case 0xFF08: // Fullwidth '('.
                case 0xFF09: // Fullwidth ')'.
                case '(': // Left parenthesis.
                case ')': // Right parenthesis.
                    this._buffer.push(this._matchChr((this._mbNegative) ? chr : ' '));
                    break;
                default:
            }
        },

        _ensureCharIsDigit : function(cValue){
            if ('0' > cValue || cValue > '9'){
                throw "Nuberic Formatting: not a digit as expected " + cValue;
            }
        },


        _fmtStr : function(str){
            return str;
        },

        _matchStr : function(str){
            return str;
        },

        _matchChr : function(str){
            return str;
        },

        _ensureSignIsAdded : function(){
            if (this._mbNegative && ! this._mbDigitAddedToOutput && ! this._pictureDesc.hasSign) {
                this._buffer.push(this._mNumberSymbols.minus);
                this._mbSignAddedToOutput = true;
            }
        },

        /**
         *
         * @override
         */
        getResult : function(){
            return this._buffer.join("");
        },

        /**
         *
         * @override
         */
        acceptPatternChar : function(chr){
            return xfalib.ut.PictureUtils.inString(chr, "(%$,.)89BCDERSVZbcdrsvzt");
        }

    });

})(_,xfalib);


/**
 * @package xfalib.ut.TimeParsingVisitor
 * @import xfalib.ut.ParsingVisitorBase
 * @fileOverview The file provides parsing/formating logic on date pattern characters.
 * @version 0.0.1
 */

/**
 * @constructor
 * @param Object {jsonModel: {_sPicture: String, _dataString: String]}
 */

(function(_,xfalib){
    var TimeParsingVisitor = xfalib.ut.TimeParsingVisitor = xfalib.ut.ParsingVisitorBase.extend({

        initialize: function() {
            this._timeInfo = new xfalib.ut.TimeInfo();
            TimeParsingVisitor._super.initialize.call(this);
        },

        consumeSubPattern : function(token){
            var chr = token.patChar;
            var chrCnt = token.len;
            var curPos = this._strPos;
            var scannedChar = chrCnt;
            this._assert(curPos+chrCnt <=this.jsonModel._dataString.length, "Mismatch");

            switch (chr) {
                case 'h':
                    if(this._timeInfo.mHourOfMeriDiem != -1 || this._timeInfo.mHourOfDay != -1){
                        throw "ambiguity time string";
                    }
                    var hourOfMeriDiem=-1;
                    switch(chrCnt){
                        case 1:
                            var parsed = this.parseIntAggressive(this.jsonModel._dataString, curPos, 2); // 1-2 digit(1-12)
                            hourOfMeriDiem = parsed.value;
                            scannedChar = parsed.len;
                            break;
                        case 2:
                            hourOfMeriDiem = this.parseIntExact(this.jsonModel._dataString, curPos, 2); // 1-2 digit(1-12)
                            break;
                    }

                    this._timeInfo.mHourOfMeriDiem = hourOfMeriDiem -1;
                    this._assert(this._timeInfo.mHourOfMeriDiem>=0 && this._timeInfo.mHourOfMeriDiem<=11, "Invalid Hour Of MeriDiem value.");
                    break;

                case 'k':
                    if(this._timeInfo.mHourOfMeriDiem != -1 || this._timeInfo.mHourOfDay != -1){
                        throw "ambiguity time string";
                    }
                    var hourOfMeriDiem=-1;
                    switch(chrCnt){
                        case 1:
                            var parsed = this.parseIntAggressive(this.jsonModel._dataString, curPos, 2); // 1-2 digit(0-11)
                            hourOfMeriDiem = parsed.value;
                            scannedChar = parsed.len;
                            break;
                        case 2:
                            hourOfMeriDiem = this.parseIntExact(this.jsonModel._dataString, curPos, 2); // 1-2 digit(0-11)
                            break;
                    }

                    this._timeInfo.mHourOfMeriDiem = hourOfMeriDiem;
                    this._assert(this._timeInfo.mHourOfMeriDiem>=0 && this._timeInfo.mHourOfMeriDiem<=11, "Invalid hour of meriDiem value.");
                    break;

                case 'H':
                    if(this._timeInfo.mHourOfMeriDiem != -1 || this._timeInfo.mHourOfDay != -1){
                        throw "ambiguity time string";
                    }
                    var hourOfDay=-1;
                    switch(chrCnt){
                        case 1:
                            var parsed = this.parseIntAggressive(this.jsonModel._dataString, curPos, 2); // 1-2 digit(0-23)
                            hourOfDay = parsed.value;
                            scannedChar = parsed.len;
                            break;
                        case 2:
                            hourOfDay = this.parseIntExact(this.jsonModel._dataString, curPos, 2); // 1-2 digit(0-23)
                            break;
                    }

                    this._timeInfo.mHourOfDay = hourOfDay;
                    this._assert(this._timeInfo.mHourOfDay>=0 && this._timeInfo.mHourOfDay<=23, "Invalid hour of day value.");
                    break;

                case 'K':
                    if(this._timeInfo.mHourOfMeriDiem != -1 || this._timeInfo.mHourOfDay != -1){
                        throw "ambiguity time string";
                    }
                    var hourOfDay=-1;
                    switch(chrCnt){
                        case 1:
                            var parsed = this.parseIntAggressive(this.jsonModel._dataString, curPos, 2); // 1-2 digit(0-23)
                            hourOfDay = parsed.value;
                            scannedChar = parsed.len;
                            break;
                        case 2:
                            hourOfDay = this.parseIntExact(this.jsonModel._dataString, curPos, 2); // 1-2 digit(0-23)
                            break;
                    }

                    this._timeInfo.mHourOfDay = hourOfDay - 1;
                    this._assert(this._timeInfo.mHourOfDay>=0 && this._timeInfo.mHourOfDay<=23, "Invalid hour of day value.");
                    break;
                case 'M':
                    if(this._timeInfo.mMinuteOfHour != -1){
                        throw "ambiguity time string";
                    }
                    var minuteOfHour=-1;
                    switch(chrCnt){
                        case 1:
                            var parsed = this.parseIntAggressive(this.jsonModel._dataString, curPos, 2); // 1-2 digit(0-59)
                            minuteOfHour = parsed.value;
                            scannedChar = parsed.len;
                            break;
                        case 2:
                            minuteOfHour = this.parseIntExact(this.jsonModel._dataString, curPos, 2); // 1-2 digit(0-59)
                            break;
                    }

                    this._timeInfo.mMinuteOfHour = minuteOfHour;
                    this._assert(this._timeInfo.mMinuteOfHour>=0 && this._timeInfo.mMinuteOfHour<=59, "Invalid minute of hour.");
                    break;
                case 'S':
                    if(this._timeInfo.mSecondOfMinute != -1){
                        throw "ambiguity time string";
                    }
                    var secondOfMinute=-1;
                    switch(chrCnt){
                        case 1:
                            var parsed = this.parseIntAggressive(this.jsonModel._dataString, curPos, 2); // 1-2 digit(0-59)
                            secondOfMinute = parsed.value;
                            scannedChar = parsed.len;
                            break;
                        case 2:
                            secondOfMinute = this.parseIntExact(this.jsonModel._dataString, curPos, 2); // 1-2 digit(0-59)
                            break;
                    }

                    this._timeInfo.mSecondOfMinute = secondOfMinute;
                    this._assert(this._timeInfo.mSecondOfMinute>=0 && this._timeInfo.mSecondOfMinute<=59, "Invalid second of minute.");
                    break;
                case 'F':

                    this._assert(chrCnt==3, "Invalid pattern F.");
                    this._timeInfo.mThousandthOfSecond = this.parseIntExact(this.jsonModel._dataString, curPos, 3);
                    this._assert(this._timeInfo.mThousandthOfSecond>=0 && this._timeInfo.mThousandthOfSecond<=999, "Invalid thousand of second.");
                    break;

                default: throw "Unsupported pattern";
            }

            this._strPos += scannedChar;
        },

        parseIntAggressive : xfalib.ut.PictureUtils.parseIntAggressive,

        parseIntExact : xfalib.ut.PictureUtils.parseIntExact,

        getResult : function(){
            return this._timeInfo.getISOTime();
        },

        getTimeInfo : function(){
            return this._timeInfo;
        },

        _assert : function(condition, message){
            if(!condition){
                throw message;
            }
        }
    });
})(_,xfalib);



/**
 * @package xfalib.ut.TextParsingVisitor
 * @import xfalib.ut.ParsingVisitorBase
 *
 * @fileOverview Parses a string according to Text Picture.
 * @version 0.0.1
 */

/**
 * @constructor
 * @param Object {jsonModel: {_sPicture: String, _dataString: String]}
 */
(function(_,xfalib){
    var TextParsingVisitor = xfalib.ut.TextParsingVisitor = xfalib.ut.ParsingVisitorBase.extend({

        initialize: function() {
            TextParsingVisitor._super.initialize.call(this);
            this._buffer = [];
        },

        consumeSubPattern : function(token){
            var chr = token.patChar;
            var chrCnt = token.len;
            for(var index = 0; index < chrCnt; index++){
                switch (chr) {
                    case '9': // Numeric
                        var cUni = this.jsonModel._dataString.charAt(this._strPos++);
                        if(!xfalib.ut.PictureUtils.isDigit(cUni)){
                            throw "TextParsing: not a digit as expected";
                        }
                        this._buffer.push(cUni);
                        break;
                    case 'A': // Alphebetic
                        var cUni = this.jsonModel._dataString.charAt(this._strPos++);
                        if(!xfalib.ut.PictureUtils.isLetter(cUni)){
                            throw "TextParsing: not a character as expected";
                        }
                        this._buffer.push(cUni);
                        break;
                    case 'O': // Alphanumeric
                    case '0':
                        var cUni = this.jsonModel._dataString.charAt(this._strPos++);
                        if(!xfalib.ut.PictureUtils.isLetterOrDigit(cUni)){
                            throw "TextParsing: not a character or digit as expected";
                        }
                        this._buffer.push(cUni);
                        break;
                    case 'X':
                        var cUni = this.jsonModel._dataString.charAt(this._strPos++);
                        this._buffer.push(cUni);
                        break;
                    case 't':
                        if(this.jsonModel._dataString.charAt(this._strPos++)=="\t"){
                            this._buffer.push("\t");
                        }else{
                            throw "TextParsing: not a Tab as expected";
                        }
                        break;
                    default:
                        if(this.jsonModel._dataString.charAt(this._strPos++)== chr){
                            this._buffer.push(chr);
                        }else{
                            throw "TextParsing: not '" + chr+"' as expected";
                        }
                }
            }

        },
        /**
         *
         * @override
         */
        getResult : function(){
            if(this._strPos < this.jsonModel._dataString.length)
                throw "TextParsing: picture clause smaller than input Text";
            return this._buffer.join("");
        },
        /**
         *
         * @override
         */
        acceptPatternChar : function(chr){
            return xfalib.ut.PictureUtils.inString(chr, "9AO0Xt");
        }

    });
})(_,xfalib);


/**
 * @package xfalib.ut.NumParsingVisitor
 * @import xfalib.ut.ParsingVisitorBase
 * @fileOverview Parses a string according to Text Picture.
 * @version 0.0.1
 */

/**
 * @constructor
 * @param Object {jsonModel: {_sPicture: String,_dataString: String}}
 */

(function(_,xfalib){
    var NumParsingVisitor = xfalib.ut.NumParsingVisitor = xfalib.ut.ParsingVisitorBase.extend({

        initialize: function(options) {
            this._pictureDesc = new xfalib.ut.NumPictureDesc({jsonModel:{_sPicture:this.jsonModel._sPicture}});
            this.jsonModel._sPicture = this._pictureDesc.getPicture();
            this._buffer = [];
            this._strPos = 0;
            this._hasRadix = false;
            this._mbNegative = false;
            this._mbDigitSeen = false; // at least one digit has been added to output
            this._mbSignSeen = false;
            this._mBacktrack = null;
            this._hasPercent = false;
            this._mbExponSeen = false;

            this._mNumberSymbols = xfalib.ut.PictureUtils.getLocaleObject(this.options._locale,"numberSymbols");
            this._mCurrencySymbols = xfalib.ut.PictureUtils.getLocaleObject(this.options._locale,"currencySymbols");
        },

        _lookupNext : xfalib.ut.Scanner.lookupNext,

        parse : function(){
            var patPos = 0;
            while(true){
                try{
                    for(var token = this._lookupNext(this.jsonModel._sPicture, patPos, this.acceptPatternChar); token != null;  ){
                        this.consume(token);
                        patPos = patPos + token.len;
                        token = this._lookupNext(this.jsonModel._sPicture, patPos, this.acceptPatternChar);
                    }
                }catch(e){
                    //mismatch, try again!
                    if(this._mBacktrack){
                        patPos = this._mBacktrack.patPos;
                        this._buffer.length = 0;
                        this._strPos = this._mBacktrack.strPos;
                        this._mbDigitSeen = false;
                        this._mBacktrack = null;
                        continue;
                    }
                }
                break;
            }
        },
        consumeSubPattern : function(token){

            var chr = token.patChar;
            var chrCnt = token.len;
            var fw = false;
            switch (chr) {
                case '9':
                case '8':
                case 'Z': // Digit or space if zero.
                case 'z':// Digit or nothing if zero.
                    while (chrCnt-- > 0 ) {
                        if(!this._mbDigitSeen){
                            var cUni = this.jsonModel._dataString.charAt(this._strPos);
                            if(cUni == '-'){
                                this._mbNegative = true;
                                cUni = this.jsonModel._dataString.charAt(++this._strPos);
                            }
                            if(chr== '9' || chr == '8'){
                                if(!xfalib.ut.PictureUtils.isDigit(cUni)){
                                    throw "TextParsing: not a digit as expected";
                                }
                                this._buffer.push(cUni);
                                this._mbDigitSeen =true;
                            }else if(chr =='Z'){
                                if(xfalib.ut.PictureUtils.isDigit(cUni)){
                                    this._buffer.push(cUni);
                                    this._mbDigitSeen =true;
                                }else if(cUni != ' '){
                                    throw "TextParsing: not a digit or space as expected";
                                }
                            }else {
                                // has to be 'z', eagerly try to match a digit, if a mismatch is latterly found, backtrack
                                if(xfalib.ut.PictureUtils.isDigit(cUni)){
                                    this._buffer.push(cUni);
                                    this._mbDigitSeen =true;
                                    this._mBacktrack = {
                                        "patPos" : token.patPos + token.len - chrCnt, //new position from next char after 'z'
                                        "strPos" : this._strPos
                                    };
                                }else {
                                    throw "TextParsing: not a digit or space as expected";
                                }
                            }
                            ++this._strPos;
                        }else{
                            var cUni = this.jsonModel._dataString.charAt(this._strPos);
                            if(xfalib.ut.PictureUtils.isDigit(cUni)){
                                this._buffer.push(cUni);
                                ++this._strPos;
                            }else{
                                if(chr !='z'){
                                    throw "TextParsing: not a digit as expected";
                                }else{
                                    ++this._strPos;
                                }
                            }
                        }
                    }

                    break;
                case 'V' :
                case 'v' :
                case '.' :
                    if(this._matchStr(this._mNumberSymbols.decimal)){
                        this._hasRadix = true;
                        this._buffer.push('.');
                        this._mbDigitSeen =true;
                    }else{
                        throw "TextParsing: not a radix as expected";
                    }
                    break;
                case 'E': // Exponent.
                    if(this._matchStr('E')){
                        this._buffer.push('E');
                        if(this._matchStr('+')){
                            //
                        }else if(this._matchStr('-')){
                            this.jsonModel._buffer.push('-');
                        }
                        var strLen = this.jsonModel._dataString.length;
                        while(this._strPos < strLen &&
                            xfalib.ut.PictureUtils.isDigit(this.jsonModel._dataString.charAt(this._strPos))){
                            this._buffer.push(this.jsonModel._dataString.charAt(this._strPos++));
                        }
                    }
                    break;

                case 'C': // CR symbol if negative and spaces if positive.
                    if(this._matchStr(xfalib.ut.NumPictureDesc.gsCR)){
                        this._mbNegative = true;
                    }else if(!this._matchStr(xfalib.ut.NumPictureDesc.gsDSP)){
                        throw "TextParsing: not a CR as expected";
                    }
                    break;
                case 'c': // CR symbol if negative and nothing if positive.
                    if(this._matchStr(xfalib.ut.NumPictureDesc.gsCR)){
                        this._mbNegative = true;
                    }
                    break;
                case 'D': // DB symbol if negative and spaces if positive.
                    if(this._matchStr(xfalib.ut.NumPictureDesc.gsDB)){
                        this._mbNegative = true;
                    }else if(!this._matchStr(xfalib.ut.NumPictureDesc.gsDSP)){
                        throw "TextParsing: not a CR as expected";
                    }
                    break;
                case 'd': // DB symbol if negative and nothing if positive.
                    if(this._matchStr(xfalib.ut.NumPictureDesc.gsDB)){
                        this._mbNegative = true;
                    }
                    break;
                case 'S': // Minus sign if negative and a space if positive.
                    if(this._matchStr(this._mNumberSymbols.negative,fw)){
                        this._mbNegative = true;
                    }else if(!this._matchStr(" ")){
                        throw "TextParsing: not a CR as expected";
                    }
                    break;
                case 's':
                    if(this._matchStr(this._mNumberSymbols.negative,fw)){
                        this._mbNegative = true;
                    }
                    break;
                case 0xFF0C: // Fullwidth ','.
                case ',': // Grouping separator.
                    while (chrCnt-- > 0) {
                        if(!this._matchStr(this._mNumberSymbols.grouping, fw)){
                            throw "TextParsing: not a grouping symbol as expected";
                        }
                    }
                    break;
                case 0xFF04: // Fullwidth '$'.
                case '$': // Currency name or symbol.
                    while (chrCnt-- > 0) {
                        if(!this._matchStr(this._mCurrencySymbols.symbol, fw)){
                            throw "TextParsing: not a grouping symbol as expected";
                        }
                    }
                    break;
                case 0xFF05: // Fullwidth '%'.
                case '%': // Percent symbol.
                    while (chrCnt-- > 0) {
                        if(!this._matchStr(this._mNumberSymbols.percent, fw)){
                            throw "TextParsing: not a grouping symbol as expected";
                        }
                    }
                    this._hasPercent = true;
                    break;
                case 0xFF08: // Fullwidth '('.
                case 0xFF09: // Fullwidth ')'.
                case '(': // Left parenthesis.
                case ')': // Right parenthesis.
                    if(this._matchStr(chr,fw)){
                        this._mbNegative = true;
                    }else if(!this._matchStr(" ")){
                        throw "TextParsing: not parentesis as expected";
                    }
                    break;
                case 't': // tab.
                    while (chrCnt-- > 0) this._matchStr('\t',fw);
            }
        },
        getResult : function(){
            var stringNum =  this._buffer.join("");
            if(this._hasPercent) {
                var buf = new Array();
                stringNum = Number(stringNum).toString();
                var dot = stringNum.indexOf('.');

                var pos = dot-2;
                if(pos ==0) buf.push("0");
                else if(pos ==-1) buf.push("0.0");
                else if(pos ==-3) pos = stringNum.length - 2;
                for(var index=0;index < stringNum.length; index++){
                    if(index == pos){
                        buf.push(".");
                    }
                    if(index != dot){
                        buf.push(stringNum.charAt(index));
                    }
                }
                stringNum = buf.join("");
            }
            var number = Number(stringNum);
            if(this._mbNegative) number = -number;
            return number.toString();
        },

        _matchStr : function(target){
            if(xfalib.ut.PictureUtils.matchString(this.jsonModel._dataString, this._strPos, target)){
                this._strPos+= target.length;
                return true;
            }else{
                return false;
            }
        },

        /**
         *
         * @override
         */
        acceptPatternChar : function(chr){
            return xfalib.ut.PictureUtils.inString(chr, "(%$,.)89BCDERSVZbcdrsvzt");
        }
    });
})(_,xfalib);
/**
 * @package xfalib.ut.DateParsingVisitor
 * @import xfalib.ut.ParsingVisitorBase
 * @fileOverview The file provides parsing/formating logic on date pattern characters.
 * @version 0.0.1
 */

/**
 * @constructor
 * @param Object {jsonModel: {_sPicture: String, _dataString: String]}
 */

(function(_,xfalib) {
    var DateParsingVisitor = xfalib.ut.DateParsingVisitor = xfalib.ut.ParsingVisitorBase.extend({

        initialize: function() {
            this._dateInfo = new xfalib.ut.DateInfo({isParsingCall : true});
            this._dayOfMonth = this._monthOfYear = this._yearOfEra = null; // used to validate date once all sub patterns are consumed
            DateParsingVisitor._super.initialize.call(this);
        },

        consumeSubPattern : function(token){
            var chr = token.patChar;
            var chrCnt = token.len;
            var curPos = this._strPos;
            var scannedChar = chrCnt;

            //TODO: need to remove this assert.
            this._assert(curPos+chrCnt <=this.jsonModel._dataString.length, "Mismatch");

            switch (chr) {
                case 'D':
                    switch(chrCnt){
                        case 1:
                            var parsed = xfalib.ut.PictureUtils.parseIntAggressive(this.jsonModel._dataString, curPos, 2); // 1-2 digit(1-31)
                            this._dayOfMonth = parsed.value;
                            scannedChar = parsed.len;
                            break;
                        case 2:
                            this._dayOfMonth = xfalib.ut.PictureUtils.parseIntExact(this.jsonModel._dataString, curPos, 2); // 1-2 digit(1-31)
                            break;
                    }
                    this._assert(this._dayOfMonth <= 31 && this._dayOfMonth >0, "Invalid date string1");
                    break;
                case 'J':

                    //this._mDayOfYear;
                    break;
                case 'M':
                    var symbol = "";
                    switch(chrCnt){
                        case 1:
                            var parsed = xfalib.ut.PictureUtils.parseIntAggressive(this.jsonModel._dataString, curPos, 2); // 1-2 digit(1-12)
                            this._monthOfYear = parsed.value;
                            scannedChar = parsed.len;
                            break;
                        case 2:
                            this._monthOfYear = xfalib.ut.PictureUtils.parseIntExact(this.jsonModel._dataString, curPos, 2); // 2 digit(01-12)
                            break;
                        case 3:
                            symbol = "calendarSymbols.abbrmonthNames";
                            break;
                        case 4:
                            symbol = "calendarSymbols.monthNames"
                            break;

                    }
                    if(symbol) {
                        var hashObj = xfalib.ut.PictureUtils.getHashOfLocaleObject(this.jsonModel._locale,symbol),
                            str = this.jsonModel._dataString.toLowerCase(),
                            hash = 0,
                            curStr = ""
                        scannedChar = 0;
                        while(curPos+scannedChar < str.length) {
                            hash += (scannedChar+1)*str.charCodeAt(curPos+scannedChar)
                            curStr+= str.charAt(curPos+scannedChar);
                            scannedChar++;
                            if(hashObj[hash] && hashObj[hash].indexOf(curStr) > -1 ) break;
                        }
                        var monthNames = _.map(xfalib.ut.PictureUtils.getLocaleObject(this.jsonModel._locale, symbol), function (str) {
                            return str.toLowerCase();
                        });
                        this._monthOfYear = monthNames.indexOf(curStr) + 1; // months are from 1 to 12
                    }
                    //TODO: remove this assert
                    this._assert(this._monthOfYear <= 12 && this._monthOfYear >0, "Invalid date string2");
                    break;
                case 'E':
                    var symbol = ""
                    switch(chrCnt) {
                        case 1:
                            scannedChar = 1;
                            break;
                        case 3:
                            symbol = "calendarSymbols.abbrdayNames";
                            break;
                        case 4:
                            symbol = "calendarSymbols.dayNames"
                            break;
                        default:
                            throw "unsupported Picture Clause ";
                    }
                    if(symbol) {
                        var hashObj = xfalib.ut.PictureUtils.getHashOfLocaleObject(this.jsonModel._locale,symbol);
                        scannedChar = 0;
                        var str = this.jsonModel._dataString.toLowerCase();
                        var hash = 0;
                        var curStr = "";
                        while(curPos+scannedChar < str.length) {
                            hash += (scannedChar+1)*str.charCodeAt(curPos+scannedChar)
                            curStr+= str.charAt(curPos+scannedChar);
                            scannedChar++;
                            if(hashObj[hash] && hashObj[hash].indexOf(curStr) > -1) break;
                        }
                    }
                    break;

                case 'e':
                    break;
                case 'G':
                    break;
                case 'Y':

                    switch(chrCnt){
                        case 2:
                            this._yearOfEra = xfalib.ut.PictureUtils.parseIntExact(this.jsonModel._dataString, curPos, 2); // 2 digit(00-99)
                            this._yearOfEra+=2000;
                            if(this._yearOfEra >= 2029){
                                this._yearOfEra -=100;
                            }
                            break;
                        case 4:
                            this._yearOfEra = xfalib.ut.PictureUtils.parseIntExact(this.jsonModel._dataString, curPos, 4); // 2 digit(0000-9999)
                            break;
                    }

                    this._assert(this._yearOfEra <= 9999 && this._yearOfEra >=0, "Invalid date string3");
                    break;
                case 'w':
                    break;
                case 'W':
                    break;
                default: throw "Unsupported pattern";
            }

            if(this._yearOfEra && this._monthOfYear && this._dayOfMonth){
                this._dateInfo.validate(this._yearOfEra, this._monthOfYear, this._dayOfMonth);
            }

            this._strPos += scannedChar;
        },

        getDate : function(){
            return this._dateInfo.date;
        },

        getResult: function(){
            if (this._strPos < this.jsonModel._dataString.length) {
                throw "DateParsing: picture clause smaller than input Date";
            }
            return this._dateInfo.getISODate();
        },

        _assert : function(condition, message){
            if(!condition){
                throw message;
            }
        }
    });
})(_,xfalib);

/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/



(function(_, $, xfalib){

    var LocalizationUtil = xfalib.ut.LocalizationUtil = xfalib.ut.Class.extend({

        getLocalizedMessage: function(category, message, snippets){
            var resolvedMessage = message;
            if(snippets){
                //resolve message with snippet
                resolvedMessage = resolvedMessage.replace(/{(\d+)}/g, function(match, number) {
                    return typeof snippets[number] != 'undefined'
                        ? snippets[number]
                        : match
                        ;
                });
            }
            var text = "";
            if (category) {
                text += " [" + category + "]";
            }
            text += "  " + resolvedMessage + "\r\n" ;
            return text;
        }

    });
})(_, $, xfalib);


/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2013 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by all applicable intellectual property
 * laws, including trade secret and copyright laws.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/




(function(_, $, xfalib){
    xfalib.view.util.TextMetrics = {
        xfaUtil : xfalib.ut.XfaUtil.prototype,
        ERROR_MARGIN : 1,
        $measureEl : null,
        initialize : function(divEl){
            if(!divEl){
                var $div = $("<div></div>");
                $div.attr("id", "textMetrics");
                var divStyles = {};
                divStyles.left = -1000;
                divStyles.top = -1000;
                divStyles.position = "absolute";
                divStyles.visibility = "hidden";
                this.xfaUtil.$css($div.get(0), divStyles);
                this.$measureEl = $div;
                $("body").append(this.$measureEl);
            }else{
                this.$measureEl = divEl;
            }
        },

        measureExtent : function(text, options){
            text = text + " ";
            if(!this.$measureEl){
                this.initialize();
            }
            options = options || {};
            var textStyles = {};
            var $refEl =  $(options.refEl || "<div></div>") ;
            var refEl = $refEl.get(0);
            textStyles.fontSize = $refEl.css("fontSize") || options["font-size"] || options["fontSize"];
            textStyles.fontStyle = $refEl.css("fontStyle") || options["font-style"] || options["fontStyle"];
            textStyles.fontWeight = $refEl.css("fontWeight") || options["font-weight"] || options["fontWeight"];
            textStyles.fontFamily = $refEl.css("fontFamily") || options["font-family"] || options["fontFamily"];
            textStyles.lineHeight = refEl.style.lineHeight || options["line-height"] || options["lineHeight"];
            textStyles.letterSpacing = $refEl.css("letterSpacing") || options["letter-spacing"] || options["letterSpacing"];
            textStyles.whiteSpace =  $refEl.css("whiteSpace") || options["white-space"] || options["whiteSpace"] || "pre-wrap";
            if( $.browser.mozilla && $refEl.is("textarea"))      // for Bug #3621180
                textStyles.whiteSpace = "pre-wrap";
            textStyles.wordBreak =  $refEl.css("wordBreak") || options["word-break"] || options["wordBreak"] || "break-all";
            textStyles.wordWrap =  $refEl.css("wordWrap") || options["word-wrap"] || options["wordWrap"] || "break-word";
            textStyles.width = this._elWidth(refEl, options);
            textStyles.height = this._elHeight(refEl, options);
            textStyles.minWidth = this._elMinWidth(refEl, options);
            textStyles.minHeight = this._elMinHeight(refEl, options);
            textStyles.maxWidth = this._elMaxWidth(refEl, options);
            textStyles.maxHeight = this._elMaxHeight(refEl, options);
            this.xfaUtil.$css(this.$measureEl.get(0), textStyles);
            // for text fields/areas and draw requiring rich text support
            if(options.contentType === "text/html"){
              // retaining for future use . If we use the above property for other rich text
               if(options.skipXSSProtection) {
                 this.$measureEl.html(text);
               } else {
                 this.$measureEl.html(xfalib.ut.XfaUtil.prototype.encodeScriptableTags(text));
               }
            }else {
               this.$measureEl.text(text);
            }
            var measuredWidth =  this.$measureEl.width();
            var measuredHeight =  this.$measureEl.height();

            if(measuredWidth == Math.ceil(options["width"]) || measuredWidth == Math.floor(options["width"])){
                measuredWidth = options["width"];
            }
            else if(options["maxWidth"] > measuredWidth || (measuredWidth > options["minWidth"] > 0 && (options["maxWidth"] || -1) < 0)){
                //complicated, please simplify if below hurts you:  Add error margin if there is scope of further extension of extent
                measuredWidth = measuredWidth +1;
            }

            if(measuredHeight == Math.ceil(options["height"]) || measuredHeight == Math.floor(options["height"])){
                measuredHeight = options["height"];
            }
            else if( $refEl.is("textarea") && (options["maxHeight"] > measuredHeight || (measuredHeight > options["minHeight"] > 0 && (options["maxHeight"] || -1) < 0))){
                measuredHeight = measuredHeight +1;
            }
            this.$measureEl.empty();
            return {width : measuredWidth, height : measuredHeight};
        },

        _elWidth : function(refEl, options){
            if(options["minWidth"] && options["minWidth"] > -1)
                return "auto";
            else if(options["maxWidth"] && options["maxWidth"] > -1)
                return "auto";
            else
                return options["width"] || "auto";
        },

        _elHeight : function(refEl, options){
            // TODO: check for calculations here for floating field and other cases.
            if(options["contentType"] === "text/html")
                return "auto";
            if(options.isDraw) { // for handling the case of draw having floating fields
                return "auto";
            }
            if(!$(refEl).is("textarea"))
                return options["height"] || "auto";
            if(options["minHeight"] && options["minHeight"] > -1)
                return "auto";
            else if(options["maxHeight"] && options["maxHeight"] > -1)
                return "auto";
            else
                return options["height"] || "auto";
        },

        _elMinWidth : function(refEl, options){
            if(options["minWidth"] && options["minWidth"] > -1)
                return options["minWidth"];
            else
                return "0"; //default css value
        },

        _elMinHeight : function(refEl, options){
            if(options["minHeight"] && options["minHeight"] > -1)
                return options["minHeight"];
            else
                return "0"; //default css value
        },

        _elMaxWidth : function(refEl, options){
            if(options["maxWidth"] && options["maxWidth"] > -1)
                return options["maxWidth"];
            else
                return "none"; //default css value
        },

        _elMaxHeight : function(refEl, options){
            if(options["maxHeight"] && options["maxHeight"] > -1)
                return options["maxHeight"];
            else
                return "none"; //default css value
        },

        _destroy : function() {
            $("#textMetrics").remove();
            this.$measureEl = null;
        }
    }
})(_, $, xfalib);
(function($) {

	$.alertBox = {

		verticalOffset: -75,
		horizontalOffset: 0,
		repositionOnResize: true,
		overlayOpacity: 0.01,
		overlayColor: '#FFF',
		draggable: false,
		dialogClass: null,
		imageDirectory: "..",
		images: ["A_Warning_Lg_N.png", "A_Alert2_Lg_N.png", "C_QuestionBubble_Xl_N.png", "A_InfoBlue_32x32_N.png"],

		alert: function(img, message, title, callback) {
			this._show(img, title, message, null, 'OK', function(result) {
				if( callback ) callback(result);
			});
		},

		okCancel: function(img, message, title, callback) {
			this._show(img, title, message, null, 'OK-Cancel', function(result) {
				if( callback ) callback(result);
			});
		},
		yesNo: function(img, message, title, callback) {
			this._show(img, title, message, null, 'Yes-No', function(result) {
				if( callback ) callback(result);
			});
		},

		yesNoCancel: function(img, message, title, callback) {
			this._show(img, title, message, null, 'Yes-No-Cancel', function(result) {
				if( callback ) callback(result);
			});
		},

		_createBox: function(msgBox_message,buttons,callback) {
			var that = this;
			$("#"+msgBox_message).after("<div id='msgBox_panel'>");
			_.each(buttons.split("-"),function(val,i) {
                var dispval = xfalib.locale.Strings[val.toLowerCase()] ? xfalib.locale.Strings[val.toLowerCase()] : val;  // keys in loaclization files are in lower-case
                $("#msgBox_panel").append("<input type='button' value='"+dispval+"' id = 'msgBox_"+val+"' class=msgbox_input />");
				$("#msgBox_"+val).click( function() {
					that._hide();
					callback(!i);
				});
				if(!i) $("msgBox_"+val).focus();
			});
		},

		_show: function(img, title, msg, value, type, callback) {

			this._hide();
			this._overlay('show');

			$("BODY").append(
			  '<div id="msgBox_container">' +
			    '<h1 id="msgBox_title"></h1>' +
			    '<div id="msgBox_content">' +
			      '<div id="msgBox_message"></div>' +
				'</div>' +
			  '</div>');

			if( this.dialogClass ) $("#msgBox_container").addClass($.alertBox.dialogClass);

			$("#msgBox_container").css({
				position: 'absolute',
				zIndex: 99999,
				padding: 0,
				margin: 0
			});

			$("#msgBox_title").text(title);
			$("#msgBox_content").addClass("msgBoxType"+img);//css("background-image","url("+this.imageDirectory+ this.images[img]+")");
			msg = xfalib.ut.XfaUtil.prototype.encodeScriptableTags(msg.replace(/\n/g, '<br />'));
            $("#msgBox_message").html(msg);

			$("#msgBox_container").css({
				minWidth: $("#msgBox_container").outerWidth(),
				maxWidth: $("#msgBox_container").outerWidth()
			});

			this._reposition();
			this._maintainPosition(true);

			this._createBox("msgBox_message",type,callback);

			//TODO: Make keyboard input work
			/*$("#msgBox_ok").keypress( function(e) {
				if( e.keyCode == 13 || e.keyCode == 27 ) $("#msgBox_ok").trigger('click');
			});
			$("#msgBox_cancel").keypress( function(e) {
				if( e.keyCode == 13 ) $("#msgBox_ok").trigger('click');
				if( e.keyCode == 27 ) $("#msgBox_cancel").trigger('click');
			});
			$("#msgBox_yes, #msgBox_no").keypress( function(e) {
				if( e.keyCode == 13 ) $("#msgBox_yes").trigger('click');
					if( e.keyCode == 27 ) $("#msgBox_no").trigger('click');
				});*/

		},

		_hide: function() {
			$("#msgBox_container").remove();
			this._overlay('hide');
			this._maintainPosition(false);
		},

		_overlay: function(status) {
			switch( status ) {
				case 'show':
					this._overlay('hide');
					$("BODY").append('<div id="msgBox_overlay"></div>');
					$("#msgBox_overlay").css({
						position: 'absolute',
						zIndex: 99998,
						top: '0px',
						left: '0px',
						width: '100%',
						height: $(document).height(),
						background: this.overlayColor,
						opacity: this.overlayOpacity
					});
				break;
				case 'hide':
					$("#msgBox_overlay").remove();
				break;
			}
		},

		_reposition: function() {
            var windowHeight = $(window).height() / xfalib.ut.XfaUtil.prototype.formScaleFactor,
                windowWidth = $(window).width() / xfalib.ut.XfaUtil.prototype.formScaleFactor,
                windowScrollTop =  $(window).scrollTop() / xfalib.ut.XfaUtil.prototype.formScaleFactor,
                windowScrollLeft =  $(window).scrollLeft() / xfalib.ut.XfaUtil.prototype.formScaleFactor,
			    top = ((windowHeight / 2) - ($("#msgBox_container").outerHeight() / 2)) + this.verticalOffset,
			    left = ((windowWidth / 2) - ($("#msgBox_container").outerWidth() / 2)) + this.horizontalOffset;
			if( top < 0 ) top = 0;
			if( left < 0 ) left = 0;

			// IE6 fix
			if( $.browser.msie && parseInt($.browser.version) <= 6 ) top = top + windowScrollTop;

			$("#msgBox_container").css({
				top: top + windowScrollTop + 'px',
				left:  left + windowScrollLeft + 'px'
			});
			$("#msgBox_overlay").height( $(document).height() );
		},

		_maintainPosition: function(status) {
			if( this.repositionOnResize ) {
				switch(status) {
					case true:
						$(window).on('resize', this._reposition);
					break;
					case false:
						$(window).off('resize', this._reposition);
					break;
				}
			}
		}

	};
})($);/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2016 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by all applicable intellectual property
 * laws, including trade secret and copyright laws.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/


(function(_, $, xfalib){
    xfalib.view.util.HtmlUtil = {
        /*
        * Most of the time it returns undefined while accessing an undefined attribute of a dom element.
        * But some browsers can throw specific exceptions while accessing an attribute which is un-supported for a specific case.
        * This API is to make this behaviour consistent across browsers and return undefined for un-supported attributes.
        * */
        getHTMLSupportedAttr : function($domElement, attr){
           try{
               return $domElement[attr];
            }
           catch (err){
               return undefined;
            }
        },

        /**
         * Checks if the attribute is supported for the given HTML element.
         * This is primarily useful to support HTML5 features in widgets
         * @param element       name of HTML element
         * @param attribute     attribute to check on the element
         * @returns {boolean}
         */
        elementSupportsAttribute : function (element, attribute) {
            var test = document.createElement(element);
            if (attribute in test) {
                $(test).remove();
                test = null;
                return true;
            } else {
                $(test).remove();
                test = null;
                return false;
            }
        }
    }
})(_, $, xfalib);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2013 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/



(function(_, $, xfalib){
    xfalib.view.util.Styles = {
        xfaUtil : xfalib.ut.XfaUtil.prototype,
        _deviceResolution :  144.0, //DPI
        _in2mmFactor : 25.4,
        _pdfResolution : 72.0 ,
        getStyleForEdge : function (edgeElement, str, cssStyleObj){
            var style = { "raised" : "outset" ,
                "dashDot" : "dashed" ,
                "dashDotDot" : "dashed" ,
                "dashed" : "dashed" ,
                "dotted" : "dotted" ,
                "embossed" : "groove" ,
                "etched" : "inset" ,
                "lowered" : "ridge",
                "solid" : "solid"};
            if(edgeElement && edgeElement.jsonModel.presence != "hidden" && edgeElement.jsonModel.presence !="invisible") {
                cssStyleObj['border'+str+'width'] = this._subPixelValue(this._convertToPx(edgeElement.getAttribute('thickness'))) || "1px";
                if(edgeElement.getElement("color") && edgeElement.getElement("color").getAttribute("value") !="")  {
                    var color =   edgeElement.getElement("color").getAttribute("value");
                    color = "rgb(" + color + ")";
                    cssStyleObj['border'+str+'color']   = color  ;
                }
                else {
                    cssStyleObj['border'+str+'color'] = "rgb(0,0,0)"  ;
                }
                cssStyleObj['border'+str+'style']   = style[edgeElement.getAttribute('stroke')] || "solid" ;
            } else {
                cssStyleObj['border'+str+'width'] =  "0px";
                return 1;
            }

        },

        getStyleForBorder : function (border) {
            if(border) {
                var edge  =  border.getElement('edge', 0, true),
                    edge1 = border.getElement('edge', 1, true),
                    edge2 = border.getElement('edge', 2, true),
                    edge3 = border.getElement('edge', 3, true);
                if(edge || edge1 || edge2 || edge3) {
                    var cssStyleObj = {} ;
                    var e0 = this.getStyleForEdge(edge, "-top-",cssStyleObj);
                    var e1 = this.getStyleForEdge(edge1 || edge,"-right-",cssStyleObj);
                    var e2 = this.getStyleForEdge(edge2|| edge,"-bottom-",cssStyleObj);
                    var e3 = this.getStyleForEdge(edge3 || edge,"-left-",cssStyleObj);
                    if(e0 !=1|| e1 !=1|| e2 !=1|| e3!=1)
                        return cssStyleObj ;
                }
            }
                return null;
        },

        _convertToPx : function(size){
            if(!size)
                return 0;
            size = "" + size;
            var pxSize = size;
            if(size.indexOf("in") >=0){
                pxSize = this._mm2px(parseFloat(size) * this._in2mmFactor);
            }
            else if(size.indexOf("mm") >=0){
                pxSize = this._mm2px(size);
            }
            else if(size.indexOf("cm") >=0){
                pxSize = this._mm2px(parseFloat(size) * 10);
            }
            else if(size.indexOf("pt") >=0){
                pxSize = parseFloat(size) * (this._deviceResolution/this._pdfResolution);
            }
            else if(size.indexOf("px") >=0){
                pxSize = parseFloat(size);
            }
            return pxSize;
        },

        _mm2px : function(mmSize){
            var mmSizeNum = 0;
            if(_.isNumber(mmSize))
                mmSizeNum = mmSize;
            else{
                mmSizeNum = parseFloat(mmSize)
            }
            var mm2in = 1/25.4 ;
            var pxSize = mmSizeNum*mm2in*this._deviceResolution;
            return pxSize;
        },

        _subPixelValue : function(value){
            if(value > 0.01)
                return Math.max(value, 1.0);
            else
                return value;
        }
    }
})(_, $, xfalib);
/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2017 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by all applicable intellectual property
 * laws, including trade secret and copyright laws.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/




(function(_, $, xfalib){
    xfalib.view.util.traversalManager = {

        // compute tabIndex for the provided page
        _computTabIndex : function (pageView) {
            var pageNum = pageView._pageNumber(),
                tabIndex = this._tabIndexBasedOnRange(pageNum);
            this.geographicalOrder = [];
            this._createGeographicalOrder(pageView);
            this._createFinalTraversalOrder(tabIndex); // assign tab index using traversal element and geographicalOrder
            // keep tracks of the last field on the page to get tab index so that handler to render next page can be added on getting focus through tabbing
            this._lastFieldTabbed = null;
        },

        _tabIndexBasedOnRange : function (pageNum) {
            var behaviorConfig = new xfalib.ut.Version(formBridge.userConfig["behaviorConfig"]),
                tabIndexConfig = (behaviorConfig.isOn('mfRangeTabIndex')|| behaviorConfig.isOn('rangeTabIndex')),
                /*assuming single page can not have more than 1000 fields.[index -> 0 to 999]
                  this is also configurable by passing the maximum number of fields allowable in the page
                  in the config parameter */
                maxFieldInPageForTabIndex = tabIndexConfig? parseInt(tabIndexConfig):1000;

            return pageNum * maxFieldInPageForTabIndex;
        },

        // to create geographical order array which will be containing all the views in the geographical order
        _createGeographicalOrder : function (currentView) {
            var sortedChildViewWrapper = this._sortViewGeographically(currentView.childViews);
            _.each(sortedChildViewWrapper, function (wrapper) {
                var currentView = wrapper.view,
                    instanceCheckMap = this._getMapOfInstanceCheck(currentView),
                    isViewEligibleForTabbing = this._isViewEligibleForTabbing(currentView);
                //  If the child view is fieldView, drawView, exclGroupView or subformView then we will push these views in this.geographicalOrder array,
                //  as we need their traverse object during final traversing
                if (((instanceCheckMap.isField && !instanceCheckMap.isChildOfExclGroup) || instanceCheckMap.isSubform || instanceCheckMap.isDraw
                    || instanceCheckMap.isExclGroup) && isViewEligibleForTabbing) {
                    this.geographicalOrder.push({
                        view : currentView,
                        visited : false
                    });
                }
                if (instanceCheckMap.isContainer && isViewEligibleForTabbing) {
                    this._createGeographicalOrder(currentView);
                }
            }, this);
        },

        // to sort provided views in geographical order
        _sortViewGeographically : function (views) {
            var viewsWrapper = [];   // wrapper of view and their geographical reference
            _.each(views, function(view) {
                var position = view.$el.offset(),
                    paddedX = xfalib.ut.XfaUtil.prototype.padString(parseInt(position.left), 5, '0'),
                    marginTop = view._marginTop(),
                    paddedY = position.top - parseFloat(marginTop),
                    positionalReference = parseInt("" + parseInt(paddedY) + paddedX);
                viewsWrapper.push({
                    positionalReference: positionalReference,
                    view: view
                });
            });
            return _.sortBy(viewsWrapper, function(viewWrapper){ return viewWrapper.positionalReference; });
        },

        // Walk through views in geographical order and assign tab index honouring traversal object if present
        _createFinalTraversalOrder : function (tabIndex) {
            var geographicalOrderLength = this.geographicalOrder.length,
                currentWrappedObj = null,
                index = -1,
                traversalIndex = 0,  // index of the element to be traversed
                viewTraversed = 0;  // counter of view traversed

            while (1) {
                if (traversalIndex >= geographicalOrderLength) {
                    traversalIndex = 0;
                }
                currentWrappedObj = this.geographicalOrder[traversalIndex];

                if (!currentWrappedObj || currentWrappedObj.visited) {  // if the wrapped object does not exist or it has been visited move to the next one
                    traversalIndex++;
                } else {
                    currentWrappedObj.visited = true;
                    viewTraversed++;
                    var currentView = currentWrappedObj.view,
                        instanceCheckMap = this._getMapOfInstanceCheck(currentView),
                        currentModel = currentView.model,
                        nextView = null,
                        nextViewSom = null;

                    // get the first traversal of the subform if traversal object is present, else move to the next geographical element
                    // next of the subform will be taken care when we will be finding the next view to be traversed,
                    // as we will be checking if the ancestor contain next before moving to geographically next view
                    if (instanceCheckMap.isSubform) {
                        if (currentModel && currentModel.getTraversalObject()) {
                            // get the first element to be traversed and update traversalIndex
                            nextViewSom = currentModel.getNextTraversalSom(xfalib.template.Constants.firstTraversal);
                            index = this._findViewInGeographicalOrderArray(nextViewSom);
                            traversalIndex = index != -1 ? index : traversalIndex + 1;
                        } else {
                            traversalIndex++;
                        }
                    // get the next traversal for the field/draw if traversal object is present, else move to the next geographical element
                    // update the tabindex for the field
                    } else if (instanceCheckMap.isField || instanceCheckMap.isDraw) {
                        if (instanceCheckMap.isField) {
                            currentView.updateTabIndex(tabIndex);
                            this._lastFieldTabbed = currentView;
                            tabIndex++;
                        }
                        if (currentModel && currentModel.getTraversalObject()) {
                            //get next element to be traversed and update traversalIndex
                            nextViewSom = currentModel.getNextTraversalSom(xfalib.template.Constants.nextTraversal);
                            index = this._findViewInGeographicalOrderArray(nextViewSom);
                            traversalIndex = index != -1 ? index : traversalIndex + 1;
                        } else {
                            traversalIndex = this._findNextViewToBeTraversed(traversalIndex);
                        }
                    // if traversal object present get the next element to be traversed, if first is also present then update tab index of the first element
                    // else look for the traversal element in the children
                    } else if (instanceCheckMap.isExclGroup) {
                        if (currentModel && currentModel.getTraversalObject()) {
                            // get next element to be traversed and update traversalIndex
                            nextViewSom = currentModel.getNextTraversalSom(xfalib.template.Constants.nextTraversal);
                            index = this._findViewInGeographicalOrderArray(nextViewSom);
                            traversalIndex = index != -1 ? index : traversalIndex + 1;
                            // if first is also present assign tab index to that referred child else assign same tab index to all child
                            nextViewSom = currentModel.getNextTraversalSom(xfalib.template.Constants.firstTraversal);
                            tabIndex = this._updateTabIndexOfExclGroupChildren(currentView, tabIndex, nextViewSom);
                        } else {
                            tabIndex = this._updateTabIndexOfExclGroupChildren(currentView, tabIndex);
                            traversalIndex = this._findTraversalInExclGroupChildren(currentView, traversalIndex);
                        }
                    } else {
                        traversalIndex++;
                    }
                }

                // if all the view are traversed, we have assigned tab index to all the views
                if (viewTraversed >= geographicalOrderLength) {
                    this._renderNextPageFuture();
                    break;
                }
            }
        },

        // Check if the nextView is a sibling of the currentView (shares the same parent)
        // if it is not a sibling, check if the parent has a NEXT traversal.
        // if so get the node traversed to else recurse to see if nextView is a sibling of our parent
        // return -1 if the provided next node is sibling of current node or if no ancestor contain next traversal
        // else return index of the next traversal object of parent
        _getParentNextTraversal : function (currentView, nextView, traversalIndex) {
            var parentView = currentView.parentView,
                parentModel = parentView.model,
                nextViewParentModel = nextView.parentView.model,
                traversalObj = null,
                nextIndex = -1;

            if (parentModel && nextViewParentModel && parentModel.somExpression != nextViewParentModel.somExpression) {
                if(parentView && parentView instanceof xfalib.view.SubformView) {
                    if (parentModel.getTraversalObject()) {
                        var nextViewSom = parentModel.getNextTraversalSom(xfalib.template.Constants.nextTraversal);
                        nextIndex = this._findViewInGeographicalOrderArray(nextViewSom);
                        if (nextIndex != -1 && !this.geographicalOrder[nextIndex].visited) {
                            return nextIndex;
                        } else {
                            return traversalIndex++;
                        }
                    } else {
                        this._getParentNextTraversal(parentView, nextView, traversalIndex);
                    }
                } else {  // parentView is not a subform so skip up a level and re-check sibling
                    this._getParentNextTraversal(parentView, nextView, traversalIndex);
                }
            } else {
                return -1;  //provided currentView and nextView are sibling
            }
            return traversalIndex++;
        },

        // return the index of the view having provided somExpression in the geographicalOrder array
        _findViewInGeographicalOrderArray : function (somExpression) {
            return _.findIndex(this.geographicalOrder, function (viewWrapper) {
                var currentViewModel = viewWrapper.view.model;
                return (currentViewModel && currentViewModel.somExpression == somExpression);
            });
        },

        // find the next element to be traversed based on the provided traversalIndex
        _findNextViewToBeTraversed : function (traversalIndex) {
            var currentView = this.geographicalOrder[traversalIndex].view,
                index = this._getNextUnvisited(traversalIndex),   //get next unvisited based on geographical location
                nextView = null,
                nextIndex = -1;

            if (index != -1) {
                nextView = this.geographicalOrder[index].view;
                //check if both are sibling and if not find the next of the parent and update traversalIndex
                nextIndex = this._getParentNextTraversal(currentView, nextView, traversalIndex);
                return nextIndex != -1 ? nextIndex : index;
            }
            return traversalIndex++;
        },

        // return the next unvisited node based on geographical location
        // starting from the traversalIndex and wraps around to check all the views
        _getNextUnvisited : function (traversalIndex) {
            var geographicalOrderLength = this.geographicalOrder.length,
                index = 0,
                actualIndex = 0;
            while(index < geographicalOrderLength) {
                actualIndex = (index + traversalIndex) % geographicalOrderLength;
                if(!this.geographicalOrder[actualIndex].visited) {
                    return actualIndex;
                }
                index++;
            }
            return -1;
        },

        // assign same tab index to all the child of exclude group
        // if exclude group contain first traverse object, then the child being referred as first should have less tabindex
        // compared to other child
        _updateTabIndexOfExclGroupChildren : function (exclGroupView, tabIndex, firstChildSom) {
            _.each(exclGroupView.childViews, function(child){
                if (this._isViewEligibleForTabbing(child)) {
                    if(firstChildSom && child.model.somExpression == firstChildSom) {
                        tabIndex++;
                        child.updateTabIndex(tabIndex-1);
                        this._lastFieldTabbed = child;
                    } else {
                        child.updateTabIndex(tabIndex);
                    }
                }
            }, this);
            if (!firstChildSom) {
                this._lastFieldTabbed = exclGroupView.childViews[0];
            }
            return ++tabIndex;
        },

        // find if any child contains next pointer and update traversal index
        // start with the last in the geographical order of the children and find child which have next traversal
        _findTraversalInExclGroupChildren : function (exclGroupView, traversalIndex) {
            var sortedChildView = this._sortViewGeographically(exclGroupView.childViews),
                tempObj = null,
                childView = null,
                childModel = null,
                traversalObj = null,
                nextViewSom = null,
                index = -1;

            sortedChildView.reverse();
            tempObj = _.find(sortedChildView, function(child) {
                childView = child.view;
                childModel = childView.model;
                if(childModel && (traversalObj = childModel.getTraversalObject())) {
                    return traversalObj.length > 0;
                }
            });

            if (tempObj) {
                nextViewSom = tempObj.model.getNextTraversalSom(xfalib.template.Constants.nextTraversal);
                index = this._findViewInGeographicalOrderArray(nextViewSom);
                traversalIndex = index != -1 ? index : traversalIndex + 1;
            } else { // else get next unvisited based on geographical location
                traversalIndex = this._findNextViewToBeTraversed(traversalIndex);
            }
            return traversalIndex;
        },

        // check if the view is initialized and visible
        _isViewEligibleForTabbing : function (view) {
            if (view._initialized && view.$el.css("visibility") != "hidden") {
                return true;
            }
            return false;
        },

        // return map of whethter provided view is instance of the various views
        _getMapOfInstanceCheck : function (view) {
            var instanceCheckMap = {};
            instanceCheckMap.isSubform = view instanceof xfalib.view.SubformView;
            instanceCheckMap.isField = view instanceof xfalib.view.FieldView;
            instanceCheckMap.isDraw = view instanceof xfalib.view.XfaDrawView;
            instanceCheckMap.isExclGroup = view instanceof xfalib.view.ExclGroupView;
            instanceCheckMap.isChildOfExclGroup = view.parentView instanceof xfalib.view.ExclGroupView;
            instanceCheckMap.isContainer = view instanceof xfalib.view.ContainerView;

            return instanceCheckMap;
        },

        // add event handler for rendering next page on tabbing on last field of the page
        _renderNextPageFuture : function () {
            if (this._lastFieldTabbed) {
                this._lastFieldTabbed.$el.one('focusin.traversalManager', function() {
                    var pagingManager = window.formBridge ? window.formBridge.pagingManager() : null;
                    $(window).on( "keyup.traversalManager", function (e) {
                        var code = (e.keyCode ? e.keyCode : e.which);
                        if (code == 9 && pagingManager && pagingManager.hasMorePages()) {
                            pagingManager.renderNextPage();
                            $(window).off("keyup.traversalManager");
                        }
                    });
                });
            }
        },
        _destroy : function() {
            this.geographicalOrder = null;
        }
    }
})(_, $, xfalib);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2013 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/



(function(_, $, xfalib){

    var ErrorManager = xfalib.view.util.ErrorManager = xfalib.ut.Class.extend({

        options: {
            warningMessageVisible:false,
            errorMessageVisible: false
        },

        initialize: function () {
            $(window).on("destroy.xfa", function () {
                $("#error-msg").hide();
                $("#warning-msg").hide();
            });
        },

        onFieldEnter: function (jqWidget) {
            var element = jqWidget.element;
            if (jqWidget.option("errorMessage")|| jqWidget.option("warningMessage")) {
                var pos = $(element).offset(),
                    styles = {};
                styles.left = (pos.left * (1 / xfalib.ut.XfaUtil.prototype.formScaleFactor) + element.width() + 5) + "px";
                styles.top = pos.top * (1 / xfalib.ut.XfaUtil.prototype.formScaleFactor) + "px";
                if (jqWidget.option("errorMessage")) {
                    jqWidget.$css($("#error-msg").get(0), styles);
                    $("#error-msg").text(jqWidget.option("errorMessage")).show();
                    jqWidget.option("errorMessageVisible",true);
                }
                else if (jqWidget.option("warningMessage")) {
                    jqWidget.$css($("#warning-msg").get(0), styles);
                    $("#warning-msg").text(jqWidget.option("warningMessage")).show();
                    jqWidget.option("warningMessageVisible",true);
                }
            }
        },

        onFieldExit: function (jqWidget) {
            if (jqWidget.option("errorMessageVisible")) {
                $("#error-msg").hide();
                jqWidget.option("errorMessageVisible",false);
            } else if (jqWidget.option("warningMessageVisible")) {
                $("#warning-msg").hide();
                jqWidget.option("warningMessageVisible",false);
            }
        },

        markError: function (jqWidget, msg, type) {
            // assigning role="alert" so that JAWS reads-out the validation message
            if (type != "warning") {
                if ($("#error-msg").length < 1)
                    $("<div id='error-msg' role='alert'></div>").appendTo('body');
                jqWidget.option("errorMessage",msg);
                jqWidget.element.addClass("dataInvalid");
            } else {
                if ($("#warning-msg").length < 1)
                    $("<div id='warning-msg' role='alert'></div>").appendTo('body');
                jqWidget.option("warningMessage",msg);
            }

        },

        clearError: function (jqWidget) {
            this.onFieldExit(jqWidget);
            jqWidget.element.removeClass("dataInvalid");
            jqWidget.option("errorMessage",null);
            jqWidget.option("warningMessage",null);
        }
    });
})(_, $, xfalib);
(function(_,$, xfalib) {
    var xfaUtil = xfalib.ut.XfaUtil.prototype,
        BUFFER_SPC = 20;

    /* template for the clear Button */
    var clearButtonTemplate = '<div class="dp-clear">' +
        '<a></a>' +
        '</div>';

    /* template for the calendar
    * header contains the navigation icons (left and right arrows)
    * and the current caption (which can be date, year or month)
    *
    * monthview displays the grid for showing the dates for a particular
    * month
    *
    * yearview displays all the months of that year
    *
    * yearsetview displays a grid of 16 years. This can be configured
    * through the option: yearsPerView
    *
    */
    var calendarTemplate = '<div class="dp-header">' +
        '<div class="dp-leftnav"></div>' +
        '<div class="dp-caption"></div>' +
        '<div class="dp-rightnav"></div>' +
        '</div>' +
        '<div class="view dp-monthview"></div>' +
        '<div class="view dp-yearview"></div>' +
        '<div class="view dp-yearsetview"></div>';

    /*template for the timer: not implemented yet */
    var watchTemplate = '<div class="dp-header">' +
        '<div class="dp-leftnav"></div>' +
        '<div class="dp-caption"></div>' +
        '<div class="dp-rightnav"></div>' +
        '</div>' +
        '<div class="view dp-monthview"></div>' +
        '<div class="view dp-yearview"></div>' +
        '<div class="view dp-yearsetview"></div>';

    /** default configuration options
     *
     * container: the html element where the datepicker template will be added
     *
     * yearsPerView: number of years to show in the yearset view
     *
     * width: with of the widget
     *
     * viewHeight: Height of the month,year and yearset view. This doesn't include
     *             the height of the header
     *
     * locale: locale information for the locale in which to show the datepicker which comprises of
     *        days: day names to display in the monthview
     *        months: month names to display in the yearview
     *        zero: string representation of zero in the locale. Numbers will be
     *              displayed in that locale only
     *        clearText: Text to display for the reset button
     *        name: name of the locale
     *
     * format: input format for the datepicker (not implemented)
     *
     * pickerType: type of the datetimepicker (date, datetime and time)
     *
     * positioning: element around which datepicker will be displayed. if null then it
     *              will be displayed around the input element
     *
     * showCalendarIcon: to show the Calendar on the right of the text field or not
     */

    var defaults = {
        container: "body",
        yearsPerView: 16,
        width: 433,
        viewHeight: 248,
        locale: {
            days:["S","M","T","W","T","F","S"],
            months: ["January","February","March","April","May","June","July","August","September","October","November","December"],
            zero: "0",
            clearText: "Clear",
            name:"en_US"
        },
        format:"YYYY-MM-DD",
        pickerType:"date",
        positioning: null,
        showCalendarIcon: false
    },
    dates = [31,28,31,30,31,30,31,31,30,31,30,31],
    /*
     *  Actions to perform when clicked on the datepicker buttons
     *  for different views
     *  caption: view to show when clicked on caption
     *           (Year/YearSet/Month/null) null means don't change the view
     *  li: view to show when clicked on date, month or year element
     *  upDown: add(up key) or subtract(down key) current date (for monthview),
     *          month(Year View) or year(YearSetView) with the number provided
     *  key: identifies the key that needs to be changed for that view
     */
    viewAction = {
        Month: {
            caption: 'Year',
            li: null,
            key:"day",
            upDown:7
        },
        Year: {
            caption: "Yearset",
            li: "Month",
            key:"month",
            upDown:3
        },
        Yearset: {
            caption: null,
            li: "Year",
            key:"year",
            upDown:4
        }
    },
    headerClass = "header",

    DateTimePicker = function() {
        this.initialized = false;
    }

    $.extend(DateTimePicker.prototype, {
        /*
         * create the widget using the provided options
         */
        create: function(options) {
            var $dp,self = this,html="",prevNavWidth,nextNavWidth;
            this.options = $.extend({},defaults,options);
            // prevent memory leak since options.positioning holds reference to HTML DOM
            this.options.positioning = null;
            // If width of date-picker exceeds screen width then it'll take up the entire screen width in AF
            if(window.guideBridge && this.options.width > window.innerWidth && window.innerWidth > 0) {
               this.options.width=window.innerWidth - BUFFER_SPC; // buffer
            }
            if(this.options.pickerType.match(/date/)) {
                html += calendarTemplate;
            }

            if(this.options.pickerType.match(/time/)) {
                html += watchTemplate;
            }

            html += clearButtonTemplate;

            $.extend(this, {
                selectedDay:0,
                selectedMonth:0,
                selectedYear:0,
                currentDay:0,
                currentMonth:0,
                currentYear:0,
                touchSupported : xfalib.ut.TouchUtil.TOUCH_ENABLED,
                _visible:false,
                _defaultView:"Month",
                _keysEnabled:false,
                focusedOnLi : false,
                keyboardAccessibility : true,
                $dp:$("<div></div>").addClass("datetimepicker")
                                    .width(this.options.width)
                                    .append(html)
                                    .addClass("datePickerTarget")
                                    .appendTo(this.options.container)
                                    .toggleClass("datetimepicker-notouch",this.touchSupported),
                $month: $(".dp-monthview",this.$dp).height(this.options.viewHeight),
                $year: $(".dp-yearview",this.$dp).height(this.options.viewHeight),
                $yearset : $(".dp-yearsetview",this.$dp).height(this.options.viewHeight)
            });
            this.actualWidth = Math.floor(this.$dp.width());
            this.$clear = $('.dp-clear a', this.$dp).on("click", $.proxy(this._clearDate, this));
            this.$prevNavWidthBtn = $(".dp-leftnav", this.$dp).on("click",
                                                            function(evnt) {
                                                                self._adjustDate(-1, self.view, false)
                                                            });
            this.$nextNavWidthBtn = $(".dp-rightnav", this.$dp).on("click",
                                                            function(evnt) {
                                                                self._adjustDate(1, self.view, false)
                                                            });
            prevNavWidth = this.$prevNavWidthBtn.outerWidth(true);
            nextNavWidth = this.$nextNavWidthBtn.outerWidth(true);
            this.$caption = $(".dp-caption", this.$dp).width(this.actualWidth - prevNavWidth - nextNavWidth)
                                                     .on("click",
                                                            function(evnt) {
                                                                if(!self.$caption.hasClass("disabled")) {
                                                                    self._layout(viewAction[self.view].caption);
                                                                }
                                                      });
            if (this.keyboardAccessibility) {
                _.each([this.$prevNavWidthBtn, this.$caption, this.$nextNavWidthBtn, this.$clear], function (elem, i) {
                    elem.attr("tabIndex", i + 1);
                });
            }
            // attach click event on entire datePicker popup
            $(this.$dp).on("click",
                function(evnt) {
                    //focus only if the device doesn't support touch
                    // input otherwise on screen keyboard will popup
                    if(!self.touchSupported)
                        self._curInstance.$field.focus();
                });

            $(window).on("touchstart.datetimepicker mousedown.datetimepicker",self._checkWindowClicked);
            this._curInstance = null;
        },

        /*
         * attaches the date picker to the field. This is a one time operation
         * First creates a configuration object and stores it in the field data attributes
         * then attaches event handlers on click, focus (to show the picker) and blur (to hide) events
         */
        _attachField: function($field,options, value) {
            var inst = this._newInst($field,options, value),
                self = this,
                activateField = function(evnt) {
                    var data = xfaUtil.$data(evnt.target,"datetimepicker");
                    if(data.access == false) {
                        return;
                    }
                    if(!self._curInstance)
                         self._activateField(evnt);

                    if(self.options.showCalendarIcon) {
                        if (evnt.type === self.getEvent()) {
                            if (self._iconClicked) {
                                self._iconClicked = false;
                                if (self._visible) {
                                    self._hide(); // hide the calendar popup if visible when calendar icon is clicked
                                    self._curInstance.$field.focus(); // bring back focus in field
                                } else {
                                    self._show(); //// show the calendar popup if not visible when calendar icon is clicked
                                }
                            }
                        }
                    } else {
                        /*show the popup only if
                         1. click/touch event
                         2. focus event in case of non-touch devices and focus is not done using script
                         */
                        if (evnt.type === self.getEvent() || (evnt.type === "focus" && !self.touchSupported && !self.scriptFocus)) {
                            self._show(evnt);
                        }
                    }

                    self._clickedWindow = true;
                    self.scriptFocus = false;
                },
                deactivateField = function(evnt) {
                    //deactivate only if clicked outside window
                    // on touch devices only keyboard or calander should be active at once, touching keyboard should deactivate calendar
                    if ((self._clickedWindow && !self.focusedOnLi) && (self.options.showCalendarIcon || !self.touchSupported)) {
                        self._hide();
                        self._deactivateField();
                        self._clickedWindow = true;
                    }
                };

            xfaUtil.$data($field[0],"datetimepicker",inst);

            $field.on(this.getEvent(),activateField)
                  .focus(activateField)
                  .blur(deactivateField);
            if(options.showCalendarIcon) {
                var calendarIcon = $("<div></div>")
                                    .addClass("datepicker-calendar-icon")
                                    .css({
                                        "width": options.iconWidth + "px",
                                        "height": options.iconHeight + "px"
                                    });
                calendarIcon.insertAfter($field);

                if (this.keyboardAccessibility) {
                    calendarIcon.attr("tabindex", 0);
                }

                calendarIcon.on(this.getEvent(), function (evnt) {
                                self._iconClicked = true;
                                $field.click();
                              })
                              .on("keydown", function (event) {
                                    if (event.keyCode === 32 || event.keyCode === 13) {
                                        $field.click();
                                    }
                              });
            }
        },

        _newInst: function($f,options, value) {
            return {
                $field:$f,
                locale: options.locale,
                positioning: options.positioning || $f,
                access:options.access,
                selectedDate:options.value,
                editValue :options.editValue,
                minValidDate : options.minValidDate,
                maxValidDate : options.maxValidDate,
                exclMinDate :  options.exclMinDate,
                exclMaxDate : options.exclMaxDate
            }
        },

        /*
         * To check where the click happened, if happened outside the datepicker
         * then hide the picker. This is checked whether any ancestor of clicked target
         * has a class datePickerTarget. This class is added to the attached element as well
         */
        _checkWindowClicked : function(evnt) {
            var self = adobeDateTimePicker;
            if(self._curInstance) {
                // datepickerTarget class depicts that the component is a part of the Date Field
                // and on click of that class, we should not hide the datepicker or fire exit events.
                if(!$(evnt.target).closest(".datePickerTarget").length) {
                    //non-touch devices do not deactivate on blur. Hence needs to be done here
                    if(self.touchSupported) {
                        self._hide()
                        //clicking outside a field doesn't blur the field in IPad. Doing it by script
                        self._curInstance.$field[0].blur()
                        self._deactivateField()
                    } else{
                        self._clickedWindow = true;
                    }
                }
                else {
                    self._clickedWindow = false;
                }
            }
        },

        /*
         * handling of key strokes. All the key strokes prevent the default browser action
         * unless specified otherwise
         * tab: set focus on calendar icon when dateinput field is active, navigates through date picker buttons when datepicker is open,
         * otherwise perform default browser action
         * escape: hides the datepicker
         * down arrow key: navigate the picker downwards by the number specified in actionView.upDown of the current View
         * up arrow key: navigate the picker upwards by the number specified in actionView.upDown of the current View
         * left arrow key: navigate the picker one unit of that view backward
         * right arrow key: navigate the picker one unit of that view forward
         * shift + up: perform the action that happens on clicking the caption (as specified in actionView.caption)
         * shift + left: perform the action that happens on clicking the left navigation button
         * shift + right: perform the action that happens on clicking the right navigation button
         * space/enter: triggers the click event for the current focused element from datepicker/ opens datepicker when calendar icon is focused.
         */
        _hotKeys: function(evnt) {
            var handled = false, date;
            switch(evnt.keyCode) {
                case 9: //tab
                    // CQ-4239352 : Setting clickedWindow property to true on tabbing so that deactivateField logic gets executed
                    // When clicking on "x" on input field in in IE and when selecting the content and releasing the mouse select outside the field
                    // the click event is not trigerred on the field and hence activateField is not executed, so clickedWindow remains as false
                    adobeDateTimePicker._clickedWindow = true;
                    handled = false;
                    break;
                case 27://escape
                    if(this._visible) {
                        adobeDateTimePicker._hide();
                        this._curInstance.$field.focus();
                        handled = true;
                    }
                    break;
                case 32: //space
                case 13: // enter
                    if($(evnt.target).hasClass("datepicker-calendar-icon")){
                        if(!this._visible) {
                            this._show();
                            return;
                        }
                        this.$focusedDate.addClass("dp-focus");
                    }
                    break;
                case 40: //down arrow key
                    if(!this._visible) {
                        this._show();
                        return;
                    }
                    this.$focusedDate.addClass("dp-focus");
                    break;
            }

            if(adobeDateTimePicker._visible && this._keysEnabled) {
                var v = viewAction[this.view].key,
                    updown=viewAction[this.view].upDown;
                switch(evnt.keyCode) {
                    case 9: // tab
                        if (evnt.shiftKey) {
                            if ($(evnt.target).hasClass("dp-leftnav") || $(evnt.target).hasClass("dp-focus")) {
                                this._hide();
                                this._curInstance.$field.focus();
                                handled = true;
                            } else {
                                handled = false;
                            }
                        } else {
                            var buttonTabindex = $(evnt.target).attr("tabindex");
                            if (buttonTabindex === '0') {
                                if (evnt.target.tagName.toLocaleLowerCase() === "input") {
                                    this._hide();
                                    handled = false;
                                } else {
                                    this.$prevNavWidthBtn.focus();
                                    handled = true;
                                }
                            } else if (buttonTabindex === '4') {
                                this._hide();
                                this._curInstance.$field.focus();
                                handled = true;
                            } else {
                                handled = false;
                            }
                        }
                        break;
                    case 32: //select on space
                    case 13: // select on enter
                        this.hotKeyPressed = true;
                        this.focusedOnLi = false;
                        if (!this.focusedOnLi) {
                            $(evnt.target, this.$dp).triggerHandler("click");
                        } else {
                            if (this.$focusedDate) {
                                this.$focusedDate.trigger("click");
                            }
                        }
                        this.hotKeyPressed = false;
                        handled = true;
                        break;
                    case 37: //left arrow key
                        if (evnt.shiftKey) {
                            $(".dp-leftnav", this.$dp).triggerHandler("click");
                        } else {
                            this._adjustDate(-1, v, true);
                        }
                        handled = true;
                        break;
                    case 38: //up arrow key
                        if (evnt.shiftKey) {
                            this.$caption.triggerHandler("click");
                        } else {
                            this._adjustDate(-updown, v, true);
                        }
                        handled = true;
                        break;
                    case 39: //right arrow key
                        if (evnt.shiftKey) {
                            $(".dp-rightnav", this.$dp).triggerHandler("click");
                        } else {
                            this._adjustDate(+1, v, true);
                        }
                        handled = true;
                        break;
                    case 40: //down arrow key
                        this._adjustDate(updown, v, true);
                        handled = true;
                        break;
                    default:
                }
            }
            if(handled) {
                evnt.preventDefault();
            }
        },

        /*
         * show the datepicker.
         */
        _show: function() {
            if(this._curInstance.access == false)
                return;
            this.options.locale = this._curInstance.locale;
            if(!this._visible) {
                var self = this,
                    date = new Date(),
                    val,
                    maxDateInfo,
                    minDateInfo,
                    validDate;
                //Bug#3607735:
                // Date constructor in ipad 5.1 doesn't support "YYYY-MM-DD", hence parsing the date on our own
                validDate = xfalib.ut.DateInfo.ParseIsoString(this._curInstance.selectedDate);
                date = (validDate != null)? validDate.getDate(): new Date();
                this.selectedDay = this.currentDay = date.getDate();
                this.selectedMonth = this.currentMonth = date.getMonth();
                this.selectedYear = this.currentYear = date.getFullYear();
                maxDateInfo = this.options.maxValidDate ? xfalib.ut.DateInfo.ParseIsoString(this._curInstance.maxValidDate) : null;
                this.maxValidDate = maxDateInfo ? maxDateInfo.getDate() : null;
                minDateInfo = this.options.minValidDate ? xfalib.ut.DateInfo.ParseIsoString(this._curInstance.minValidDate) : null;
                this.minValidDate = minDateInfo ? minDateInfo.getDate() : null;
                this.exclMaxDate = this._curInstance.exclMaxDate;
                this.exclMinDate = this._curInstance.exclMinDate;
                $('.dp-clear a',this.$dp).text(this.options.locale.clearText);
                this._layout('Month');
                this._position();
                this.$dp.show();
                this.focusedOnLi = false;
                this._visible = true;
                if (this.options.showCalendarIcon) {
                    this._curInstance.$field.attr('readonly', true);    // when the datepicker is active, deactivate the field
                }
            }

            //   Disabling the focus on ipad  due to a bug where value of
            // date picker is not being set
            // Removing this code will only hamper one use case
            // where on ipad if you click on the calander then
            // the field becomes read only so
            // there is no indication where the current focus is
            // And  if you remove this foucs code all together
            // then what happens is that on desktop MF in iframe the exit event
            // is not getting called hence calander getting remained open even
            // when you click somewhere on window or focus into some other field
            if (this.options.showCalendarIcon  && !this.touchSupported ) {
                this._curInstance.$field.focus(); // field loses focus after being marked readonly, causing blur event not to be fired later
            }
        },

        /*
         * position the datepicker around the positioning element
         * provided in the options
         */
        _position: function() {
            var $elem = this._curInstance.positioning,
                windowScrollX = window.scrollX/ xfalib.ut.XfaUtil.prototype.formScaleFactor,
                windowScrollY = window.scrollY/ xfalib.ut.XfaUtil.prototype.formScaleFactor,
                windowInnerHeight = window.innerHeight/ xfalib.ut.XfaUtil.prototype.formScaleFactor,
                windowInnerWidth = window.innerWidth/ xfalib.ut.XfaUtil.prototype.formScaleFactor,
                height = $elem.outerHeight(true),
                width  = $elem.outerWidth(true),
                top = $elem.offset().top / xfalib.ut.XfaUtil.prototype.formScaleFactor + height,
                left = $elem.offset().left / xfalib.ut.XfaUtil.prototype.formScaleFactor,
                styles = {"top": (top+"px"), "left": (left+"px")},
                diffBottom = top + this.$dp.outerHeight(true) - windowInnerHeight - windowScrollY,
                newLeft,
                newTop;
            if(diffBottom > 0) {
                //can't appear at the bottom
                //check top
                newTop = top - height - this.$dp.outerHeight(true) - BUFFER_SPC;
                if(newTop < windowScrollY) {
                    //can't appear at the top as well ... the datePicker pop up overlaps the date field
                    newTop = top - diffBottom;
                    // Fix for BUG #3626974
                    if(xfaUtil.isWebkit() && !this.options.showCalendarIcon) {
                        this._curInstance.$field.trigger("onoverlap.datetimepicker");
                    }
                }
                styles.top = newTop + "px";
            }
            if(left + this.$dp.outerWidth(true) > windowScrollX + windowInnerWidth ) {
                //align with the right edge
                newLeft = windowScrollX + windowInnerWidth - this.$dp.outerWidth(true) - BUFFER_SPC;
                styles.left = newLeft + "px";
            }
            xfaUtil.$css(this.$dp.get(0), styles);
            return this;
        },

        /*
         * layout the nextView. if nextView is null return
         *
         */
        _layout: function(nextView) {
            if(nextView == null) {
                this._hide();
            } else {
                if(this.view)
                    this['$'+this.view.toLowerCase()].hide();
                this.view = nextView;
                this.$caption.toggleClass("disabled",!viewAction[this.view].caption);
                this['$'+this.view.toLowerCase()].show();
                this["show"+this.view]();
            }
            return this;
        },

        /*
         * show the month view
         */
        showMonth: function() {
            var self = this,
                curDate = new Date(this.currentYear, this.currentMonth),
                maxDay =   this._maxDate(this.currentMonth),
                prevMaxDay = this._maxDate((this.currentMonth + 12)%12),
                day1 = new Date(this.currentYear,this.currentMonth,1).getDay(),
                rowsReq = Math.ceil((day1 + maxDay) / 7) + 1,
                data,display;

            this.tabulateView(
                {
                    caption: this.options.locale.months[this.currentMonth] + ", "+ this._convertNumberToLocale(this.currentYear),
                    header:this.options.locale.days,
                    numRows:rowsReq,
                    numColumns:7,
                    elementAt: function(row,col) {
                        var day = (row-1)*7 + col - day1 + 1;
                        display = self._convertNumberToLocale(day);
                        data = day;
                        if(day < 1) {
                            display = self._convertNumberToLocale(prevMaxDay + day);
                            data = -1
                        }
                        else if(day > maxDay) {
                            display = self._convertNumberToLocale(day-maxDay);
                            data = -1;
                        }
                        else {
                            curDate.setDate(day);
                            var compareFn = xfalib.ut.XfaUtil.prototype._compareVal;
                            // check if the currentdate is valid based on max and min valid date
                            if(compareFn(curDate, self.maxValidDate, self.exclMaxDate) || compareFn(self.minValidDate, curDate, self.exclMinDate)) {
                                data = -1;
                            }
                        }
                        return {
                            data : data,
                            display : display,
                            ariaLabel : self.options.editValue(self.currentYear+"-"+self._pad2(self.currentMonth + 1)+"-"+self._pad2(display))
                        };
                    }
                });
        },



        /*
         * show the year view
         */
        showYear: function() {
            var self = this,
                minDate = this.minValidDate ? new Date(this.minValidDate.getFullYear(), this.minValidDate.getMonth()) : null,
                maxDate = this.maxValidDate ? new Date(this.maxValidDate.getFullYear(), this.maxValidDate.getMonth()) : null,
                curDate = new Date(this.currentYear, 0), //can't omit month, if only one param present it is treated as millisecond
                data,
                month;
            this.tabulateView(
                {
                    caption : this._convertNumberToLocale(this.currentYear),
                    numRows : 4,
                    numColumns : 3,
                    elementAt : function(row,col) {
                        data = month =  row*3 + col;
                        curDate.setMonth(month);
                        if ((minDate && curDate < minDate) || (maxDate && curDate > maxDate)) {
                            data = -1;
                        }
                        return {
                            data : data,
                            display : self.options.locale.months[month],
                            ariaLabel : self.options.locale.months[month] + " " +self.currentYear
                        };
                    }
                });
        },

        /*
         * show the year set view
         */
        showYearset: function() {
            var year,
                minDate = this.minValidDate ? new Date(this.minValidDate.getFullYear(), 0) : null ,
                maxDate = this.maxValidDate ? new Date(this.maxValidDate.getFullYear() + 1, 0) : null,
                curDate = new Date(),
                data,
                self = this;
            this.tabulateView(
                {
                    caption: this._convertNumberToLocale(this.currentYear - this.options.yearsPerView/2) +"-"+this._convertNumberToLocale(this.currentYear - this.options.yearsPerView/2 + this.options.yearsPerView - 1),
                    numRows:4,
                    numColumns:4,
                    elementAt: function(row,col) {
                        data = year =  self.currentYear - 8 + (row*4 + col);
                        curDate.setFullYear(year);
                        if ((minDate && curDate < minDate) || (maxDate && curDate > maxDate)) {
                            data = -1;
                        }
                        return {
                            "data" : data,
                            "display" : self._convertNumberToLocale(year),
                            ariaLabel : year
                        };
                    }
                });
        },

        insertRow :  function(rowNum,rowArray,isHeader,height) {
            var $view = this["$"+this.view.toLowerCase()],
                width = (this.actualWidth)/rowArray.length,
                $row = $("ul",$view).eq(rowNum),
                items,$li,element,$tmp,
                self= this;
            if(!$row.length)
                $row = $("<ul></ul>").attr("aria-label", "").appendTo($view).toggleClass(headerClass,isHeader);
            $row.height(height);
            items = $("li",$row).length;
            while(items++ < rowArray.length) {
                $tmp = $("<li></li>").appendTo($row);
                if(!isHeader)
                    $tmp.on("click", $.proxy(this._selectDate,this));
            }

            _.each(rowArray, function(el,index) {
                $li = $("li",$row).eq(index);
                if(isHeader)
                    $li.text(rowArray[index]);
                else {
                    element = rowArray[index];
                    xfaUtil.$data($li.get(0), "value", element.data);
                    if(self._checkDateIsFocussed(element.data)) {
                        if(self.$focusedDate) {
                            self.$focusedDate.removeClass("dp-focus");
                            self.$focusedDate.attr("tabindex", "-1");
                        }
                        self.$focusedDate = $li;
                        if(self._keysEnabled)
                            self.$focusedDate.addClass("dp-focus")
                    }
                    $li.toggleClass("dp-selected",self._checkDateIsSelected(element.data))
                        .toggleClass("disabled", element.data == -1).text(element.display)
                        .attr("title", element.ariaLabel)
                        .attr("aria-label", element.ariaLabel)
                        .attr("tabindex", -1);
                }
                $li.css( {"height":height+"px","width":width+"px","line-height":height+"px"});
            });
            return $row;
        },

        /*
         * creates a tabular view based on the options provided. The options that can be passed are
         * numRows: number of rows that needs rendering
         * numCols: number of columns that needs rendering
         * caption: text for the datepickers caption element
         * header: an array of elements that identifies the header row
         * elementAt: a function(row, column) that returns an object (data: <data>, display: <display>) where
         *            <data> is the value to set for that view when the element at (row,column) is clicked and
         *            <display> is the value that will be visible to the user
         */
        tabulateView : function(options) {
            var r = 0,rows = 0,
                row = [],
                ht =  this.options.viewHeight/options.numRows,
                c;
            this.$caption.text(options.caption);
            if(options.header) {
                this.insertRow(r++,options.header,true,ht);
            }
            while(r < options.numRows) {
                c = 0;
                while(c < options.numColumns) {
                    row[c] = options.elementAt(r,c);
                    c++;
                }
                this.insertRow(r++,row,false,ht);
            }
            rows = $(".dp-"+this.view.toLowerCase()+"view ul:visible").length;
            while(rows > options.numRows) {
                $(".dp-"+this.view.toLowerCase()+"view ul").eq(--rows).hide();
            }
            while(options.numRows > rows) {
                $(".dp-"+this.view.toLowerCase()+"view ul").eq(rows++).show();
            }
        },

        _activateField : function(evnt) {
            this._curInstance = xfaUtil.$data(evnt.target,"datetimepicker");
            this._curInstance.$field.trigger("onfocus1.datetimepicker").addClass("datePickerTarget");
            // Issue LC-7049:
            // datepickerTarget should be added when activate the field and should be removed
            // after the fields gets deactivated.
            if (this.options.showCalendarIcon) {
                this._curInstance.$field.parent().addClass("datePickerTarget");
            }
            //enable hot keys only for non touch devices
            if(!this.touchSupported && !this._keysEnabled) {
                $(window).on("keydown.datetimepicker", $.proxy(this._hotKeys,this));
                this._keysEnabled = true;
            }
        },

        _deactivateField: function() {
            if(this._curInstance) {
                if(this._keysEnabled) {
                    $(window).off("keydown.datetimepicker")
                    this._keysEnabled = false;
                }
                //Bug#3607499: on deactivate check the value in the input box, if that is
                // different than the selected Date, change the selectedDate
                //if (this._curInstance.selectedDate != this._curInstance.$field.val()) {
                //    this._curInstance.selectedDate = this._curInstance.$field.val();
                //}
                this._curInstance.$field.trigger("onfocusout.datetimepicker").removeClass("datePickerTarget");
                // Issue LC-7049:
                // datepickerTarget should be added when activate the field and should be removed
                // after the fields gets deactivated. Otherwise clicking on any other datefield
                // will not hide the existing datepicker
                if (this.options.showCalendarIcon) {
                    this._curInstance.$field.parent().removeClass("datePickerTarget");
                }
                this._curInstance = null;
            }
        },

        _hide: function() {
            if(this._visible) {
                this.$dp.hide();
                this._curInstance.$field.trigger("onclose.datetimepicker");
                this._visible = false;
                if (this.options.showCalendarIcon) {
                    this._curInstance.$field.attr('readonly', false);    // when the datepicker is deactivated, activate the field
                }
            }
        },

        _adjustDate: function(step, view, focus) {
            var maxDate,prevMaxDate;
            var _focus = focus || false;
            switch(view.toLowerCase()) {
                case "day":
                    this.currentDay += step;
                    maxDate = this._maxDate(this.currentMonth)
                    if(this.currentDay < 1) {
                        prevMaxDate =  this._maxDate((this.currentMonth - 1 + 12)%12);
                        this.currentDay = prevMaxDate + this.currentDay;
                        return this._adjustDate(-1, "month", _focus);
                    }
                    if(this.currentDay > maxDate) {
                        this.currentDay -= maxDate;
                        return this._adjustDate(+1, "month", _focus);
                    }
                    break;
                case "month":
                    this.currentMonth += step;
                    if(this.currentMonth > 11) {
                        this.currentYear++;
                        this.currentMonth = 0;
                    }
                    if(this.currentMonth < 0) {
                        this.currentYear--;
                        this.currentMonth = 11;
                    }
                    break;
                case "year":
                    this.currentYear += step;
                    break;
                case "yearset":
                    this.currentYear += step*this.options.yearsPerView;
                    break;
            }
            this._layout(this.view);
            if (_focus) {
                this.focusedOnLi = true;
                this.$focusedDate.attr("tabindex", 0)[0].focus();
            }
        },

        _checkDateIsSelected: function(data) {
            switch(this.view.toLowerCase()) {
                case "month":
                    return this.currentYear == this.selectedYear && this.currentMonth == this.selectedMonth && data == this.selectedDay;
                case "year":
                    return this.currentYear == this.selectedYear && this.selectedMonth == data;
                case "yearset":
                    return this.selectedYear == data;
            }
        },

        _checkDateIsFocussed: function(data) {
            switch(this.view.toLowerCase()) {
                case "month":
                    return data == this.currentDay;
                case "year":
                    return this.currentMonth == data;
                case "yearset":
                    return this.currentYear == data;
            }
        },

        _convertNumberToLocale : function(number) {
            var zeroCode = this.options.locale.zero.charCodeAt(0);
            number += "";
            var newNumber = [];
            for(var i = 0;i < number.length;i++) {
                newNumber.push(String.fromCharCode(zeroCode + parseInt(number.charAt(i))));
            }
            return newNumber.join("");
        },

        _clearDate: function() {
            var isDateEmpty = this._curInstance.$field.val() ? false : true;
            this.selectedYear
                = this.selectedMonth
                = this.selectedYear
                = -1;
            this._curInstance.selectedDate = "";
            this._curInstance.$field.val("");
            if (!isDateEmpty) {
                this._curInstance.$field.trigger("onvaluechange.datetimepicker", [
                    {selectedDate: ""}
                ]);
            }
            $(".dp-selected",this['$'+this.view.toLowerCase()]).removeClass("dp-selected");
        },

        getEvent : function() {
            return "click";//this.touchSupported ? "touchstart" : "click";
        },

        _pad2: function(m) {
            return m = m < 10 ?"0"+m:m;
        },

        toString : function() {
            return this.selectedYear +"-"+this._pad2(this.selectedMonth + 1)+"-"+this._pad2(this.selectedDay);
        },

        _selectDate : function(evnt) {
            var val = xfaUtil.$data(evnt.target, "value"),
                nextView = viewAction[this.view].li,
                editVal;
            //disabled dates have a value of -1. Do nothing in that case
            if(val == -1)
                return;
            switch(this.view.toLowerCase()) {
                case "month":
                    this.selectedMonth = this.currentMonth;
                    this.selectedYear = this.currentYear;
                    this.selectedDay = val;
                    this._curInstance.selectedDate = this.toString();
                    editVal = this._curInstance.editValue(this.toString());
                    this._curInstance.$field.val(editVal).focus();
                    this._curInstance.$field.trigger("onvaluechange.datetimepicker", [
                        {selectedDate: editVal}
                    ]);
                    $(".dp-selected",this['$'+this.view.toLowerCase()]).removeClass("dp-selected");
                    $(evnt.target).addClass("dp-selected");
                    break;
                case "year":
                    this.currentMonth = val;
                    break;
                case "yearset":
                    this.currentYear = val;
                    break;
            }
            this._layout(nextView);
            //manually focus on the field if clicked on the popup buttons for non-touch device
            if(!this.touchSupported) {
                //No need to focus if selection is made by pressing space.
                if(!this.hotKeyPressed) {
                    this.scriptFocus = true;
                }
            } else if(nextView == null){
                //For touch devices, deactivate the field if a selection is made
                this._deactivateField()
            }
        },

        _leapYear : function() {
            return this.currentYear % 400 == 0 || (this.currentYear % 100 != 0 && this.currentYear % 4 == 0);
        },

        _maxDate : function(m) {
            if(this._leapYear() && m == 1)
                return 29;
            else return dates[m];
        },

        _access: function(val) {
            if(typeof val == "undefined")
                return this.access
            this.access = val;
        },

        _value:function(val) {
            if(typeof val == "undefined")
                return this.$field.val()
            else {
                this.selectedDate = val;
                var editValue = this.editValue(val);
                // update the field val with provided value instead of null
                if (!editValue) {
                    editValue = val;
                }
                this.$field.val(editValue);
            }
        }
    });

    var adobeDateTimePicker = new DateTimePicker();

    $.fn.adobeDateTimePicker = function(options, value) {
        if(!adobeDateTimePicker.initialized) {
            adobeDateTimePicker.create(options);
            adobeDateTimePicker.initialized = true;
        }
        if(typeof options === "object") {
            adobeDateTimePicker._attachField(this, options);
        }
        else if(typeof options === "string") {
            if(arguments.length == 2)
                adobeDateTimePicker["_"+options].apply(xfaUtil.$data(this[0],"datetimepicker"),[value])
            else
                return adobeDateTimePicker["_"+options].apply(xfaUtil.$data(this[0],"datetimepicker"))
        }
        return this;
    }
})(_, $, xfalib);
(function (xfalib) {
    xfalib.ut.TouchUtil = (function () {
        var touchAvailable = !!("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch) ,
            pointerEnabled = !!(window.MSPointerEvent || window.PointerEvent) ,
            POINTER_DOWN_EVENT = "mousedown",
            POINTER_MOVE_EVENT = "mousemove",
            POINTER_UP_EVENT = "mouseup",
            EVENT_TYPE = "MouseEvent";

        if (window.PointerEvent) { //> IE11
            POINTER_DOWN_EVENT = "pointerdown";
            POINTER_MOVE_EVENT = "pointermove";
            POINTER_UP_EVENT = "pointerup";
            EVENT_TYPE = "PointerEvent";

        } else if (window.MSPointerEvent) { // IE10
            POINTER_DOWN_EVENT = "MSPointerDown";
            POINTER_MOVE_EVENT = "MSPointerMove";
            POINTER_UP_EVENT = "MSPointerUp";
            EVENT_TYPE = "MSPointerEvent" ;

        } else if (touchAvailable) {  // other touch devices
            POINTER_DOWN_EVENT = "touchstart";
            POINTER_MOVE_EVENT = "touchmove";
            POINTER_UP_EVENT = "touchend";
            EVENT_TYPE = "TouchEvent";
        }
        return {
            TOUCH_ENABLED: touchAvailable,
            // new MS Pointer Events
            POINTER_EVENT: EVENT_TYPE,
            POINTER_ENABLED: pointerEnabled,
            POINTER_DOWN: POINTER_DOWN_EVENT,
            POINTER_MOVE: POINTER_MOVE_EVENT,
            POINTER_UP: POINTER_UP_EVENT,
            getTouchEvent: function (evt) {
                var target;
                if (pointerEnabled) {
                    target = evt.originalEvent;
                } else if (touchAvailable) {
                    target = evt.originalEvent || evt;
                    target = target.touches[0];
                    //if (evt.originalEvent && evt.originalEvent.changedTouches && evt.originalEvent.changedTouches[0]) {
                    //    te = evt.originalEvent.changedTouches[0];
                    //}
                }

                return target || evt;
            },
            getPointerEvent: function (eventType) {
                var event = null;
                if ((typeof PointerEvent) === "function") {
                    event = new PointerEvent(eventType, {
                        bubbles: true,
                        cancelable: true
                    });
                } else {
                    event = document.createEvent(EVENT_TYPE);
                    event.initEvent(eventType, true, true);
                }
                return event;
            },
            getTouches:function(evt){
                var touches = [];
                if(touchAvailable && evt.originalEvent && evt.originalEvent.touches ){
                    touches = evt.originalEvent.touches;
                }
                return touches;
            }
        };
    })();
})(xfalib);
(function ($) {
    $.widget("xfaWidget.abstractWidget", {

        $userControl: null,

        $data: xfalib.ut.XfaUtil.prototype.$data,

        $css: xfalib.ut.XfaUtil.prototype.$css,

        getOrElse: xfalib.ut.Class.prototype.getOrElse,

        dIndexOf: xfalib.ut.XfaUtil.prototype.dIndexOf,

        btwn: xfalib.ut.XfaUtil.prototype.btwn,

        logger: xfalib.ut.XfaUtil.prototype.getLogger,

        localeStrings: xfalib.ut.XfaUtil.prototype.getLocaleStrings,

        logMsgs: xfalib.ut.XfaUtil.prototype.getLogMessages,

        errorManager: xfalib.ut.XfaUtil.prototype.getErrorManager,

        _widgetName: "abstractWidget",

        // if there are any specific black listed attributes, each widget should define their own
        _blackListedAttributes : ["type"],

        options: {
            name: "",
            value: null,
            commitProperty: "value",
            displayValue: null,
            screenReaderText: null,
            tabIndex: 0,
            role: null,
            paraStyles: null,
            dir: null,
            errorMessage: null,
            warningMessage: null,
            hScrollDisabled: false,
            placeholder:"",
            isValid:true,
            mandatory: false
        },

        getOptionsMap: function () {
            return {
                "tabIndex": function (val) {
                    this.$userControl.attr("tabindex", val);
                },
                "role": function (val) {
                    if (val)
                        this.$userControl.attr("role", val);
                },
                "screenReaderText": function (val) {
                    if (val)
                        this.$userControl.attr("aria-label", val)
                },
                "paraStyles": function (val) {
                    if (val)
                        this.$css(this.$userControl.get(0), val);
                },
                "dir": function (val) {
                    if (val)
                        this.$userControl.attr("dir", this.options.dir);
                },
                "height": function (val) {
                    if (val) {
                        this.$css(this.$userControl[0], {"height": val})
                    }
                },
                "width": function (val) {
                    if (val)
                        this.$css(this.$userControl[0], {"width": val})
                },
                "isValid": function (val) {
                    if(val){
                      this.$userControl.removeAttr("aria-invalid");
                    } else {
                      this.$userControl.attr("aria-invalid",true);
                    }
                },
                "color" : function(value) {
                    if(!_.isEmpty(value)) {
                        var color = "rgb(" + value + ")";
                        this.$css(this.$userControl[0], {"color": color});
                    }
                },
                "font-style" : function (value) {
                    if (!_.isEmpty(value)) {
                        this.$css(this.$userControl[0], {"font-style": value});
                    }
                },
                "mandatory" : function (value) {
                    if(value){
                        this.$userControl.attr("aria-required", true);
                    } else {
                        this.$userControl.removeAttr("aria-required");
                    }
                }
            };
        },

        getEventMap: function () {
            return {
                "focus": xfalib.ut.XfaUtil.prototype.XFA_ENTER_EVENT,
                "blur": xfalib.ut.XfaUtil.prototype.XFA_EXIT_EVENT,
                "click": xfalib.ut.XfaUtil.prototype.XFA_CLICK_EVENT
            };
        },

        /**
         * Copies all the attributes from source jquery object to destination jquery object
         * @param $src      source jquery object
         * @param $dest     destination jquery object
         */
        copyAttributesFromSrcToDest : function($src, $dest){
            var that = this;
            // let's get all the attribute from the src element and copy it to dest jquery object
            if($src != null && $src[0] && $src[0].attributes && $dest != null){
                $.each($src[0].attributes, function() {
                    // we don't add the black listed set of attributes
                    if(this.specified && this.value != null && _.isString(this.value) && this.value.length > 0 && that._blackListedAttributes.indexOf(this.name) === -1) {
                        $dest.attr(this.name, this.value);
                    }
                });
            }
        },

        _create: function () {
            this.widgetEventPrefix = "";
            this.element.addClass(this._widgetName);
            this.$userControl = this.render();
            this.optionsHandler = this.getOptionsMap();
            this.eventMap = this.getEventMap();
            this._initializeOptions();
            this._initializeEventHandlers();
            this.errObj = this.errorManager();
            //call it only after render
            // Dirty hack to prevent this being called in Guide
            if (typeof guidelib === "undefined") {
                this.$css(this.$userControl.get(0), {
                    "box-sizing": "border-box",
                    "position": "absolute"
                });
            }
        },

        _initializeEventHandlers: function () {
            xfalib.ut.XfaUtil.prototype.getLogger().debug("xfa", "initialize event handlers for " + this._widgetName);
            _.each(this.eventMap, function (xfaevent, htmlevent) {
                var self = this;
                if (xfaevent) {
                    if (!(xfaevent instanceof  Array)) {
                        xfaevent = [xfaevent];
                    }
                    for (var i = 0; i < xfaevent.length; i++) {
                        xfalib.ut.XfaUtil.prototype.getLogger().debug("xfa", "binding " + htmlevent + " with " + xfaevent[i]);
                        this.$userControl.on(htmlevent,
                            (function (xfevnt) {
                                return function (evnt) {
                                    xfalib.ut.XfaUtil.prototype.getLogger().debug("xfa", "trigger " + evnt.type +
                                    " xfa-event " + xfevnt);
                                    self._preProcessEvent.apply(self, [xfevnt, evnt]);
                                    //since the fix https://github.com/jquery/jquery/pull/972, Fix for keeping namespace when triggering an event using an Event #972
                                    //we need to clear the namespace and its regular expression of triggering event, as the listeners are registered on un-namespaced events
                                    evnt.namespace = "";
                                    evnt.namespace_re = "";
                                    self._trigger(xfevnt, evnt);
                                    self._postProcessEvent.apply(self, [xfevnt, evnt]);
                                }
                            })(xfaevent[i])
                        )

                    }
                }
            }, this)
        },

        _preProcessEvent: function (xfaevent, htmlevent) {
            if (xfaevent == this.options.commitEvent) {
                this.preProcessCommit(htmlevent);
            }
            switch (xfaevent) {
                case xfalib.ut.XfaUtil.prototype.XFA_ENTER_EVENT:
                    this.preProcessEnter(htmlevent);
                    break;
                case xfalib.ut.XfaUtil.prototype.XFA_EXIT_EVENT:
                    this.preProcessExit(htmlevent);
                    break;
                case xfalib.ut.XfaUtil.prototype.XFA_CHANGE_EVENT:
                    this.preProcessChange(htmlevent);
                    break;
                case xfalib.ut.XfaUtil.prototype.XFA_CLICK_EVENT:
                    this.preProcessClick(htmlevent);
                    break;
            }

        },

        _postProcessEvent: function (xfaevent, htmlevent) {
            if (xfaevent == this.options.commitEvent) {
                this.postProcessCommit(htmlevent);
            }
            switch (xfaevent) {
                case xfalib.ut.XfaUtil.prototype.XFA_ENTER_EVENT:
                    this.postProcessEnter(htmlevent);
                    break;
                case xfalib.ut.XfaUtil.prototype.XFA_EXIT_EVENT:
                    this.postProcessExit(htmlevent);
                    break;
                case xfalib.ut.XfaUtil.prototype.XFA_CHANGE_EVENT:
                    this.postProcessChange(htmlevent);
                    break;
                case xfalib.ut.XfaUtil.prototype.XFA_CLICK_EVENT:
                    this.postProcessClick(htmlevent);
                    break;
            }
        },

        _initializeOptions: function () {
            _.each(this.optionsHandler, function (value, key) {
                if (typeof value === "function")
                    value.apply(this, [this.options[key]]); // TODO: check whether it is needed for initialization or not
            }, this)
        },

        _setOption: function (key, value) {
            if (this.options[key] != value) {
                this.options[ key ] = value;
                if (typeof this.optionsHandler[key] === "function") {
                    this.optionsHandler[key].apply(this, [this.options[key]])
                }
            }
        },

        /**
         * @override
         */
        option: function (key, value) {
            if (arguments.length === 1 &&
                typeof key === "string" &&
                this.options.hasOwnProperty(key) &&
                this.options[key] === undefined) {
                return undefined;
            }
            return $.Widget.prototype.option.apply(this, arguments)
        },

        destroy: function () {
            this.$userControl.removeClass(this._widgetName);
        },


        render: function () {
            var control;
            if (this.element.children().length > 0) {
                control = $(this.element.children().get(0));
            }
            else
                control = this.element;
            control.attr("name", this.options.name)
            return control;
        },


        preProcessCommit: function (evnt) {
            this.options.value = this.getCommitValue();
            xfalib.ut.XfaUtil.prototype.getLogger().debug("xfa", "passing commit value " + this.options.value +
            "to model ");
        },

        getCommitValue: function () {

        },

        preProcessExit: function (evnt) {

        },

        preProcessEnter: function (evnt) {
            //Only focus the enabled widgets
            if (this.options.access === "open") {
                this._showError();
                this.showValue();
            }
        },

        preProcessChange: function (evnt) {

        },

        preProcessClick: function (evnt) {

        },

        postProcessCommit: function (evnt) {
            this.showDisplayValue();
        },

        postProcessExit: function (evnt) {
            //Only for the enabled widgets
            if (this.options.access === "open") {
                this.showDisplayValue();
                this._hideError();
            }
        },

        postProcessEnter: function (evnt) {
        },

        postProcessChange: function (evnt) {

        },

        postProcessClick: function (evnt) {

        },

        showDisplayValue: function () {
            this.$userControl.val(this.options.displayValue)
        },

        /**
         * Checks if the edit value is same as value present in the user control(html form element)
         * @returns {boolean}
         */
        _isValueSame : function(){
            return (((this.options.value === null) && (this.$userControl.val() === "")) || (this.options.value === this.$userControl.val()));
        },

        showValue: function () {
            // May be $userControl doesn't have val(), using it as of now
            // If the value of the field is not same as edit value, only then set the value, this also solves IE bug of cursor
            // moving to the end of field on click
            if(!this._isValueSame()) {
                this.$userControl.val(this.options.value)
            }
        },

        focus: function () {
            var that = this;
            // setTimeout added to fix CQ-51141
            // While using setFocus API in adaptive form, the focus was not being set in TextBox on chrome
            // and also on click of caption of RadioButton/Checkbox, due to fast event execution, hence adding delay during focus.
            setTimeout(function(){
                that.$userControl[0].focus();
            }, 1);
        },

        click: function () {
            this.focus();
            this.$userControl.triggerHandler("click"); // we do not want the exact click as might bubble up to the field.
        },

        /* widget specific code */

        _showError: function () {
            if(this.errObj && _.isFunction(this.errObj.onFieldEnter)) {
                this.errObj.onFieldEnter(this);
            }
        },

        _calculatePaddingForVAlign:function(diff){
           var flagForMoz = $.browser.mozilla && !xfalib.ut.Utilities.isIE11() &&
                              this.options.multiLine,
               vAlignBottomOrTop = this.options.paraStyles &&
                                   (this.options.paraStyles["vertical-align"] == "bottom" ||
                                    this.options.paraStyles["vertical-align"] == "top");

           if(flagForMoz && vAlignBottomOrTop || $.browser.msie && this.options.multiLine) {
              return;
           }
           // to handle the edge cases, if the diff is like -0.01 the whole operation is getting aborted
           // this diff comes mainly due to scroll height getting rounded off when widgetHeight is like x.999999
           diff = (diff > -0.01) ? Math.abs(diff) : diff;
           if (this.options.paraStyles && diff > 0) {
                var vAlign = this.options.paraStyles["vertical-align"];
                if (vAlign == "bottom") {
                    diff = diff - this.options.paraStyles["padding-bottom"];
                    this.$userControl.css("padding-top", diff);
                    this.padding = this.$userControl.css("padding-top");
                }
                else if (vAlign == "top" || (vAlign != "middle" && vAlign == undefined)) {
                    if (this.options.paraStyles["padding-top"])
                        diff = diff - this.options.paraStyles["padding-top"];
                    this.$userControl.css("padding-bottom", diff);
                    this.padding = this.$userControl.css("padding-bottom");
                }
                else if (this.options.multiLine && vAlign == "middle") {
                    var newDiff = diff / 2;
                    newDiff = newDiff - this.options.paraStyles["padding-bottom"];
                    if (this.options.paraStyles["padding-top"])
                        newDiff = newDiff + this.options.paraStyles["padding-top"];
                    this.$userControl.css("padding-top", newDiff);
                }
            }
        },

        _handleVAlignOnExit: function (evnt) {

            if (!this.options.paraStyles) {
                //vAlign has to be handled only if there is paraStyles
                return;
            }
            var value = this.options.displayValue,
                lineHeight = xfalib.view.util.TextMetrics.measureExtent(value, {refEl: this.$userControl.get(0), maxHeight: -1}).height,
                widgetHeight = this.options.height,
                diff = widgetHeight - lineHeight;
            this._calculatePaddingForVAlign(diff);

        },

        _handleVAlignOnEnter: function (evnt) {
            //Only align the enabled widgets
            var flagForIE = $.browser.msie && this.options.multiLine;
            if (this.options.paraStyles && !flagForIE) {
                 var vAlign = this.options.paraStyles["vertical-align"];
                 if (vAlign == "bottom" && this.padding)
                     this.$userControl.css("padding-top", this.padding);
                 else if (vAlign == "top" && this.padding)
                     this.$userControl.css("padding-bottom", this.padding);
            }
        },

        _hideError: function () {
            if(this.errObj && _.isFunction(this.errObj.onFieldExit)) {
                this.errObj.onFieldExit(this);
            }
        },

        markError: function (msg, type) {
            if(this.errObj && _.isFunction(this.errObj.markError)) {
                this.errObj.markError(this, msg, type);
            }
        },

        clearError: function () {
            if(this.errObj && _.isFunction(this.errObj.clearError)) {
                this.errObj.clearError(this);
            }
        },

        getEditValue: function(value) {
            if(this.options.editPattern == null) {
                return value;
            }
            try {
                return xfalib.ut.PictureFmt.format(value, this.options.editPattern);
            } catch(e) {
                return null;
            }
        },

        parseEditValue: function(value) {
            if(this.options.editPattern == null) {
                return value;
            }
            try {
                return xfalib.ut.PictureFmt.parse(value, this.options.editPattern);
            } catch(e) {
                return value;
            }
        }
    });
})($);
(function($) {
    $.widget( "xfaWidget.defaultWidget", $.xfaWidget.abstractWidget, {

        _widgetName: "defaultWidget",

        getOptionsMap: function() {
            var parentOptionsMap = $.xfaWidget.abstractWidget.prototype.getOptionsMap.apply(this,arguments);
            return $.extend({},parentOptionsMap,{
                "access": function(val) {
                    switch(val) {
                        case "open" :
                            this.$userControl.removeAttr("readOnly");
                            this.$userControl.removeAttr("aria-readonly");
                            this.$userControl.removeAttr("disabled");
                            this.$userControl.removeAttr("aria-disabled");
                            break;
                        case "nonInteractive" :
                        case "protected" :
                            this.$userControl.attr("disabled", "disabled");
                            this.$userControl.attr("aria-disabled", "true");
                            break;
                        case "readOnly" :
                            this.$userControl.attr("readOnly", "readOnly");
                            this.$userControl.attr("aria-readonly", "true");
                            break;
                        default  :
                            this.$userControl.removeAttr("disabled");
                            this.$userControl.removeAttr("aria-disabled");
                            break;
                    }
                },

                "displayValue": function(val) {
                    if(this.options.commitProperty) {
                        if($.browser.mozilla && this.options.commitProperty == "value") {
                            // on submitting form firefox does not remember autocomplete values, if updated through attr()
                            this.$userControl.val(this._displayEmptyStringForIE(this.options.displayValue));
                        } else {
                            this.$userControl.prop(this.options.commitProperty, this._displayEmptyStringForIE(this.options.displayValue));
                            this.$userControl.attr(this.options.commitProperty, this._displayEmptyStringForIE(this.options.displayValue));
                        }
                    } else {
                        this.logger().debug("xfaView", "[DefaultWidget._update], User Control or Commit Property is null");
                    }
                },

                "placeholder": function(value){
                    this.$userControl.attr("placeholder", value);
                }
            });
        },

        _displayEmptyStringForIE: function(value){
            /*CQ-69417: By default "null" is displayed in the comments text box
              "null" values shown in IE */
            // CQ-69107 included check for edge as well
            return (value == null && xfalib.ut.XfaUtil.prototype.detectIE()) ? '' : value;
        },

        render : function() {
            var control = $.xfaWidget.abstractWidget.prototype.render.apply(this,arguments)
            this._attachEventHandlers(control)
            return control
        },

        getCommitValue: function() {
            var value = this.$userControl.val();
            if(this.options.hScrollDisabled && !this.options.multiLine)
                var value = xfalib.ut.XfaUtil.prototype.splitStringByWidth(this.$userControl.val(),this.$userControl.width(),this.$userControl.get(0)) ;
            return value;
        },

        _attachEventHandlers: function($control) {
            $control.keydown($.proxy(this._handleKeyDown,this));
            $control.keypress($.proxy(this._handleKeyPress,this));
            $control.on('paste',$.proxy(this._handlePaste,this));
            $control.on('cut',$.proxy(this._handleCut,this));
        },

        _compositionUpdateCallback : function (event) {
            return false;
        },

        _attachCompositionEventHandlers : function($control) {
            var isComposing = false; // IME Composing going on
            var hasCompositionJustEnded = false; // Used to swallow keyup event related to compositionend
            // IME specific handling, to handle japanese languages max limit
            // since enter can also be invoked during composing, a special handling is done here
            var that = this,
                changeCaratPosition = function() {
                    // change the carat selection position to further limit input of characters
                    var range = window.getSelection();
                    range.selectAllChildren(that.$userControl[0]);
                    range.collapseToEnd();
                };
            $control.keyup(function(event) {
                if (/*isComposing || */hasCompositionJustEnded) {
                    if (that._compositionUpdateCallback(event)) {
                        changeCaratPosition();
                    }
                    // IME composing fires keydown/keyup events
                    hasCompositionJustEnded = false;
                }
            });
            $control.on("compositionstart",
                function(event) {
                    isComposing = true;
                })
                .on("compositionupdate",
                    function(event) {
                        // event.originalEvent.data refers to the actual content
                        if (that._compositionUpdateCallback(event)) {
                            changeCaratPosition();
                        }
                    })
                .on("compositionend",
                    function(event) {
                        isComposing = false;
                        // some browsers (IE, Firefox, Safari) send a keyup event after
                        //  compositionend, some (Chrome, Edge) don't. This is to swallow
                        // the next keyup event, unless a keydown event happens first
                        hasCompositionJustEnded = true;
                    })
                .on("keydown",
                    function(event) {
                        // Safari on OS X may send a keydown of 229 after compositionend
                        if (event.which !== 229) {
                            hasCompositionJustEnded = false;
                        }
                    });
        },

        _handleKeyDown : function(event){
            if(event.keyCode == 13 || event.charCode == 13 || event.which == 13) // touch devices may return charCode
                event.preventDefault();
        },

        _handleKeyPress : function(event){
            if(event.keyCode == 13 || event.charCode == 13 || event.which == 13) // touch devices may return charCode
                event.preventDefault();
        }
    });
})($);
(function($, _) {
    var xfaUtil = xfalib.ut.XfaUtil.prototype;
    $.widget( "xfaWidget.dateTimeEdit", $.xfaWidget.defaultWidget, {

        _widgetName : "dateTimeEdit",

        getEventMap: function() {
            var parentOptionsMap = $.xfaWidget.defaultWidget.prototype.getEventMap.apply(this,arguments);
            if(this._nativeWidget === false) {
                return $.extend({}, parentOptionsMap, {
                    "onfocus1.datetimepicker": xfalib.ut.XfaUtil.prototype.XFA_ENTER_EVENT,
                    "onvaluechange.datetimepicker": xfalib.ut.XfaUtil.prototype.XFA_CHANGE_EVENT,
                    "onfocusout.datetimepicker": xfalib.ut.XfaUtil.prototype.XFA_EXIT_EVENT,
                    "onoverlap.datetimepicker": xfalib.ut.XfaUtil.prototype.XFA_CLICK_EVENT, // Custom Event to fix BUG #3626974
                    "input": xfalib.ut.XfaUtil.prototype.XFA_CHANGE_EVENT, // TODO : add handler for xfa.event.change
                    "focus": null,
                    "blur": null
                })
            } else {
                return $.extend({}, parentOptionsMap, {
                    "change": xfalib.ut.XfaUtil.prototype.XFA_CHANGE_EVENT
                })
            }
        },

        _getAdobeDatePickerOptionsMap : function(parentOptionsMap) {
            return {
                "access" : function (val) {
                    switch (val) {
                        case "open" :
                            this.$userControl.adobeDateTimePicker("access", true);
                            break;
                        case "nonInteractive" :
                        case "protected" :
                        case "readOnly" :
                            this.$userControl.adobeDateTimePicker("access", false);
                            break;
                    }
                    parentOptionsMap.access.apply(this, arguments);
                },
                "displayValue" : function (val) {
                    // set the value in the datepicker plugin
                    this.$userControl.adobeDateTimePicker("value", this.options.value);
                    // show the display value
                    this.showDisplayValue();
                }
            }
        },

        _getNativeDatePickerOptionsMap: function (parentOptionsMap) {
            return {
                "displayValue": function (val) {
                    this.showDisplayValue();
                }
            }
        },


        getOptionsMap: function() {
            var parentOptionsMap = $.xfaWidget.defaultWidget.prototype.getOptionsMap.apply(this,arguments),
                datePickerOptions = this._nativeWidget === false ? this._getAdobeDatePickerOptionsMap(parentOptionsMap)
                    : this._getNativeDatePickerOptionsMap(parentOptionsMap),
                commonOptions = {
                    "paraStyles": function (paraStyles) {
                        parentOptionsMap.paraStyles.apply(this, arguments);
                        this._handleVAlignOnExit();
                    },

                     "access": function(val) {
                        // update width on change of access (as width of widget is dependent on access)
                        // The calender icon should be hidden, and widget should take full space when readOnly
                        parentOptionsMap.access.apply(this, arguments);
                        this.getOptionsMap().width.apply(this,[this.options.width]);
                      },
                     "width": function (val) {
                        parentOptionsMap.width.apply(this, arguments);
                        if (this.options.showCalendarIcon && val && this.options.access == "open") {
                            var effectiveWidth = val > this.options.calendarIconWidth ? val - this.options.calendarIconWidth : val;
                            this.$userControl.width(effectiveWidth);  // leave space for the cal icon
                        }
                    },

                    "height": function(val) {
                        parentOptionsMap.height.apply(this, arguments);
                        this._handleVAlignOnExit();
                    },
                    "screenReaderText": function (val) {
                        var editPattern = this.options.editPattern;
                        var defaultEditPattern = this._nativeWidget ? "mm/dd/yyyy" : "YYYY-MM-DD";
                        var regex = /(?:date){0,1}{(.*)}/; // date{<pattern>} or {<pattern>} both are valid as per xfa spec
                        editPattern = typeof editPattern === "string" ? editPattern.match(regex)[1] : defaultEditPattern;
                        var defaultLabel = "Please Enter date in {0} format only";
                        if (editPattern) {
                            var ariaLabel = xfalib.ut.LocalizationUtil.prototype.getLocalizedMessage("",
                                xfalib.locale.Strings.datePickerAriaLabel || defaultLabel, [editPattern])
                        }
                        var finalVal = val !== undefined ? val + " " + ariaLabel : val;
                        this.$userControl.attr("aria-label", finalVal);
                    }
                };
            return $.extend({},parentOptionsMap,datePickerOptions, commonOptions);
        },

        postProcessExit: function(evnt) {
            $.xfaWidget.defaultWidget.prototype.postProcessExit.apply(this,arguments);
            this._handleVAlignOnExit ();
        },

        preProcessEnter: function(evnt) {
            $.xfaWidget.defaultWidget.prototype.preProcessEnter.apply(this,arguments);
            this._handleVAlignOnEnter();
        },

        preProcessChange: function(evnt) {
           //CQ-46332:loss of date value in date-picker , setting the value here or else
           //it gets lost during focus
           if(this._nativeWidget === true){
            this.options.value = this.$userControl.val();
           }
        },

        showDisplayValue: function() {
            if(this._nativeWidget === false) {
                $.xfaWidget.defaultWidget.prototype.showDisplayValue.apply(this, arguments);
            } else {
                this.showValue();
            }
        },


        showValue: function () {
            if (this._nativeWidget == false) {
                this.$userControl.adobeDateTimePicker("value", this.options.value);
            } else {
                $.xfaWidget.defaultWidget.prototype.showValue.apply(this, arguments);
            }
            $.xfaWidget.textField.prototype._selectOnFocusInIE.apply(this, arguments);
        },

        getCommitValue: function() {
            if (this._nativeWidget === false) {
                var value = this.$userControl.adobeDateTimePicker("value"),
                    parsedValue = this.parseEditValue(value);
                return parsedValue;
            }
            return $.xfaWidget.defaultWidget.prototype.getCommitValue.apply(this, arguments);
        },

        render: function() {
            var self = this,
                textStyle = this.getOrElse(this.$data(this.element.get(0), "xfamodel"), "textstyle", ""),
                $control = $.xfaWidget.abstractWidget.prototype.render.apply(this, arguments),
                $source = $control,
                id,
                existingInlineStyleAttributeValues,
                newInlineStyleAttributeValues,
                combinedInlineStyleAttributeValues;
            existingInlineStyleAttributeValues = this.element.find("input").attr("style") || '';
            this._nativeWidget = true;
            if(this.options.useNativeWidget === false || $control[0].type !== "date") {
                this._nativeWidget = false;
                id = this.element.find("input")[0].id;
                this.element.children().remove();
                $("<div></div>").css({position: "relative", width: "100%", height: "100%"}) // want to fill entire width of containing table cell
                    .append($("<input type='text'/>"))
                    .appendTo(this.element);
                $control = $("input", this.element).
                    attr("style", textStyle).
                    attr("name", this.options.name).
                    attr("id", id).
                    adobeDateTimePicker({
                        positioning: this.element,
                        locale: {
                            months: this.options.months,
                            days: this.options.days,
                            zero: this.options.zero,
                            clearText: this.options.clearText
                        },
                        access: this.options.access,
                        value: this.options.value,
                        showCalendarIcon: this.options.showCalendarIcon,
                        iconWidth: this.options.calendarIconWidth,
                        minValidDate : this.options.minValidDate,
                        maxValidDate : this.options.maxValidDate,
                        exclMinDate :  this.options.exclMinDate,
                        exclMaxDate : this.options.exclMaxDate,
                        editValue: function (value) {
                            return self.getEditValue(value);
                        }
                    });
            }
            this._attachEventHandlers($control);
            newInlineStyleAttributeValues = this.element.find("input").attr("style") || '';
            //append the previous inlineStyleAttributeValues to newInlineStyleAttributeValues so that the inline styles
            //added from the dialog are applied.
            combinedInlineStyleAttributeValues = newInlineStyleAttributeValues + existingInlineStyleAttributeValues;
            this.element.find("input").attr("style", combinedInlineStyleAttributeValues);
            // only in case of adaptive form, we would copy the attributes back
            if(window.guideBridge) {
                // restore the original attribute back to destination object
                this.copyAttributesFromSrcToDest($source, this.element.find("input"));
            }
            return $control;
        }
    }) ;

})($, _);
(function($) {
$.widget("xfaWidget.numericInput", $.xfaWidget.defaultWidget, {

    _widgetName: "numericInput",

	options : {
		value : null,
		curValue: null,
        pos: 0,
        lengthLimitVisible: true,
        zero:"0",
        decimal:".",
        minus:"-"
	},

    //TODO: to support writing in different locales \d should be replaced by [0-9] for different locales
    _matchArray : {
                    "integer":"^[+-]?{digits}*$",
                    "decimal":"^[+-]?{digits}{leading}({decimal}{digits}{fraction})?$",
                    "float":"^[+-]?{digits}*({decimal}{digits}*)?$"
                  },

    _regex : null,

    _engRegex : null,

    _writtenInLocale : false,

    _previousCompositionVal : "",


    _toLatinForm : function (halfOrFullWidthStr) {
        // refer http://www.fileformat.info/info/unicode/block/halfwidth_and_fullwidth_forms/utf8test.htm
        return halfOrFullWidthStr.replace(
            /[\uff00-\uffef]/g,
            function(ch) { return String.fromCharCode(ch.charCodeAt(0) - 0xfee0); }
        );
    },

    getOptionsMap: function() {
        var parentOptionsMap = $.xfaWidget.defaultWidget.prototype.getOptionsMap.apply(this,arguments);
        return $.extend({},parentOptionsMap,{
            "paraStyles": function(paraStyles){
                parentOptionsMap.paraStyles.apply(this,arguments);
                this._handleVAlignOnExit ();
            } ,

            "height": function(val) {
                if(val)   {
                    this.$css(this.$userControl[0],{"height" :val});
                    this._handleVAlignOnExit();    // To Handle the case of expandable Fields
                }
            }

        })
    },

    getEventMap: function() {
        var parentOptionsMap = $.xfaWidget.defaultWidget.prototype.getEventMap.apply(this,arguments);
        return $.extend({},parentOptionsMap,{
            "onKeyInput.numericInput" : xfalib.ut.XfaUtil.prototype.XFA_CHANGE_EVENT
        })
    },

    _getDigits: function() {
        var zeroCode = this.options.zero.charCodeAt(0),
            digits = "";
        for(var i = 0;i < 10;i++) {
            digits += String.fromCharCode(zeroCode + i);
        }
        return "["+digits+"]"
    },

    _escape: function(str) {
      return str.replace(".","\\.")
    },

    postProcessExit: function(evnt) {
        $.xfaWidget.defaultWidget.prototype.postProcessExit.apply(this,arguments);
        this._handleVAlignOnExit ();
    },

    preProcessEnter: function(evnt) {
        $.xfaWidget.defaultWidget.prototype.preProcessEnter.apply(this,arguments);
        this._handleVAlignOnEnter();
    },

	render : function() {
        var matchStr =  this._matchArray[this.options.dataType];
        if(matchStr) {
            var ld = this.options.leadDigits,
                fd = this.options.fracDigits,
                ldstr = ld && ld != -1 ? "{0,"+ld+"}"
                    : "*",
                fdstr = fd && fd != -1 ? "{0,"+fd+"}"
                    : "*",
                matchStr =  matchStr.replace("{leading}",ldstr)
                                    .replace("{fraction}",fdstr),
                localeStr = matchStr.replace(/{digits}/g,this._getDigits())
                                    .replace("{decimal}",this._escape(this.options.decimal)),
                engStr = matchStr.replace(/{digits}/g,"[0-9]")
                                .replace("{decimal}","\\.")
            this._processValue = !(this._getDigits() == "[0123456789]" && this.options.decimal == ".")
            this._regex = new RegExp(localeStr, "g");
            this._engRegex = new RegExp(engStr, "g");
        }
        return $.xfaWidget.defaultWidget.prototype.render.apply(this, arguments);
    },

    getCommitValue: function() {
        var value = $.xfaWidget.defaultWidget.prototype.getCommitValue.apply(this, arguments);
        // we support full width, half width and locale specific numbers
        value = this._toLatinForm(value);
        if(value.length > 0 && this._processValue && !value.match(this._engRegex)) {
            this._writtenInLocale = true;
            value = this._convertValueFromLocale(value);
        } else {
            this._writtenInLocale = false
        }
        if(value && value.length >= this.options.combCells )
            value = value.slice(0,this.options.combCells);
        this._previousCompositionVal = value;
        return value;
    },

    _compositionUpdateCallback : function (event) {
        var that = this;
        var flag = false;
        var leadDigits = that.options.leadDigits;
        var fracDigits = that.options.fracDigits;
        // we don't check use-case where just fracDigits is set since in case of composition update, the value to update is not known
        if (leadDigits !== -1) {
            var val = that.$userControl.val();
            if (event.type === "compositionupdate" && event.originalEvent.data) {
                val = val + event.originalEvent.data.substr(event.originalEvent.data.length - 1);
            }
            // can't use the existing regex (since current regex checks for english digits), rather doing leadDigit compare
            var totalLength = leadDigits + (fracDigits !== -1 ? (fracDigits + that.options.decimal.length) : 0);
            if (val.indexOf(that.options.decimal) === -1) {
                totalLength = leadDigits;
            }
            var latinVal = this._toLatinForm(val);
            // match both since we support full width, half width and locale specific input
            var match = latinVal.match(that._regex)|| latinVal.match(this._engRegex);
            flag  = !match;
            if (match === null) {
                // entered invalid character, revert to previous value
                that.$userControl.val(that._previousCompositionVal);
                flag = true;
            } else if (flag) {
                // if max reached
                var newVal = val.substr(0, totalLength);
                that.$userControl.val(newVal);
                that._previousCompositionVal = newVal;
                flag = true;
            } else {
                that._previousCompositionVal = val;
            }
        }
        return flag;
    },

    _attachEventHandlers : function($control) {
        $.xfaWidget.defaultWidget.prototype._attachEventHandlers.apply(this, arguments);
        // IME specific handling, to handle japanese languages max limit
        $.xfaWidget.defaultWidget.prototype._attachCompositionEventHandlers.apply(this, arguments);
	},

    _handleKeyInput : function(event, character, code){
        if(event.ctrlKey && !_.contains(['paste', 'cut'], event.type)) {
            return true;
        }

        $.xfaWidget.defaultWidget.prototype._handleKeyDown.apply(this,arguments);
        this.options.lengthLimitVisible = true;

        var val = this.$userControl.prop(this.options.commitProperty) || '',
            // if selectionStart attribute isn't supported then its value will be undefined
            selectionStart = xfalib.view.util.HtmlUtil.getHTMLSupportedAttr(this.$userControl[0], "selectionStart"),
            isSelectionAttrSupported = !(selectionStart === undefined || selectionStart === null),
            selectionStart = selectionStart || 0,
            selectionEnd = xfalib.view.util.HtmlUtil.getHTMLSupportedAttr(this.$userControl[0], "selectionEnd") || 0,
            combCells = parseInt(this.options.combCells) || 0,
            current,
            change = character;

        if (combCells > 0 ) {
            change = character.substr(0, combCells - val.length + selectionEnd - selectionStart);
        }

        // CQ-4245407 : selectionStart and selectionEnd attributes aren't supported in case of input type = number
        // it is used for providing native HTML5 implementation for numeric field, so no further processing is required
        // As it is specific to AF and AF doesn't support change event on each keypress, so this change should be fine
        if (!isSelectionAttrSupported) {
            return true;
        }

        current = val.substr(0, selectionStart) + change + val.substr(selectionEnd);
        // done to handle support for both full width, half width or mixed input in number field
        var latinCurrentValue = this._toLatinForm(current);

        if (!(this._regex == null || latinCurrentValue.match(this._regex) || latinCurrentValue.match(this._engRegex))) {
            event.preventDefault();
            return false;
        }
        if (!_.contains(['keydown', 'cut'], event.type) && combCells && (val.length >= combCells || current.length > combCells) && selectionStart === selectionEnd) {
            event.preventDefault();
            return false;
        }

        this.options.curValue = val;
        this._previousCompositionVal = val;
        this.options.pos = selectionStart;

        if(this.options.hScrollDisabled && !_.contains(['keydown', 'cut'], event.type)) {
            var expectedWidth = xfalib.view.util.TextMetrics.measureExtent(current, {refEl: this.$userControl[0], maxWidth:-1}).width;
            if(!event.ctrlKey && expectedWidth > this.$userControl.width() - 5){
                event.preventDefault();
                this.options.lengthLimitVisible = false;
            }
        }

        this.$userControl.trigger({
            type : "onKeyInput.numericInput",
            originalType : event.type,
            character : character,  // contains the pasted string or pressed key
            keyCode : event.keyCode || 0,
            charCode : event.charCode || 0,
            which : event.which || 0,
            ctrlKey : event.ctrlKey || event.metaKey || false,
            shiftKey : event.shiftKey || false,
            keyDown : false, // This property is available only for list boxes and drop-down lists
            selectionStart: selectionStart,
            selectionEnd: selectionEnd
        });
    },

    _handleKeyDown : function(event){
        if (event) {
            var code = event.charCode || event.which || event.keyCode || 0;
            if(code == 8 || code == 46) // backspace and del
               this._handleKeyInput(event, "", code);
            else if(code == 32) { // suppress space
                event.preventDefault();
                return false;
            }
        }
    },

    _isValidChar: function (character) {
        character = this._toLatinForm(character);
        var lastSingleDigitChar = String.fromCharCode(this.options.zero.charCodeAt(0) + 9);
        // we only full width, half width and also locale specific if customer has overlayed the i18n file
        return (character >= "0" && character <= "9") || (character>=this.options.zero && character<=lastSingleDigitChar) || character===this.options.decimal || character===this.options.minus;
    },

    _handleKeyPress : function(event){
        if (event) {
            var code = event.charCode || event.which || event.keyCode || 0,
                character = String.fromCharCode(code);

            if(xfalib.ut.XfaUtil.prototype.isNonPrintableKey(event.key)) { // mozilla also generates a keypress, along with keydown
                return true;                                               // for all keys, so only handling printable keys in keypress
            }

            if (this._isValidChar(character))
                this._handleKeyInput(event, character, code);
            else if (!event.ctrlKey){
                event.preventDefault();
                return false;
            }
        }
    },

    _handlePaste : function(event){
        if (event) {
            var pastedChar = undefined;
            if (window.clipboardData && window.clipboardData.getData) { // IE
                pastedChar = window.clipboardData.getData('Text');
            } else if (event.originalEvent.clipboardData && event.originalEvent.clipboardData.getData) {
                pastedChar = event.originalEvent.clipboardData.getData('text/plain');
            }

            if(pastedChar) {
                var allPastedCharsValid = _.every(pastedChar.split(''), function (character) {
                    return this._isValidChar(character);
                }, this);
                if (allPastedCharsValid) {
                    // during paste we support both half width, full width and locale specific numbers
                    pastedChar = this._toLatinForm(pastedChar);
                    this._handleKeyInput(event, pastedChar, 0);
                }
                else if (!event.ctrlKey) {
                    event.preventDefault();
                    return false;
                }
            }
        }
    },

    _handleCut : function(event) {
        if (event) {
            this._handleKeyInput(event, "", 0);
        }
    },
    // CQ-107886 : added handling for negative values, as for '-', '-3' was getting returned
    _convertValueToLocale: function(val) {
        var zeroCode = this.options.zero.charCodeAt(0);
        return  _.map(val,function(c) {
            if(c == ".") {
                return this.options.decimal;
            } else if(c == "-") {
                return this.options.minus;
            } else {
                return String.fromCharCode(parseInt(c) + zeroCode);
            }
        },this).join("");
    },

    _convertValueFromLocale: function(val) {
        val = this._toLatinForm(val);
        var zeroCode = this.options.zero.charCodeAt(0);
        return  _.map(val,function(c) {
            if(c == this.options.decimal) {
                return ".";
            } else if(c == this.options.minus) {
                return "-";
            } else {
                return (c.charCodeAt(0) - zeroCode).toString();
            }
        },this).join("");
    },

    showValue : function() {
       // if the value is same, don't do anything
       if(!this._isValueSame()){
           if(this.options.value && this._writtenInLocale) {
               this.$userControl.val(this._convertValueToLocale(this.options.value))
           } else {
               this.$userControl.val(this.options.value)
           }
       }
       //IE doesn't show selected text if we focus and set its value all the time so force selection
       $.xfaWidget.textField.prototype._selectOnFocusInIE.apply(this, arguments);
    }
});
})($);(function ($, _) {
    $.widget("xfaWidget.dropDownList", $.xfaWidget.defaultWidget, {            //commitEvent: change; commitProperty: value<Array>

        _widgetName: "dropDownList",

        options: {
            value: [],
            items: [],
            editable: false,
            placeholder: "",
            displayValue: []
        },

        widgetSkeleton: '<select name="" style="" size = "1"><option id="emptyValue" role="none" value=""></option></select>',
        optionSkeleton: '<option data-user-option></option>',
        optGroupSkeleton: '<optgroup label=""></optgroup>',
        AF_OPTGROUP_NAME: "afOptGroupName",
        PLACE_HOLDER_STYLE_CLASS : "placeHolder",

        getOptionsMap: function () {
            var parentOptionsMap = $.xfaWidget.defaultWidget.prototype.getOptionsMap.apply(this, arguments);
            return $.extend({}, parentOptionsMap, {
                "value": function (val) {
                    if (!_.isArray(val)) {
                        val = [val];
                    }
                    var found = false,
                        that = this;
                    //sync option selection as per new values
                    $("option", this.$userControl).each(function (index) {
                        var selectValue = $(this).val();
                        //Check if this value is present in options value array
                        if (_.contains(val, selectValue)) {
                            $(this).prop("selected", true);
                            found = true;
                        } else {
                            $(this).prop("selected", false);
                            if (this.id === "emptyValue") {
                                $(this).val("").html(that.options.placeholder);
                                //Hiding emptyValue with no placeholder text configured.
                                if(that.options.placeholder.length == 0) {
                                    $(this).hide();
                                }
                            }
                        }
                    });
                    //If no value is found then set the emptyValue to true
                    if (val.length == 0 || val[0] == null) {
                        this.$userControl.children("#emptyValue").prop("selected", true);
                    } else if (!found) {
                        this.$userControl.children("#emptyValue").text(val[0]).
                            prop("selected", true).
                            val(_.escape(val[0])).
                            show();
                    }
                    this.$userControl.toggleClass(this.PLACE_HOLDER_STYLE_CLASS, val.length == 0 || val == null);
                },

                "items": function (val) {
                    if (!_.isArray(val)) {
                        val = [val];
                    }

                    var AF_OPTGROUP_NAME = "afOptGroupName";
                    var i, j, optgroupOptions = [], element, $viewOptgroup, $preOptgroup;
                    var viewOptgroups = $("optgroup", this.$userControl);
                    // Removes all options which earlier didn't belong to any optgroup.
                    if (viewOptgroups.length == 0) {
                        // save selected value because when value is set before items in setWidgetOptions
                        // the selected value would get lost in html
                        var selectedOption = this.$userControl.find('[selected]');
                        this.$userControl.children("option[data-user-option]").remove();
                    }
                    for (i = 0, j = 0; j < val.length; j++) {
                        element = val[j];
                        if (element.save != AF_OPTGROUP_NAME) {
                            // Add options to String[] which will be later synced to the optgroup.
                            optgroupOptions.push(element);
                        } else {
                            $viewOptgroup = viewOptgroups[i++];
                            // When optgroup is less than the required optgroups.
                            if (i > viewOptgroups.length) {
                                $viewOptgroup = this.addGroup(element.display);
                            }
                            // Undefined as it may not occur even once when list is purely of options.
                            if (!_.isUndefined($viewOptgroup) && $viewOptgroup.label != element.display) {
                                $viewOptgroup.label = element.display || '';
                            }
                            // Check to skip the first optgroup.
                            if (j != 0) {
                                // Syncs options to the prev optgroup.
                                // Prev optgroup because current optgroup marks the end of options of prev.
                                this.handleOptions($preOptgroup, optgroupOptions);
                                // Clear options of the optgroup for next optgroup.
                                optgroupOptions = [];
                            }
                            $preOptgroup = $viewOptgroup;
                        }
                    }
                    // Removes all extra optgroups.
                    while (i < viewOptgroups.length) {
                        $viewOptgroup = viewOptgroups[i++];
                        this.deleteGroup($viewOptgroup.label);
                    }
                    //Add remaining options to respective optgroup.
                    if (optgroupOptions.length != 0) {
                        this.handleOptions($preOptgroup, optgroupOptions, selectedOption);
                    }

                    //Intentionally left the selection check -> I am relying on the fact that "value" sync event is called after "items" sync.
                },

                "displayValue": function () {
                },
                "placeholder": function(value){
                    // overriding the default handling of place holder options setter
                },
                "access": function (val) {
                    switch (val) {
                        case "open" :
                            this.$userControl.removeAttr("disabled");
                            this.$userControl.removeAttr("aria-disabled");
                            break;
                        case "nonInteractive" :
                        case "protected" :
                        case "readOnly" :
                            this.$userControl.attr("disabled", "disabled");
                            this.$userControl.attr("aria-disabled", "true");
                            break;
                        default  :
                            this.$userControl.removeAttr("disabled");
                            this.$userControl.removeAttr("aria-disabled");
                            break;
                    }
                }
            })
        },

        getEventMap: function () {
            var parentOptionsMap = $.xfaWidget.defaultWidget.prototype.getEventMap.apply(this, arguments);
            return $.extend({}, parentOptionsMap, {
                "focus": [xfalib.ut.XfaUtil.prototype.XFA_ENTER_EVENT, xfalib.ut.XfaUtil.prototype.XFA_PREOPEN_EVENT],
                "change": xfalib.ut.XfaUtil.prototype.XFA_CHANGE_EVENT
            })
        },

        render: function () {
            var existingInlineStyleAttributeValues = this.element.find("select").attr("style"),
                newInlineStyleAttributeValues,
                combinedInlineStyleAttributeValues,
                size = 1;

            this.element.addClass(this._widgetName);
            this.element.children().remove();

            var inputName = _.uniqueId("select"),  //Unique Id
                textStyle = this.getOrElse(this.$data(this.element.get(0), "xfamodel"), "textstyle", ""),
                $widgetSkeleton = $(this.widgetSkeleton)
                                    .attr('style', textStyle)
                                    .attr('name', inputName);
            if(this.options.editable) {
                $widgetSkeleton.addClass('combobox');
            }

            if(this.options.items && this.options.items.length>0){
                size = this.options.items.length
            }
            if(this.options.multiSelect) {
                $widgetSkeleton.addClass('multiDropdown');
                $widgetSkeleton.attr('multiple','multiple');
                $widgetSkeleton.attr('size',size);
                $widgetSkeleton.attr('data-multiple-selection',"true");
            }

            var $parEl = $widgetSkeleton;
            _.each(this.options.items, function(item){
                var saveItem = _.isString(item.save) ? item.save.replace(/\"/g, "&quot;") : "";
                if (saveItem === this.AF_OPTGROUP_NAME){ // assuming optgroups appear before options
                    $parEl = $(this.optGroupSkeleton).attr('label', item.display).appendTo($widgetSkeleton);
                } else {
                    $(this.optionSkeleton).val(saveItem).text(item.display).appendTo($parEl);
                }
            },this);

            this.element.append($widgetSkeleton);

            var control = this.element.children().eq(0).attr("name", this.options.name);
            this._attachEventHandlers(control);
            newInlineStyleAttributeValues = this.element.find("select").attr("style");
            //append the previous inlineStyleAttributeValues to newInlineStyleAttributeValues so that the inline styles
            //added from the dialog are applied.
            combinedInlineStyleAttributeValues = newInlineStyleAttributeValues + existingInlineStyleAttributeValues;
            this.element.find("select").attr("style", combinedInlineStyleAttributeValues);
            return control;
        },

        //syncs the options to the optgroup dynamically.
        handleOptions : function ($viewOptgroup, val, selectedOption) {
            //When the list so far consists purely of options.
            if (_.isUndefined($viewOptgroup)) {
                $viewOptgroup = this.$userControl[0];
            }
            var viewOptions = $("option[data-user-option]", $viewOptgroup);
            //Syncs the value of options.
            for (var i = 0, j = 0; i < viewOptions.length && j < val.length; i++, j++) {
                var $viewOption = viewOptions[i];
                var element = val[j];
                if ($viewOption.text != element.display) {
                    $viewOption.text = element.display || '';
                }
                if ($viewOption.value != element.save) {
                    $viewOption.value = element.save || '';
                }
            }
            //Deletes options if count is more than required.
            while (i < viewOptions.length) {
                this.deleteOption(viewOptions[i++])
            }
            //Add options if count is less than required.
            while (j < val.length) {
                this.addOption($viewOptgroup, val[j++], selectedOption);
            }
        },

        addOption : function ($viewOptgroup, element, selectedOption) {
            var $newOption = $(this.optionSkeleton).val(element.save).text(element.display);
            $newOption.appendTo($viewOptgroup);
            if(selectedOption) {
                if(element.save === selectedOption.val() && element.display === selectedOption.text()) {
                    $newOption.prop("selected", true);
                }
            }
            // Since the displayValue is a '\n' separated string of selected values in case of multiSelect,
            // we convert it to an array and check whether that array contains the save value of the element
            var values;
            if (this.options.value && _.isString(this.options.value)) {
                values = this.options.value.split('\n');
            } else if (_.isArray(this.options.value)) {
                // In the case of AF we have value/displayValue as an array
                values = this.options.value
            }
            if (values && values.indexOf(element.save) >= 0) {
                //Hide emptyValue and select the new option.
                var $emptyOption = this.$userControl.children("#emptyValue");
                $emptyOption.val("").html(this.options.placeholder).prop("selected", false);
                //Hiding emptyValue with no placeholder text configured.
                if(this.options.placeholder.length == 0) {
                    $emptyOption.hide();
                }
                this.$userControl.children().filter( function() {
                    return this.value==element.save;
                }).prop("selected", true);
            }
        },

        deleteOption: function ($viewOption) {
            this.$userControl.find('option[value='+$viewOption.value+']').remove();
        },

        addGroup: function(label) {
            //Creates a optgroup Node.
            var optionGroup = document.createElement("OPTGROUP");
            optionGroup.label = label;
            this.$userControl[0].appendChild(optionGroup);
            return optionGroup;
        },

        deleteGroup: function(label) {
            this.$userControl.children().remove('optgroup[label='+label+']');
        },

        addItem: function (itemValues) {
            var newOption = new Option(itemValues.sDisplayVal || '', itemValues.sSaveVal || '');
            this.$userControl[0].add(newOption, null);
            // if item has same value as present in options then mark it as selected
            if (_.contains(this.options.value, itemValues.sSaveVal)) {
                this.$userControl.children("#emptyValue").val("").html("").prop("selected", false).hide();
                this.$userControl.find("option[value=" + itemValues.sSaveVal + "]").prop("selected", true)
            }
        },

        clearItems: function () {
            //Deleting all the options including optGroup except the empty value.
            this.$userControl.children().not("#emptyValue").remove();
        },

        deleteItem: function (nIndex) {
            //check for emptyValue instead of blindly doing + 1
            if (this.$userControl[0].item(0) && this.$userControl[0].item(0).id == "emptyValue")
                nIndex = nIndex + 1;
            //if there is emptyValue element then just delete one index higher
            //this check is must instead of blindly increasing the index by 1 because NWKListBox extends this class and that doesn't maintain emptyValue
            this.$userControl[0].remove(nIndex);
        },

        getCommitValue: function (event) {
            var value = $("option:selected", this.$userControl).map(function () {
                return $(this).val();
            }).get();
            return value;
        },

        showDisplayValue: function () {
        },

        destroy: function () {
            this.element.
                removeClass(this._widgetName).
                children().remove().
                text("");

            // call the base destroy function
            $.xfaWidget.defaultWidget.prototype.destroy.apply(this, arguments);
        },

        _handleKeyDown: function (event) {

            if (event.keyCode == 13) {
                //do nothing
                //just override the return key behaviour and over to defaultWidget for rest of the stuff.
                //return key is intercepted to avoid submission of form which is default behavior of html form element
                //but as a side effect it also stops the closing of drop down only in IE -> probably I should use IE condition but
                // this code works fine in          chrome as well so keeping it that way.
                //watson bug#3675141
            }
            else
                $.xfaWidget.defaultWidget.prototype._handleKeyDown.apply(this, arguments);
        },

        // CQ-51462 : focus and commit event (change) happen together hence first selection was modifying the value
        // we do not want focus to modify the value that is about to be committed
        showValue : function() {

        }
    });
})($, _);
(function($){
	$.widget( "xfaWidget.listBox", $.xfaWidget.defaultWidget, {

    _widgetName: "listBoxWidget",

    options : {
        value : [],
        items : [],
        multiSelect : false
    },

    getOptionsMap: function() {
        var parentOptionsMap = $.xfaWidget.defaultWidget.prototype.getOptionsMap.apply(this,arguments);
        return $.extend({},parentOptionsMap,{
            "width" : function(val) {
                //Bug#3597771. setting the height more than 0.95 brings scrollbar
                this.options.width = val*0.95
                parentOptionsMap.width.apply(this,[this.options.width])
            },
            "access" : function() {},
            "value": function(val) {
                var newValues = this.options.value,
                    self = this,
                    tabSet = false;
                if(!_.isArray(newValues))
                    newValues = [newValues];
                var tabSet
                this.$userControl.children().each(function(){
                    var saveVal = $(this).attr("data-save");

                    // Check if this value is present in options value array
                    if(newValues && _.contains(newValues, saveVal)){
                        self._selectListItem($(this));
                        tabSet = true;

                        // Set the selected data attribute to true.
                        if (!$.data(this, "_xfaInitialized")) {
                            //Initialized data- attributes parse for once using this call.
                            // Next onward don't use this. Instead use $.data which is cheap/
                            $(this).data();
                            $.data(this, "_xfaInitialized", true); //Mark the element to say that data has been initialized.
                        }
                        $.data(this, "selected", true);

                    }
                    else{
                        $(this).removeClass("item-selected");
                        $(this).addClass("item-selectable");
                        $(this).attr("tabIndex", "-1");
                    }
                });
                if(!tabSet) {
                    $(this.$userControl.children().get(0)).attr("tabIndex", this.options.tabIndex);
                }
            },

            "items" : function(val) {
                if(!_.isArray(val))
                    val = [val];
                var viewItems = this.$userControl.children();

                //if number of items are not same in model and view then balance it
                if((viewItems.length) > val.length){
                    for(var i=viewItems.length; i >  val.length; i--){
                        this.deleteItem(i-1);
                    }
                }
                else if((viewItems.length) < val.length){
                    for(var i=val.length; i > (viewItems.length); i--){
                        this.addItem({sDisplayVal: val[i-1].display, sSaveVal: val[i-1].save});
                    }
                }

                _.each(val, function(element, index){
                    var $viewItem = $(viewItems[index]);
                    if( $viewItem.text() != element.display){
                        $viewItem.text(element.display || '');
                    }

                    if( $viewItem.attr("data-save") != element.save){
                        $viewItem.attr("data-save", element.save || '');
                    }
                });

                //Intentionally left the selection check -> I am relying on the fact that "value" sync event is called after "items" sync.
            },

            "displayValue" : function(){;},

            "tabIndex": function() {
                var selectedItem = this.$userControl.children(".item-selected"),
                    children =this.$userControl.children()
                if(selectedItem.length) {
                    selectedItem.eq(0).attr("tabIndex", this.options.tabIndex);
                }
                else if(children.length > 0) {
                    children.eq(0).attr("tabIndex", this.options.tabIndex);
                }
            }
        })
    },

    getEventMap: function() {
        var parentOptionsMap = $.xfaWidget.defaultWidget.prototype.getEventMap.apply(this,arguments);
        return $.extend({},parentOptionsMap,{
            "listboxenter":xfalib.ut.XfaUtil.prototype.XFA_ENTER_EVENT,
            "listboxexit":xfalib.ut.XfaUtil.prototype.XFA_EXIT_EVENT,
            "listboxchange":xfalib.ut.XfaUtil.prototype.XFA_CHANGE_EVENT,
            "focus":null,
            "blur":null
        })
    },

    showDisplayValue : function() {
        },

    render : function() {
        this.element.addClass( this._widgetName);
        this.element.children().remove();

        //TODO: add a function for geting textStyle
        var textStyle = this.getOrElse(this.$data(this.element.get(0), "xfamodel"), "textstyle", ""),
            that = this,
            //Bug#3597771 width and height are provided by the view itself.
            listElTemplate =
            '<ol style="position:absolute;<%=textStyle%>" role="listbox">' +
                '<% _.each(items, function(item){ %>' +
                '<% var saveItem = item.save ? item.save.replace(/\"/g,"&quot;"):null %>'+
                    '<li role="option" data-save="<% print(saveItem) %>" data-selected="false"><% print(item.display) %></li>'+
                '<%})%>'+
            '</ol>',
            compiledListElTemplate = _.template(listElTemplate),
            templateOptions = _.extend({
                "textStyle" : textStyle
                }, this.options),
            resolvedListEl = compiledListElTemplate(templateOptions);
        that.element.html(xfalib.ut.XfaUtil.prototype.encodeScriptableTags(resolvedListEl));
        var control = $(that.element.children().get(0)).attr("name",this.options.name);
        this._attachEventHandlers(control);
        return control
    },

    focus: function() {
        if(this.$userControl.children(".item-selected").length > 0) {
            this.$userControl.children(".item-selected")[0].focus();
        }
        else if(this.$userControl.children().length > 0) {
            this.$userControl.children()[0].focus();
        }
    },

    addItem : function(itemValues){
        $("<li></li>")
            .attr("data-save", itemValues.sSaveVal || '')
            .text(itemValues.sDisplayVal || '')
            .appendTo(this.$userControl)
            .click($.proxy(this._handleItemClick, this))
            .focus($.proxy(this._handleItemFocus, this));

        // add new item as selected if the value is already present in options
        if (_.contains(this.options.value, itemValues.sSaveVal)) {
            this._selectListItem(this.$userControl.find("[data-save=" + itemValues.sSaveVal+ "]"));
        }
    },

    clearItems : function(){
        $(this.$userControl).empty();
    },

    deleteItem : function(nIndex){
        $(this.$userControl).children('li').each(function(index,element){
            if(index==nIndex){
                $(element).off("click").off("focus").remove();
            }
        })
    },


    _attachEventHandlers : function($control){
        var self = this;
        $control.keydown($.proxy(this._hotKeys,this))
            .children().on("mousedown",function() {
                    if(self.inFocus == true) {
                        self.mouseDown = true;
                    }
                })
            .click($.proxy(this._handleItemClick, this))
            .focus($.proxy(this._handleItemFocus, this))
            .blur($.proxy(this._handleFocusOut,this))

    },

     _hotKeys : function(event){
         if(this.options.access != "open")
             return;
         if(this.itemInFocus){
             switch(event.which) {
                 case 38: //arrow up
                     var prevSibling = $(this.itemInFocus).prev();
                     if(prevSibling){
                         this.keyDown = true;
                         prevSibling.focus();
                         this.keyDown = false;
                     }
                     event.preventDefault();
                     break;
                 case 40: //arrow down
                     var nextSibling = $(this.itemInFocus).next();
                     if(nextSibling){
                         this.keyDown = true;
                         nextSibling.focus();
                         this.keyDown = false;
                     }
                     event.preventDefault();
                     break;
                 case 91: //left arrow
                 case 92: //right arrow
                     event.preventDefault();
                     break;
                 case 32:
                     this._toggleItem(this.itemInFocus);
                     event.preventDefault();
                     break;
                 default:
             }
         }
     },

     _toggleItem: function(item) {
         var $item = $(item),
             multiMode = this.options.multiSelect, // && event.ctrlKey ;
             that = this;
             //toggle selected state of this item
             this.$data(item, "selected", !this.$data(item, "selected"));
         var state = this.$data(item, "selected")

         if(!multiMode) {
             var $selectedItem = this.$userControl.children(".item-selected")
             if($selectedItem.length) {
                 this.$data($selectedItem[0],"selected",false)
                 $selectedItem.removeClass("item-selected").addClass("item-selectable")
             }
         }
         $item.toggleClass("item-selectable",!state).
               toggleClass("item-selected",state)

         this.$userControl.trigger("listboxchange");
     },

     getCommitValue: function() {
         var that = this,
             multiMode = this.options.multiSelect;


         return this.$userControl.children().map(function(){
             // intentionally using $this.attr("data-save") instead of $this.data("data")
             return that.$data(this, "selected") ? $(this).attr("data-save") : null;
         }).get();
     },

      _handleItemFocus : function(event){
          if(this.options.access != "open")
              return;
          var item = event.target;
          this.itemInFocus = item;

          // overriding default widgets handleFocus
          if(!(this.keyDown || this.mouseDown)) {        //we do not need to fire focus event if
              this.$userControl.trigger("listboxenter")  // clicked on another li element or pressed a key to move the selectio
          }
          this.mouseDown = false;
          this.inFocus = true;
      },

     _handleItemClick : function(event){
        // Bug#3501811 If clicked onlistbox entry more than once, exit event is not fired
        // Clicking on the same entry does not call focus and hence we were not resetting the state. Doing it in onClick
        if(this.mouseDown == true)
            this.mouseDown = false;
        if(this.options.access != "open")
             return;
        this._toggleItem(event.target)
    },

    _handleFocusOut: function(){
        if(!(this.keyDown || this.mouseDown)) {
            this.$userControl.trigger("listboxexit");
            this.inFocus = false
        }
    },

    _selectListItem : function ($elem) {
        if ($elem && $elem.length) {
            $elem.removeClass("item-selectable")
                .addClass("item-selected")
                .attr("tabIndex", this.options.tabIndex);
        }
    },

    destroy: function() {
        this.element.
            removeClass(this._widgetName).
            children().remove().
            text("");

        $.xfaWidget.defaultWidget.prototype.destroy.apply(this, arguments);
    }
});
})($);
(function($) {
    $.widget( "xfaWidget.nwkListBox",  $.xfaWidget.dropDownList, {            //non-webkit listbox

        _widgetName : "nwkListBox",

        options : {
            value : [],
            multiSelect : false
        },

        render : function() {
            var $control = $.xfaWidget.dropDownList.prototype.render.apply(this, arguments);
            if($control){
                $control.children("#emptyValue").remove();
                if(this.options.multiSelect)
                    $control.attr("multiple", "multiple");
            }
            this._updateSelectSize($control);
            return $control;
        },

        addItem : function(itemValues){
            $.xfaWidget.dropDownList.prototype.addItem.apply(this, arguments);
            this._updateSelectSize();
        },

        clearItems : function(){
            $.xfaWidget.dropDownList.prototype.clearItems.apply(this, arguments);
            this._updateSelectSize();
        },

        deleteItem : function(nIndex){
            $.xfaWidget.dropDownList.prototype.deleteItem.apply(this, arguments);
            this._updateSelectSize();
        },

        _updateSelectSize : function($control){
            $control = $control || this.$userControl;
            $control.attr("size", (this.options.items || []).length);
        },

        // Bug#3597771
        // focus and commit event happen together hence first selection was modifying the value
        // we do not want focus to modify the value that is about to be committed
        showValue : function() {

        }

  });
})($);
(function ($) {
    $.widget("xfaWidget.xfaButton", $.xfaWidget.defaultWidget, {            //commitEvent: change; commitProperty: value<Array>

        _widgetName: "xfaButton",

        options: {
            value: null,
            svgCaption: false //option to indicate if button already has an SVG caption
        },

        getOptionsMap: function () {
            var parentOptionsMap = $.xfaWidget.defaultWidget.prototype.getOptionsMap.apply(this, arguments);
            return $.extend({}, parentOptionsMap, {
                "access": function (val) {
                    switch (val) {
                        case "open" :
                            this.$userControl.removeAttr("disabled");
                            this.$userControl.removeAttr("aria-disabled");
                            break;
                        case "nonInteractive" :
                        case "protected" :
                        case "readOnly" :
                            this.$userControl.attr("disabled", "disabled");
                            this.$userControl.attr("aria-disabled", "true");
                            break;
                        default  :
                            this.$userControl.removeAttr("disabled");
                            this.$userControl.removeAttr("aria-disabled");
                            break;
                    }
                },
                "value": function () {
                },
                "displayValue": function () {
                },
                "svgCaption": function (val) {
                    if (val) {
                        this.$userControl.removeAttr("value");
                    }
                }
            })
        },

        _attachEventHandlers: function ($control) {
            $control.click(function () {
                this.focus()
            });
        },

        getCommitValue: function () {
            return this.options.value;
        },

        showValue: function () {
        },

        showDisplayValue: function () {
        }
    });
})($);(function ($) {
    $.widget("xfaWidget.XfaCheckBox", $.xfaWidget.defaultWidget, {            //commitEvent: change; commitProperty: value<Array>

        _widgetName: "XfaCheckBox",

        options: {
            value: null,
            state: -1,
            states: 2,
            values: [],
            mandatory: false
        },

        checkedState: false,
        clickPending: false,

        getOptionsMap: function () {
            var parentOptionsMap = $.xfaWidget.defaultWidget.prototype.getOptionsMap.apply(this, arguments);
            return $.extend({}, parentOptionsMap, {
                "access": function (val) {
                    switch (val) {
                        case "open" :
                            this.$userControl.removeAttr("disabled");
                            this.$userControl.removeAttr("aria-disabled");
                            break;
                        case "nonInteractive" :
                        case "protected" :
                        case "readOnly" :
                            this.$userControl.attr("disabled", "disabled");
                            this.$userControl.attr("aria-disabled", "true");
                            break;
                        default  :
                            this.$userControl.removeAttr("disabled");
                            this.$userControl.removeAttr("aria-disabled");
                            break;
                    }
                },

                "displayValue": function (val) {
                    this.$userControl.attr(this.options.commitProperty, this.options.value);
                    this._state(this.dIndexOf(this.options.values, this.options.value));
                    this.$userControl.attr("checked", this.checkedState ? "checked" : null);
                    this.$userControl.prop("checked", this.checkedState ? "checked" : null);
                    //for accessibility
                    this.$userControl.attr("aria-checked", this.checkedState);
                    if (this.options.state == 2)
                        this.$userControl.addClass("neutral");
                    else if (this.options.states == 3)
                        this.$userControl.removeClass("neutral");   // since current state != neutral
                },

                "allowNeutral": function (val) {
                    var intVal = parseInt(val);
                    if (intVal == 0 || intVal == 1) {
                        this.options.states = 2 + intVal;
                    }
                },

                "paraStyles": function (paraStyles) {
                    parentOptionsMap.paraStyles.apply(this, arguments);
                    this._handleVAlignOnExit();
                }
            })
        },

        getEventMap: function () {
            var parentOptionsMap = $.xfaWidget.defaultWidget.prototype.getEventMap.apply(this, arguments);
            return $.extend({}, parentOptionsMap, {
                 "xfacheckboxchange" :  xfalib.ut.XfaUtil.prototype.XFA_CHANGE_EVENT,
                 "xfacheckboxclick" :   xfalib.ut.XfaUtil.prototype.XFA_CLICK_EVENT,
                 "change": null,
                 "click" : null
               })
        },

        _attachEventHandlers: function ($control) {
            var that = this;
            var focusFunc = function (evnt) {
                if (!that.inFocus) {
                    that.focus();
                    that.inFocus = true;
                }
            }
            var focusOutFunc = function (evnt) {
                that.inFocus = false;
            }
            $control.click(focusFunc).change(focusFunc).blur(focusOutFunc);
            $control.change($.proxy(this._handleChange,this)).click($.proxy(this._handleClick,this));   //LC-5106
        },

        getCommitValue: function () {
            this._state((this.options.state + 1) % this.options.states);
            this.$userControl.attr("checked", this.checkedState ? "checked" : null);
            //for accessibility
            this.$userControl.attr("aria-checked", this.checkedState)
            if (this.options.state == 2) {
                this.$userControl.addClass("neutral");
            }
            else if (this.options.states == 3)
                this.$userControl.removeClass("neutral"); // since current state != neutral

            return this.options.values[this.options.state];
        },

        _handleVAlignOnExit: function (evnt) {
            //--this is being kept empty as no other browser (i.e Mozilla and Chrome) take the padding-bottom or padding-top into account.
            // the only browser to take it into consideration is IE. And moreover the alignment and padding considerations have already been taken into account in
            // calculations in CheckButtonFieldView.js. And on removing the entire function it takes up the _handleVAlignOnExit() of AbstractWidget.

        },

        _handleChange: function (evnt) {
            this.$userControl.trigger("xfacheckboxchange"); //change is always fired
            if(this.clickPending === true) {
              this.clickPending = false;
              this.$userControl.trigger("xfacheckboxclick");
            } else {
                // handling of this.clickPending is added to handle the case when clicked on checkbox/radiobutton label/caption
                this.clickPending = true;
            }
        },

        _handleClick: function (evnt) {
             var isChrome = xfalib.ut.XfaUtil.prototype.detectChrome(),
                 isIE = xfalib.ut.XfaUtil.prototype.detectIE(),
                 isSafari = xfalib.ut.XfaUtil.prototype.isSafari(),
                 userControlType = this.$userControl.attr("type");
             // click will not be fired if the previous state of the radiobutton is 'on'.
             // NPR-35652 : Checkbox movement - Click event works fine on chrome but not in iOS safari for collapsible fields
             // CQ-103023 : Click Event on Radio Button not working correctly in Chrome 53
             // CQ-103715 : CQ-103715 : Click Event on Check Box not working correctly in Chrome and Firefox, added handling for checkbox also
             // handling of this.clickPending is added to handle the case when clicked on checkbox/radiobutton label/caption
             if(($.browser.mozilla || isChrome || isSafari) && !isIE && this.clickPending === false && ((userControlType === "radio" && this.checkedState === false) || (userControlType === "checkbox"))) {
               this.clickPending = true;
             }
             else {
                this.$userControl.trigger("xfacheckboxclick");
                this.clickPending = false;
             }
        },

        _state: function (newState) {
            if (newState == undefined)
                return this.options.state;
            else
                this.options.state = newState;
            this.checkedState = (newState == 0 || newState == 2);
        },

        click: function () {
            // trigger change for check box and for radio only if it is not selected
            // otherwise radio button will go in deselected state
            if (this.$userControl.attr("type") !== "radio" || this.options.state !== 0) {
                this.$userControl.trigger("change");
            }
            //we should call only the handler since calling click will trigger change.
            this.$userControl.triggerHandler("click");
        }
    });
})($);
(function($){
    $.widget( "xfaWidget.textField", $.xfaWidget.defaultWidget, {

        _widgetName: "textField",

        options: {
            curValue : null ,
            pos:0,
            lengthLimitVisible: true,
            maxChars:0 ,
            flag:"",
            // by default html5Type is set to true
            // we leverage pattern, maxLength support from HTML5 browser for mobile forms
            html5Type : "text",
            length : null,
            minLength : 0,
            totalLengthMessage : "",
            minimumLengthMessage : "",
        },

        getOptionsMap: function() {
            var parentOptionsMap = $.xfaWidget.defaultWidget.prototype.getOptionsMap.apply(this,arguments);
            return $.extend({},parentOptionsMap,{
                "maxChars": function(maxchars) {
                    if(this._maxCharsReached(this.options.value)) {
                        var value = this.options.value.slice(0,maxchars)
                        this._setOption("value", value);
                        this._setOption("displayValue", value);
                    }

                },

                "multiLine ": function(val) {
                    if(this.options.multiLine)
                        this.$userControl.attr("aria-multiline", "true");
                    else
                        this.$userControl.removeAttr("aria-multiline", "false");
                },

                "height": function(val) {
                    if(val)   {
                        this.$css(this.$userControl[0],{"height" :val})
                        this._handleVAlignOnExit();    // To Handle the case of expandable Fields
                    }
                },
                "width": function(val){
                    parentOptionsMap.width.apply(this,arguments);
                    // handle valign on width change as well
                    // as content height(scrollHeight) varies according to width
                    this._handleVAlignOnExit();
                },
                "paraStyles": function(paraStyles){
                    parentOptionsMap.paraStyles.apply(this,arguments);
                    this._handleVAlignOnExit();
                }

            })
        },

        render : function() {
            var control = $.xfaWidget.defaultWidget.prototype.render.apply(this, arguments);
            // use the control to set HTML5 attributes
            if (control && control.length > 0 && this.options.html5Type) {
                var minLength = this.options.minLength,
                    maxLength = this.options.maxChars,
                    length = this.options.length;
                    isMinLengthSet = minLength != null && minLength > 0,
                    isMaxLengthSet = maxLength != null && maxLength > 0,
                    isLengthSet = length != null && length > 0,
                    isMultiline = this.options.multiLine,
                    minLengthMsg = this.options.minimumLengthMessage,
                    totLengthMsg = this.options.totalLengthMessage,
                    pattern = ""; // html5 pattern is not supported for textarea

                // order of execution matters for the below code snippet
                if (isMinLengthSet) {
                    // add minLength though it is not fully supported in all browsers
                    // hence also adding pattern attribute
                    control.attr("minlength", parseInt(minLength));
                    if(minLengthMsg && minLengthMsg.length > 0) {
                        control.attr("title", this.options.minimumLengthMessage); // html5 supported message on pattern validation failure
                    }
                }

                if (isMaxLengthSet) {
                    control.attr("maxlength", parseInt(maxLength));
                }

                // if both min and max length is set
                if(isMinLengthSet && isMaxLengthSet){
                    pattern += ".{" + minLength + "," + maxLength + "}";
                } else if(isMinLengthSet) {
                    // if only min length set
                    pattern += ".{" + minLength + ",}";
                }

                // if length is set then set min and max length in pattern equal to length
                if (isLengthSet) {
                    if(isMultiline){ // set both min and maxlength as pattern is not supported
                        control.attr("minlength", parseInt(length));
                        control.attr("maxlength", parseInt(length));
                    }
                    if(totLengthMsg && totLengthMsg.length > 0) {
                        control.attr("title", this.options.totalLengthMessage);
                    }
                    // reset the pattern string
                    pattern = ".{" + length + "," + length + "}";
                }
                // if required is set, set the required attribute, it is necessary else an empty value will be excluded from constraint validation
                if (this.options.required) {
                    control.attr("required", true);
                }
                // set the pattern if not empty and check if this is not multiline, since pattern is not supported for textarea
                if (pattern && pattern.length > 0 && !isMultiline) {
                    control.attr("pattern", pattern);
                }
            }
            return control;
        },

        /*  This function aligns vAlign when:
         1. parastyles is present and the widget contains a value.
         2. During initial rendering if no content present fallback to the previous logic.
         3. Presence of content in widget.
        */
        _handleVAlignOnExit: function(){
             var value = this.options.displayValue,
                 noContentPresent = _.isEmpty(this.$userControl.val() || this.options.displayValue),
                 contentHeight,widgetHeight,diff,tempCSS;

             //the widget doesn't have value as yet but content exists [ Rendering of widget]
             if (!this.options.paraStyles || noContentPresent) {
                //vAlign has to be handled only if there is paraStyles and widget has content
                return;
             }

             // mozilla results in vAlign regression hence made this change only for textarea
             if($(this.element[0]).find("textarea").length >0 && !noContentPresent)  {
               /* measureExtent not returning correct height of content in textarea even with all
                 css values */
               tempCSS={'height':this.$userControl.css('height'),'padding':this.$userControl.css('padding')};
               this.$css(this.$userControl[0],{'height':'1px','padding':'0px'});

               contentHeight = this._getContentHeight();
               this.$css(this.$userControl[0],tempCSS);
               widgetHeight = this.options.height;
               diff = widgetHeight - contentHeight;
               this._calculatePaddingForVAlign(diff);
             } else {
                // widget has no initial content or is a textfield.Proceed as before.
                $.xfaWidget.defaultWidget.prototype._handleVAlignOnExit.apply(this,arguments);
             }
        },

        getEventMap: function() {
            var parentOptionsMap = $.xfaWidget.defaultWidget.prototype.getEventMap.apply(this,arguments);
            return $.extend({},parentOptionsMap,{
                "onKeyInput.textField" : xfalib.ut.XfaUtil.prototype.XFA_CHANGE_EVENT
            })
        },

        _maxCharsReached: function(val) {
            var isMaxLengthSupported = false,
                elementName = this.options.multiLine ? "textarea" : "input";
            // in browsers, where max length is supported, we don't custom javascript checks, we let HTML do the validation of max length
            if(this.options.html5Type && xfalib.view.util.HtmlUtil.elementSupportsAttribute(elementName, "maxLength")){
                isMaxLengthSupported = true;
            }
            return !isMaxLengthSupported && this.options.maxChars
                   && this.options.maxChars!=="0"
                   && val
                   &&  val.length >= this.options.maxChars
        },

        _handleKeyInput : function(event, character, code) {
            if(event.ctrlKey && !_.contains(['paste', 'cut'], event.type)) {
                return true;
            }

            if(!this.options.multiLine) {
                $.xfaWidget.defaultWidget.prototype._handleKeyDown.apply(this, arguments);
                character = (code == 13) ? '' : character ;
            }

            var val =  this.$userControl.val(),
                selectionStart = xfalib.view.util.HtmlUtil.getHTMLSupportedAttr(this.$userControl[0], "selectionStart") || 0,
                selectionEnd = xfalib.view.util.HtmlUtil.getHTMLSupportedAttr(this.$userControl[0], "selectionEnd") || 0,
                pos = selectionStart,
                // CQ-4260239 : "&nbsp" taking space of 5 chars for restricting the length to visible area
                newVal = (val.substr(0, selectionStart) + character + val.substr(selectionEnd));
            this.options.curValue = val;
            if(!this.options.multiLine) { //TODO:looks like a bug
                this.options.lengthLimitVisible = true;
                this.options.pos = pos;
                if(this.options.hScrollDisabled && !_.contains(['keydown', 'cut'], event.type)) {
                    var expectedWidth = xfalib.view.util.TextMetrics.measureExtent(newVal, {refEl: this.$userControl[0], maxWidth:-1}).width;
                    if(!event.ctrlKey && expectedWidth > this.$userControl.width()){   // Why  allowance of 5 required??
                        this.options.lengthLimitVisible = false;
                        event.preventDefault();
                        return false;
                    }
                }
            } else if (this.options.multiLine && this.options.hScrollDisabled) {  // LC-4656 : wait till user input, if it causes an overflow revert to old text
                var $textArea = this.$userControl;
                $textArea.css("padding", "0px 0px 0px");  // TODO : take care of multiline selection & padding later

                // TODO : find a scheme to avoid attaching and detaching listeners, currently $.val() causes 'input' to fire, resulting in an infinite loop
                $textArea.one("input", function () {
                    if ($textArea.prop('scrollHeight') > $textArea.prop('offsetHeight')) {
                        $textArea.val(val)
                                 .prop("selectionStart", selectionEnd)
                                 .prop("selectionEnd", selectionEnd);  // LC-4656 : reset the cursor pos, afterwards
                        character = null;
                        code = 0;
                    }
                });
            }

            if (!_.contains(['keydown', 'cut'], event.type) && this._maxCharsReached(val) && selectionStart === selectionEnd) {
                event.preventDefault();
                return false;
            }

            this.$userControl.trigger({
                type : "onKeyInput.textField",
                originalType : event.type,
                character : character,  // contains the pasted string or pressed key
                keyCode : event.keyCode || 0,
                charCode : event.charCode || 0,
                which : event.which || 0,
                ctrlKey : event.ctrlKey || event.metaKey || false,
                shiftKey : event.shiftKey || false,
                keyDown: false, // This property is available only for list boxes and drop-down lists
                selectionStart: selectionStart,
                selectionEnd: selectionEnd
            });
        },

        _handleKeyDown : function(event){
            if (event) {
                var code = event.charCode || event.which || event.keyCode || 0;
                if(code == 8 || code == 46) // backspace and del
                   this._handleKeyInput(event, "", code);
            }
        },

        _handleKeyPress : function(event){
            if (event) {
                var code = event.charCode || event.which || event.keyCode || 0,
                    character = (code == 13) ? "\n" : String.fromCharCode(code); // modified '\r\n' -> '\n'

            if(xfalib.ut.XfaUtil.prototype.isNonPrintableKey(event.key)) { // mozilla also generates a keypress, along with keydown
                return true;                                               // for all keys, so only handling printable keys in keypress
            }

            this._handleKeyInput(event, character, code);
            }
        },

        _compositionUpdateCallback : function (event) {
            var that = this;
            var val = that.$userControl.val();
            if (event.type === "compositionupdate" && event.originalEvent.data) {
                val = val + event.originalEvent.data.substr(event.originalEvent.data.length - 1);
            }
            var flag = that._maxCharsReached(val);
            if (flag) {
                // if max reached
                var newVal = val.substr(0, that.options.maxChars);
                that.$userControl.val(newVal);
            }
            return flag;
        },

        _attachEventHandlers: function($control) {
            $.xfaWidget.defaultWidget.prototype._attachEventHandlers.apply(this, arguments);
            // IME specific handling, to handle japanese languages max limit
            $.xfaWidget.defaultWidget.prototype._attachCompositionEventHandlers.apply(this, arguments);
        },

        _handlePaste : function(event){
            if (event) {
                var pastedChar = undefined;
                if (window.clipboardData && window.clipboardData.getData) { // IE
                    pastedChar = window.clipboardData.getData('Text');
                } else if (event.originalEvent.clipboardData && event.originalEvent.clipboardData.getData) {
                    pastedChar = event.originalEvent.clipboardData.getData('text/plain');
                }
                if(pastedChar) {
                    this._handleKeyInput(event, pastedChar, 0);
                }
            }
        },

        _handleCut : function(event) {
            if (event) {
                this._handleKeyInput(event, "", 0);
            }
        },

        postProcessExit: function(evnt) {
            $.xfaWidget.defaultWidget.prototype.postProcessExit.apply(this,arguments);
            if (this.options.multiLine && this.options.hScrollDisabled) {
                return;
            }
            this._handleVAlignOnExit();
        },

        preProcessEnter: function(evnt) {
            $.xfaWidget.defaultWidget.prototype.preProcessEnter.apply(this,arguments);
            if(this.options.multiLine && this.options.hScrollDisabled)
                return;
            this._handleVAlignOnEnter();
        },

        /**
         * @brief: Select the given field on focus in Internet Explorer
         *
         */
        _selectOnFocusInIE : function(){
            // if the value is not same only then do selection in IE
            // For Issue: LC-9895, we check if value not same
            if($.browser.msie && !this._isValueSame()) {
                this.$userControl.select();
            }
            else {
                //all other browsers behave like a good boy
            }
        },

        showValue : function() {
            $.xfaWidget.defaultWidget.prototype.showValue.apply(this,arguments);
            //IE doesn't show selected text if we focus and set its value all the time so force selection
            this._selectOnFocusInIE();
        },

        getCommitValue: function() {
            var value = $.xfaWidget.defaultWidget.prototype.getCommitValue.apply(this, arguments);

            if(this._maxCharsReached(value)) {
                value = value.slice(0,this.options.maxChars);
            }

            this.$userControl.val(this.options.value);

            //TODO: ask Sharad whether it is right
            if(this.options.multiLine && this.options.hScrollDisabled)  {
                //var str= this._checkLines(value);
                //if(value != str) {
                    return value;
                //}
            }
            return value;
        },

        /*
        ** returns the contentHeight which needs to be considered for padding for valign,
        ** if no contentHeight is present then fontSize is returned.
        */
        _getContentHeight: function () {
            var contentHeight = Math.ceil(this.$userControl.get(0).scrollHeight);
            return contentHeight ? contentHeight : this.options.fontSize;
        }
    });
})($);
/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * __________________
 *
 *  Copyright 2019 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

(function ($) {
    $.widget("xfaWidget.richTextField", $.xfaWidget.textField, {

        _widgetName : "richTextField",

        _richTextWidget : null,

        _changeAccess : function (val) {
            switch (val) {
                case "open":
                    if (this._richTextWidget) {
                        this._richTextWidget.editor.enable();
                        this._richTextWidget.$toolbar.removeClass("hideToolbar");
                    }
                    break;
                case "readOnly":
                    if (this._richTextWidget) {
                        this._richTextWidget.editor.disable();
                        this._richTextWidget.$toolbar.addClass("hideToolbar");
                    }
                    break;
            }
        },

        getOptionsMap : function () {
            var parentOptionsMap = $.xfaWidget.textField.prototype.getOptionsMap.apply(this, arguments);
            return $.extend({}, parentOptionsMap, {
                "value" : function (val) {
                    if (this._richTextWidget) {
                        this._richTextWidget.setRichTextEditorContent(val);
                    }
                },
                "access" : function (val) {
                    this._changeAccess(val);
                }
            });
        },

        getEventMap : function () {
            // in case of IE browsers, focus event is delayed, hence adding activate method for content editable
            if (xfalib.ut.XfaUtil.prototype.isIE()) {
                var parentOptionsMap = $.xfaWidget.textField.prototype.getEventMap.apply(this, arguments);
                return $.extend({}, parentOptionsMap, {
                    "activate.richTextField" : xfalib.ut.XfaUtil.prototype.XFA_ENTER_EVENT
                });
            } else {
                return $.xfaWidget.textField.prototype.getEventMap.apply(this, arguments);
            }
        },

        render : function () {
            var $richTextWidget = this.element.find("div.richTextWidget").eq(0);
            if(!$richTextWidget.length){
                var attachedTextareaClasses = this.element.children().attr('class');
                var richTextWidgetElement = '<div class="richTextWidget ' + attachedTextareaClasses + '" id="richTextField_' + this.options.name + '_' + attachedTextareaClasses + '"></div>';
                this.element.children().remove();
                this.element.append(richTextWidgetElement);
                $richTextWidget = this.element.find("div.richTextWidget").eq(0);
            }else{
                $richTextWidget.children().remove();
            }
            $richTextWidget.append(this.options.value);
            return $.xfaWidget.defaultWidget.prototype.render.apply(this, arguments);
        },

        getCommitValue : function () {
            var value = "";
            if (this._richTextWidget) {
                value = this._richTextWidget.getRichTextEditorContent();
            }
            return value;
        },

        preProcessEnter : function (evnt) {
            $.xfaWidget.textField.prototype.preProcessEnter.apply(this, arguments);
            var $richTextDiv = this.$userControl.find("div.richTextWidget").eq(0);
            if(!$richTextDiv.length){
                $richTextDiv = this.element.find("div.richTextWidget").eq(0);
                this.changeDefaultToolbarConfig();
                this.$userControl.parents('.richtextsupport').css('z-index', 'auto');
            }
            if (window.Form === undefined || window.Form.rte === undefined) {
                /* Forms RTE is part of Forms Addon package only. Dont do anything if addon is not installed.*/
                return;
            } else if (this._richTextWidget === null) {
                this._initializeRTEToolbar();
                this._richTextWidget = new window.Form.rte.RichTextEditor({
                    selector : $richTextDiv.attr("id"),
                    toolbar : window.Form.rte.RichTextEditor.MFToolbar,
                    data : this.options.value,
                    locale : $richTextDiv.data("locale")
                });
                var that = this;
                this._richTextWidget.editor.on("blur:composer", function () {
                    that.$userControl.trigger("blur");
                });
                // initialize the access
                if (this.options.access) {
                    this._changeAccess(this.options.access);
                }
            }
        },

        changeDefaultToolbarConfig: function(){
            if(window.Form && window.Form.rte){
                var toolbarDefaultConfigData = window.Form.rte.DefaultConfig;
                toolbarDefaultConfigData.fontSize.defaultValue = this.options.fontSize;
                toolbarDefaultConfigData.fontFamily.defaultValue = this.options.fontFamily;

                // Adding 'isFontInPx' flag and overriding two utility functions
                // 'getDefaultParaStyle' and 'getMissingParaStyle' are responsible for adding RTE font styling attributes to rich text elements
                toolbarDefaultConfigData.isFontInPx = true;
                this.changeDefaultParaStyleUtility();
                this.changeMissingParaStyleUtility();

                // Adding dropdown values in default config if not available in options
                if(toolbarDefaultConfigData.fontSize.options.indexOf(this.options.fontSize) === -1){
                    toolbarDefaultConfigData.fontSize.options.push(this.options.fontSize);
                }
                if(toolbarDefaultConfigData.fontFamily.options.indexOf(this.options.fontFamily) === -1){
                    toolbarDefaultConfigData.fontFamily.options.push(this.options.fontFamily);
                }
            }
        },

        changeDefaultParaStyleUtility: function(){
            Form.rte.util.HtmlUtils.getDefaultParaStyle = function (config) {
                var style = "";
                if (config) {
                    style += 'font-family:' + config.fontFamily.defaultValue + ';';
                    if(config.isFontInPx){
                        style += 'font-size:' + config.fontSize.defaultValue + 'px;';
                        style += 'letter-spacing:' + config.letterSpacing.defaultValue + 'px;';
                    }else{
                        style += 'font-size:' + config.fontSize.defaultValue + 'pt;';
                        style += 'letter-spacing:' + config.letterSpacing.defaultValue + 'pt;';
                    }
                    style += 'color:#000000;';
                    style += 'text-align:left;';
                }

                return style;
            };
        },

        changeMissingParaStyleUtility : function(){
            Form.rte.util.HtmlUtils.getMissingParaStyle = function (style, config) {
                if (style && style.length > 0) {
                    if (config) {
                        if (!Form.rte.util.StringHelper.endsWith(style, ";")) {
                            style += ";";
                        }
                        if (style.indexOf("font-family") < 0) {
                            style += 'font-family:' + config.fontFamily.defaultValue + ';';
                        }
                        if (style.indexOf("font-size") < 0) {
                            if(config.isFontInPx){
                                style += 'font-size:' + config.fontSize.defaultValue + 'px;';
                            }else{
                                style += 'font-size:' + config.fontSize.defaultValue + 'pt;';
                            }
                        }
                        if (style.indexOf("letter-spacing") < 0) {
                            if(config.isFontInPx){
                                style += 'letter-spacing:' + config.letterSpacing.defaultValue + 'px;';
                            }else{
                                style += 'letter-spacing:' + config.letterSpacing.defaultValue + 'pt;';
                            }
                        }
                        if (style.indexOf("color") < 0) {
                            style += 'color:#000000;';
                        }
                        if (style.indexOf("text-align") < 0) {
                            style += 'text-align:left;';
                        }
                    }
                } else {
                    style = Form.rte.util.HtmlUtils.getDefaultParaStyle(config);
                }
                return style;
            };
        },

        _initializeRTEToolbar : function () {
            window.Form.rte.RichTextEditor.MFToolbar = window.Form.rte.RichTextEditor.MFToolbar || {
                defaultMode : 'basic',
                toolbars : {
                    basic : {
                        layout : [
                            {
                                items : [Form.rte.Commands.HEADER]
                            },
                            {
                                items : [Form.rte.Commands.BOLD, Form.rte.Commands.ITALIC, Form.rte.Commands.UNDERLINE]
                            },
                            {
                                command : 'lists',
                                icon : 'list',
                                title : "List Type",
                                type : 'popover',
                                placement : 'bottom',
                                items : [Form.rte.Commands.INSERT_UNORDERED_LIST,
                                    Form.rte.Commands.INSERT_ORDERED_LIST,
                                    Form.rte.Commands.INSERT_LOWERCASE_ALPHABET_LIST]
                            },
                            {
                                title : 'Expand',
                                command : Form.rte.Commands.MODE,
                                value : Form.rte.ToolbarMode.FULL,
                                icon : 'resize-full'
                            }
                        ],
                        floating : true
                    },
                    full : {
                        layout : [
                            {
                                items : [Form.rte.Commands.BOLD, Form.rte.Commands.ITALIC, Form.rte.Commands.UNDERLINE]
                            },
                            {
                                items : [Form.rte.Commands.SUPERSCRIPT, Form.rte.Commands.SUBSCRIPT]
                            },
                            {
                                items : [
                                    Form.rte.Commands.HEADER, Form.rte.Commands.FONT_FAMILY, Form.rte.Commands.LINE_HEIGHT, Form.rte.Commands.FORE_COLOR, Form.rte.Commands.HILITE_COLOR, Form.rte.Commands.LINK
                                ]
                            },
                            {
                                items : [Form.rte.Commands.INSERT_UNORDERED_LIST, Form.rte.Commands.INSERT_ORDERED_LIST, Form.rte.Commands.INSERT_LOWERCASE_ALPHABET_LIST
                                ]
                            },
                            {
                                title : 'Collapse',
                                command : Form.rte.Commands.MODE,
                                value : Form.rte.ToolbarMode.BASIC,
                                icon : 'resize-small',
                                selected : true
                            }
                        ]
                    }
                }
            };
        }
    });

})($);(function($){
	$.widget( "xfaWidget.imageField", $.xfaWidget.defaultWidget, {

    _widgetName:"imageField",

    options: {
        tabIndex: 0,
        "role": "img"
    },

    getEventMap: function () {
        var parentOptionsMap = $.xfaWidget.defaultWidget.prototype.getEventMap.apply(this, arguments);
        return $.extend({}, parentOptionsMap, {
            "imagechange": xfalib.ut.XfaUtil.prototype.XFA_CHANGE_EVENT
        })
    },

    getOptionsMap: function() {
        var parentOptionsMap = $.xfaWidget.defaultWidget.prototype.getOptionsMap.apply(this,arguments);
        return $.extend({},parentOptionsMap,{
            "screenReaderText": function(val) {
                if(val)
                    this.$userControl.attr("alt", val)
            },
            "displayValue": function(val) {
                var widgetValue;
                if (this.options.value) {
                    widgetValue = "data:;base64," + this.options.value;
                } else {
                    widgetValue = "";
                }
                this.$userControl.prop(this.options.commitProperty, widgetValue);
                this.$userControl.attr(this.options.commitProperty, widgetValue);
            },
            "access" : function() {},

            // CQ-85514 : use max-ht & max-wd to honor image's intrinsic ht & wd attributes & prevent distortion
            "height" : function (val) {
                // in case aspect is actual then we need to crop the image, which will be not possible if max height and width are set
                if (val && this.options.aspect != "actual") {
                    this.$css(this.$userControl[0], {"max-height": val});
                }
            },
            "width" : function (val) {
                if (val && this.options.aspect != "actual") {
                    this.$css(this.$userControl[0], {"max-width": val});
                }
            },
            "aspect" : function (val) {
                // value of actual turns off scaling, causing the image to be drawn at its native size,
                // as per xfa spec Adobe implementations crop the image
                if(this.options.aspect == "actual") {
                    var right = this.$userControl.attr("width"),
                        bottom = this.$userControl.attr("height");
                    right = right.indexOf("px") >= 0 ? right : right + "px";
                    bottom = bottom.indexOf("px") >= 0 ? bottom : bottom + "px";
                    this._cropImage("0px", right, bottom, "0px");
                    this.$userControl.removeAttr("height width");
                // value of none indicates no aspect ratio
                // as per xfa spec image is independently scaled in the horizontal and vertical directions to exactly fill the field,
                // which are already set to fill the field
                } else if (this.options.aspect != "none") {
                // A value of fit, which is the default, causes the scale to be such that the image fills as much of the field as possible
                // without overflowing it in either dimension.
                    this.$userControl.attr({"height" : "auto", "width" : "auto"});
                }
            }
        });
    },

    // crop the image using top,right, bottom, left coordiantes of the image
    _cropImage : function (top, right, bottom, left) {
        var clipRect = "rect(" + top + "," + right + "," + bottom + "," + left + ")";
        var clipPathPolygon = "polygon( 0px 0px, 0px " + bottom + "," + right + " " + bottom +"," + right + " 0px)";
        // clip property is deprecated but still supported by all the major browsers
        // clip-path replaces the deprecated clip property but still is not fully supported by all major browser
        this.$userControl.css({"clip" : clipRect, "clip-path" : clipPathPolygon});
    },

    render : function() {
        var self = this;
        if (typeof FileReader !== "undefined") {
            this.reader = new FileReader();
        } else {
            xfalib.ut.XfaUtil.prototype.getLogger().error("Image Field is supported only for HTML5 supported browsers.");
        }
        if (this.element) {
            // change event triggered when new image is selected
            this.$widgetInput = this.element.find("input").on("change.imageField", function() {
                self._handleInputChange();
            }).click(function(event) {
                // to stop bubbling of event from input to widget
                event.stopPropagation();
            });
            this.$widgetImg = this.element.on("click.imageField", function() {
                self._imageClick();
            }).find("img");
        }
        if (this.reader) {
            //load event is triggered each time the reading operation is successfully completed
            this.reader.addEventListener("load", function () {
                self.$widgetImg.attr("src",self.reader.result);
                self.$widgetImg.trigger("imagechange");
            }, false);
        }
        return $.xfaWidget.defaultWidget.prototype.render.apply(this, arguments);
    },

    getCommitValue: function() {
        return this._extractData(this.$userControl.attr("src"));
    },

    // hidden input change handler, input change will be triggered on selecting a new image
    _handleInputChange : function() {
        this._displayImage();
    },

    _imageClick : function(clickEvent) {
        //as the input button is hidden we trigger click explicitly on click of the widget
        this.$widgetInput.trigger("click");
    },

    // removes "data\:.*\;base64," from the image base64 string
    _extractData : function(value) {
        return value.replace(/data\:.*\;base64,/, "");
    },

    // previews image in the imagefield widget
    _displayImage : function() {
        var imageFile = this.$widgetInput.get(0).files ? this.$widgetInput.get(0).files[0] : null;
        if (imageFile && this._isFileOfImageType(imageFile.name)) {
            if (this.reader) {
                //readAsDataURL method is used to read the contents of the specified file, result attribute contains  the data as a URL representing the file's data as a base64 encoded string
                this.reader.readAsDataURL(imageFile);
            }
        }
    },

    // Test for supported image file(jpg,jpeg,png,gif,tif,bmp)
    _isFileOfImageType : function(fileName) {
        if (fileName) {
            return (/\.(jpe?g|png|gif|tif|bmp)$/i.test(fileName));
        }
        return false;
    }
});
})($);
/**
 * Created with IntelliJ IDEA.
 * User: rpandey
 * Date: 12/24/12
 * Time: 8:06 PM
 * To change this template use File | Settings | File Templates.
 */


(function($){
    $.widget( "xfaWidget.signatureField", $.xfaWidget.defaultWidget, {

        _widgetName:"signatureField",

        getOptionsMap: function() {
            var parentOptionsMap = $.xfaWidget.defaultWidget.prototype.getOptionsMap.apply(this,arguments);
            return $.extend({},parentOptionsMap,{
                "displayValue": function(val) {},
                "access": function(val) {}
            })
        },

        render : function() {
            var $control = $.xfaWidget.defaultWidget.prototype.render.apply(this, arguments);
            //pessimistic checks
            if($control) {
                $control.attr("readOnly","readonly").attr("disabled", true);
            }
            return $control;
        }
    });
})($);
/*
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 * Copyright 2011-2012 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
 
/**
 * widget definition for scribbleable field
 */
(function($,xfalib){

 var TouchUtil=xfalib.ut.TouchUtil;
 var ScribbleUtil=(function(){
      return {
          localeString:function(id){
                    return xfalib.ut.XfaUtil.prototype.encodeScriptableTags($.xfaWidget.abstractWidget.prototype.localeStrings()[id])  || id;
          }
      };
 })();
 var DELETE_KEY = 46;
 var ESC_KEY = 27;
 var ENTER_KEY = 13;
/**
 * Scribble class definition, used for drawing on canvas using mouse or touch
 */
function Scribble( canvasID,image,_width,_height, callback) {
    this._callback = callback;
    this.canvasID = canvasID;
    this._lineWidth=5;
    this.canvas = $("#"+canvasID);
    this.context = this.canvas.get(0).getContext("2d"); 
    this.context.clearRect(0,0,this.canvas.width,this.canvas.height);
    this._enabled=true;
    this.context.strokeStyle = "#000000";
    this.canvasBorderWidth = parseInt(this.canvas.css('border-left-width'),10); // assuming top and left borders are same width
    this.context.lineWidth = this._lineWidth;
    this.lastMousePoint = {x:0, y:0};
    
    this.canvas[0].width = _width;// this.canvas.parent().innerWidth();
    this.canvas[0].height = _height;//this.canvas.parent().innerHeight();
    if(!image){
        this.context.fillStyle   = '#ffffff';
        this.context.clearRect(0,0,_width,_height);
    } else {
        this.context.drawImage(image,0,0);
    }
    this.canvas.on( TouchUtil.POINTER_DOWN, this.onCanvasMouseDown() );
}
Scribble.prototype.setLineWidth=function(w){
    this._lineWidth=w;
};
Scribble.prototype.onCanvasMouseDown = function () {
    var self = this;
    return function(event) {
        if(TouchUtil.getTouches(event).length < 2){
            self.mouseMoveHandler = self.onCanvasMouseMove();
            self.mouseUpHandler = self.onCanvasMouseUp();
            //CQ-4261765 : Scribble sign scroll issue with ios
            //https://stackoverflow.com/questions/49500339/cant-prevent-touchmove-from-scrolling-window-on-ios
            //https://github.com/jquery/jquery/issues/2871
            document.addEventListener(TouchUtil.POINTER_MOVE, self.mouseMoveHandler,{ passive: false });
            $(document).on(TouchUtil.POINTER_UP, self.mouseUpHandler );
            self.updateMousePosition( event );
            self.updateCanvas( event );
        }
    }
};

Scribble.prototype.onCanvasMouseMove = function () {
    var self = this;
    return function(event) {
        if(TouchUtil.getTouches(event).length < 2){
            self.updateCanvas( event );
            event.preventDefault();
            return false;
        }
    }
};

Scribble.prototype.onCanvasMouseUp = function (event) {
    var self = this;
    return function(event) {
        document.removeEventListener(TouchUtil.POINTER_MOVE, self.mouseMoveHandler,{ passive: false });
        $(document).off(TouchUtil.POINTER_UP, self.mouseUpHandler );
        self.mouseMoveHandler = null;
        self.mouseUpHandler = null;
    }
};

Scribble.prototype.updateMousePosition = function (event) {
    if(!this._enabled) return ;
    var target = TouchUtil.getTouchEvent(event);

    var offset = this.canvas.offset();
    /* In IE>=10 pageX values are incorrect when using zoom
     so calculate them using clientX and scrollLeft */
    this.lastMousePoint.x = target.clientX + $(window).scrollLeft() - offset.left - this.canvasBorderWidth;
    this.lastMousePoint.y = target.clientY + $(window).scrollTop() - offset.top - this.canvasBorderWidth;

};
Scribble.prototype._isInsideCanvas = function(x,y){
    return y>=0 && y<this.canvas[0].height && x>=0 && x < this.canvas[0].width;
};
    Scribble.prototype.updateCanvas = function (event) {
    if(!this._enabled) {
       return;
    }
    var oldX,oldY,dX,dY,canDraw,scaleX,scaleY,cssWidth,cssHeight;
    cssWidth = parseInt(this.canvas[0].style.width,10);
    cssHeight = parseInt(this.canvas[0].style.height,10);
    scaleX =  cssWidth?this.canvas[0].width/cssWidth:1;
    scaleY = cssHeight?this.canvas[0].height/cssHeight:1;

    scaleX /= xfalib.ut.XfaUtil.prototype.formScaleFactor;
    scaleY /= xfalib.ut.XfaUtil.prototype.formScaleFactor;

    oldX = this.lastMousePoint.x*scaleX;
    oldY = this.lastMousePoint.y*scaleY;
   
    this.updateMousePosition( event );

    var newX =  this.lastMousePoint.x*scaleX;
    var newY =  this.lastMousePoint.y*scaleY;

    dX = Math.abs(newX - oldX );
    dY = Math.abs(newY - oldY );

    canDraw = ( dX > 0 || dY > 0 ) && this._isInsideCanvas(oldX,oldY) && this._isInsideCanvas(newX,newY);;

    if(canDraw){
        this.context.beginPath();
        this.context.moveTo( oldX, oldY );
        this.context.lineTo(newX, newY );
        this.context.lineWidth=this._lineWidth;
        this.context.lineCap='round';
        this.context.stroke();
		
        this._callback();
		
    }
};

Scribble.prototype.toString = function () {

    var dataString = this.canvas.get(0).toDataURL("image/png");
    //var index = dataString.indexOf( "," )+1;
    //dataString = dataString.substring( index );

    return dataString;
};
Scribble.prototype.setEnabled=function(enable){
    this._enabled=enable;
};
Scribble.prototype.clear = function () {

    var c = this.canvas[0];
    this.context.clearRect( 0, 0, c.width, c.height );
};


// ImageEdit dialog box
var imageEditDialog=(function(){
  
    // html used to construct dialog box
    var htmlStr=(function(){
         var html=[
             '<div id="iEBox_container" tabindex="0" role="dialog" aria-label="'+ScribbleUtil.localeString("pleaseSignText")+'">',
                  '<div id="iEBox_panel">',
                      '<div  id = "iEBox_Cancel" class="iEBox_button" tabindex="0" role="button" aria-label="'+ScribbleUtil.localeString("cancel")+'" title="'+ScribbleUtil.localeString("cancel")+'" ></div>',
                  '</div>',
                  '<div id="iEBox_content">',
                      '<div id="iEBox_canvases" align=center>',
                          '<div style="display:inline-block;">',
                               '<canvas  id="iEBox_canvas" style="margin:0px;border-bottom:0px;" width="696" height="390" ></canvas>' ,
                               '<fieldset id="iEBox_caption"><legend align="center">'+ScribbleUtil.localeString("pleaseSignText")+'</legend></fieldset>',
                          '</div>',
                          '<canvas id="iEBox_geoCanvasRight" width="0" height="0" ></canvas>',
                          '<div><canvas id="iEBox_geoCanvasBottom" width="0" height="0" ></canvas></div>',
                      '</div>',
                      '<div>',
                          '<div id="iEBox_Brush" class="iEBox_button" tabindex="0"  role="button" aria-label="'+ScribbleUtil.localeString("brushes")+'"  title="'+ScribbleUtil.localeString("brushes")+'"></div>',
                          '<div id="iEBox_Clear" class="iEBox_button" tabindex="0"  role="button" aria-label="'+ScribbleUtil.localeString("clear")+'"  title="'+ScribbleUtil.localeString("clear")+'" ></div>',
                          '<div id="iEBox_Geo" class="iEBox_button" tabindex="0"  role="button" aria-label="'+ScribbleUtil.localeString("geolocation")+'"  title="'+ScribbleUtil.localeString("geolocation")+'" ></div>',
                          '<div id="iEBox_title"></div>',
                          '<div id="iEBox_Ok" class="iEBox_button" tabindex="0"  role="button" aria-label="'+ScribbleUtil.localeString("ok")+'"  title="'+ScribbleUtil.localeString("ok")+'" ></div>',
                      '</div>' ,
                  '</div>' ,
                  '<div id="iEBox_moveframe" ></div>',
                  '<div id="iEBox_brushList" ></div>',
              '</div>'].join("");
           return function(){
              return html;
           };
    });
	
    /**
	 *   
	 */
	
    var dialogObj = {
        verticalOffset: 0, // removing the magic value of -75 since it was not causing any impact
        horizontalOffset: 0,
        repositionOnResize: true,
        overlayOpacity: .75,
        overlayColor: '#CCCCCC',
        draggable: true,
        _brushes:[2,3,4,5,6,7,8,9,10],
		_buttonsEnabled:{},
		_isOpen:false,
        show:function(title,callback){
           this._show(callback);
		   this._buttonsEnabled={Geo:true,Clear:true,Ok:true,Cancel:true,Brush:true};
        },
		setEnabled:function(button,enable){
		    if(this._buttonsEnabled[button]!=enable){
		           this._buttonsEnabled[button]=enable;
				   if(enable){
				       $('#iEBox_'+button).empty('<div style="background:white;width:100%;height:100%;opacity:0.75;"></div>').
				                  removeClass("disable_button");
				   } else {
				       $('#iEBox_'+button).append('<div style="background:white;width:100%;height:100%;opacity:0.75;"></div>').
				                  addClass("disable_button");
				   }
			       
			}
		},
		enableButtons:function(buttons){
		    for(var k in buttons){
				   this.setEnabled(k,buttons[k]);
			}
		},
        toggleBrushList:function(event){
                var that = this;
                if($('#iEBox_brushList').css('display')!='none'){
                    $('#iEBox_brushList').css({display:'none'});
                    return;
                }
                 var tmpFn =  document.onselectstart;
                 document.onselectstart=function(){return false;};
                 $('#iEBox_brushList').css({display:'block',visibility:'hidden'});
                    $('#iEBox_brushList').offset($('#iEBox_Brush').offset());
                    $('#iEBox_brushList').offset({top:$('#iEBox_Brush').offset().top-$('#iEBox_brushList').height()});
                    $('#iEBox_brushList').css({display:'block',visibility:'visible'});
                  //  $('#iEBox_brushList').focus();
                     $('#iEBox_brushList').one('mouseleave',function(event){
                         $('#iEBox_brushList').css({display:'none'});
                          document.onselectstart=tmpFn;
                     });
        },
        _attachCallbacks: function(callback) {
            var that = this;
           _.each("Cancel-Clear-Geo-Ok-Brush".split("-"),function(val,idx){
                    $("#iEBox_"+val).click( function(event) {
				       if(that._buttonsEnabled[val]){
                          event.stopPropagation();
                          callback(val);
				       }
                    });
					$("#iEBox_"+val).keydown( function(event) {
				       if(that._buttonsEnabled[val] && (event.keyCode == ENTER_KEY || event.charCode == ENTER_KEY || event.which == ENTER_KEY) ){
                          event.stopPropagation();
                          callback(val);
				       }
                    });
            });
            _.each($("#iEBox_brushList").children(),function(itm,idx){
                  $(itm).on(TouchUtil.POINTER_UP,function(event){
                         callback("BrushSelect",that._brushes[idx]);
                         $('#iEBox_brushList').css({display:'none'});
                          // $(itm).css({backgroundColor:'#FFFFFF'});
                  });
                  $(itm).on(TouchUtil.POINTER_DOWN,function(event){
                          // $(itm).css({backgroundColor:'#AAAAAA'});
                           event.preventDefault();
                  });
            });
            // capture tab key and escape
            $('#iEBox_container').keydown(function(event){
                var firstFocusableItem = document.querySelector("#iEBox_container");
                var lastFocusableItem = document.querySelector("#iEBox_Ok");
                var KEYCODE_TAB = 9;
                var isTabPressed = (event.key === 'Tab' || event.keyCode === KEYCODE_TAB);
                if((event.keyCode == ESC_KEY || event.charCode == ESC_KEY || event.which == ESC_KEY)) {
                    event.stopPropagation();
                    event.preventDefault();
                    callback("Cancel");
                } else if (isTabPressed) {
                    // Trap focus inside the dialog box
                    if (event.shiftKey && document.activeElement === firstFocusableItem) {
                        // when shift + tab key is pressed
                        lastFocusableItem.focus();
                        event.preventDefault();
                    } else if (document.activeElement === lastFocusableItem) {
                        // when tab key is pressed
                        firstFocusableItem.focus();
                        event.preventDefault();
                    }
                }

            });

            if(this.draggable){
                this._makeDraggable(TouchUtil.TOUCH_ENABLED);
            }
        },
        _makeDraggable:function(touchEnabled){
              var _isMouseDown=false;
              var _that=this;
              var dX;
              var dY;
              var offsetPos;
              var _mouseMovFun;
              var _mouseUpFun;
              $('#iEBox_panel').on(TouchUtil.POINTER_DOWN,function( event ){
              
                  if(TouchUtil.getTouches(event).length < 2){
                      if($(event.target).is('#iEBox_panel')){
                          $('body')[0].addEventListener(TouchUtil.POINTER_MOVE,_mouseMovFun=function( event ){
                              if(TouchUtil.getTouches(event).length < 2 && _isMouseDown){
                                  event.preventDefault();
                                  var evt = TouchUtil.getTouchEvent(event);
                                  var delX = evt.pageX - dX;
                                  var delY = evt.pageY - dY;
                                  $('#iEBox_moveframe').offset({
                                      top: offsetPos.top+delY,
                                      left: offsetPos.left+delX
                                  });
                              }
                          }, { passive: false });
                          $('body').on(TouchUtil.POINTER_UP,_mouseUpFun=function(event){
                              if(_isMouseDown){
                                  var offsetMove = $('#iEBox_moveframe').offset();
                                  var topEdge  = $(window).scrollTop();
                                  var bottomEdge = topEdge + $(window).height();
                                  if(offsetMove.top - topEdge < 1){
                                      offsetMove.top = topEdge;
                                  }
                                  if(offsetMove.top - bottomEdge + $('#iEBox_panel').height() > 0 ){
                                      offsetMove.top = bottomEdge - $('#iEBox_panel').height();
                                  }
                                  $('#iEBox_container').offset(offsetMove );
                                  $('#iEBox_moveframe').css({display:'none'}).offset(offsetMove);
                                  _isMouseDown=false;
                                  $('body')[0].removeEventListener(TouchUtil.POINTER_MOVE,_mouseMovFun,{ passive: false });
                                  $('body').off(TouchUtil.POINTER_UP,_mouseUpFun);
                              }
                          });

                          var evt = TouchUtil.getTouchEvent(event);
                          _isMouseDown=true; dX = evt.pageX;dY=evt.pageY;
                          offsetPos = $('#iEBox_container').offset();
                          $('#iEBox_moveframe').css({display:'block'});
                          $('#iEBox_moveframe').offset(offsetPos);
                          $('#iEBox_moveframe').css('width',$('#iEBox_container').css('width'));
                          $('#iEBox_moveframe').css('height',$('#iEBox_container').css('height'));
                      }
                  }
              });
             
        },
        _createBrushes:function(){
               var _that=this;
              _.each(this._brushes,function(val,idx){
                  var divel = document.createElement('DIV');
                  var cnv = document.createElement('CANVAS');
                  var ctx = cnv.getContext('2d');
                  cnv.style.border='1px solid #AAAAAA';
                  cnv.width=TouchUtil.TOUCH_ENABLED?200:100;
                  cnv.height=TouchUtil.TOUCH_ENABLED?40:20;;
                  ctx.lineWidth=val;
                  ctx.beginPath();
                  ctx.moveTo(10,cnv.height/2);
                  ctx.lineTo(cnv.width-10,cnv.height/2);
                  ctx.stroke();
                  divel.appendChild(cnv);
                  $('#iEBox_brushList').append(divel);
               });
        },
		getIsOpen:function(){
		    return dialogObj._isOpen;
		},
		setIsOpen:function(open){
		    dialogObj._isOpen = open;
		},
        _show: function(callback) {
            dialogObj.hide();
            dialogObj._overlay('show');
            
            $("BODY").append(htmlStr());
            dialogObj.setIsOpen(true);
            $('#iEBox_container').focus();
            dialogObj._createBrushes();

            dialogObj._reposition();

            // calculate spacing around canvas area
            // this will be used to find canvas dimensions based on available screen area.
            var container_el = $('#iEBox_container');
            var canvas_el =  $('#iEBox_canvas');
            var container_width = $('#iEBox_container').outerWidth(true);
            var container_height = $('#iEBox_container').outerHeight(true);
            var canvas_width = canvas_el[0].width;
            var canvas_height = canvas_el[0].height;
            dialogObj.canvas_spacing = { x:container_width - canvas_width, y:container_height-canvas_height};

            dialogObj._maintainPosition(true);
            
            dialogObj._attachCallbacks(callback);
        },

        hide: function() {
            $("#iEBox_container").remove();
            this._overlay('hide');
            dialogObj.setIsOpen(false);
            this._maintainPosition(false);
        },
        _overlayResize:function(event) {
            if($("#iEBox_overlay").height()!= $(document).height()){
                $("#iEBox_overlay").height( $(document).height() );
            }

        },
        _disableMove:function(event) {
            event.preventDefault();
        },
        _overlay: function(status) {
            switch( status ) {
                case 'show':
                    this._overlay('hide');
                    $("BODY").append('<div id="iEBox_overlay"></div>');
                    $("#iEBox_overlay").css({
                        position: 'fixed',
                        zIndex: 99997,
                        top: '0px',
                        left: '0px',
                        width: '100%',
                        height: $(document).height(),
                        background: this.overlayColor,
                        opacity: this.overlayOpacity
                    });
                    if(xfalib.ut.XfaUtil.prototype.isSafari()) {
                        $("#iEBox_overlay").on('touchmove', this._disableMove);
                    }
                    $(document).on('scroll',this._overlayResize);
                break;
                case 'hide':
                    if(xfalib.ut.XfaUtil.prototype.isSafari()) {
                        $("#iEBox_overlay").off('touchmove');
                    }
                    $("#iEBox_overlay").remove();
                    $(document).off('scroll',this._overlayResize);
                break;
            }
        },
        /**
         * resize dialog based on available screen area
         */
        _resize:function(){
            // available screen area
            var aWidth = $(window).width();
            var aHeight = $(window).height();

            var sigCnv = $('#iEBox_canvas')[0];
            var bGeoCnv = $('#iEBox_geoCanvasBottom')[0];
            var rGeoCnv = $('#iEBox_geoCanvasRight')[0];

            // calculate amount of width height we need to reduce

            var totalCnvWidth = sigCnv.width + rGeoCnv.width;
            var totalCnvHeight = sigCnv.height + bGeoCnv.height;





            var diffW = totalCnvWidth + dialogObj.canvas_spacing.x - aWidth;
            if(diffW < 0) {
                diffW = 0;
            }
            var diffH = totalCnvHeight + dialogObj.canvas_spacing.y - aHeight;
            if(diffH < 0){
                diffH = 0;
            }

            var newTotalCnvHeight, newTotalCnvWidth;
            if( diffW > 0 || diffH > 0 ){ // does any side need resize

                if(diffH * totalCnvWidth > totalCnvHeight * diffW){ // need to reduce height
                   newTotalCnvHeight = totalCnvHeight - diffH;
                   newTotalCnvWidth = (newTotalCnvHeight * totalCnvWidth)/ totalCnvHeight;
                } else {
                   newTotalCnvWidth = totalCnvWidth - diffW;
                   newTotalCnvHeight = (newTotalCnvWidth * totalCnvHeight)/ totalCnvWidth;
                }

                // distribute evenly the new dimensions


                var newSigCnvWidth   = (newTotalCnvWidth*sigCnv.width)/totalCnvWidth;
                var newSigCnvHeight = (newTotalCnvHeight*sigCnv.height)/totalCnvHeight;

                sigCnv.style.width = newSigCnvWidth + "px";
                sigCnv.style.height = newSigCnvHeight + "px";

                bGeoCnv.style.width = newSigCnvWidth +"px";
                bGeoCnv.style.height = (newTotalCnvHeight - newSigCnvHeight) +"px";

                rGeoCnv.style.width = (newTotalCnvWidth - newSigCnvWidth) +"px";
                rGeoCnv.style.height = newSigCnvHeight + "px";


                $('#iEBox_caption').width(Math.floor(newSigCnvWidth));

            } else {
                sigCnv.style.width =  sigCnv.width + "px";
                sigCnv.style.height = sigCnv.height + "px";

                bGeoCnv.style.width =  bGeoCnv.width + "px";
                bGeoCnv.style.height = bGeoCnv.height + "px";

                rGeoCnv.style.width =  rGeoCnv.width + "px";
                rGeoCnv.style.height = rGeoCnv.height + "px";

                $('#iEBox_caption').width(sigCnv.width);

            }
        },
        _reposition: function() {
            var top = (($(window).height() * (1 / xfalib.ut.XfaUtil.prototype.formScaleFactor) / 2) - ($("#iEBox_container").outerHeight() / 2)) + dialogObj.verticalOffset;
            var left = (($(window).width() * (1 / xfalib.ut.XfaUtil.prototype.formScaleFactor) / 2) - ($("#iEBox_container").outerWidth() / 2)) + dialogObj.horizontalOffset;
            if( top < 0 ) top = 0;
            if( left < 0 ) left = 0;

            $("#iEBox_container").css({
                top: top + $(window).scrollTop() * (1 / xfalib.ut.XfaUtil.prototype.formScaleFactor) + 'px',
                left: left + $(window).scrollLeft() * (1 / xfalib.ut.XfaUtil.prototype.formScaleFactor) + 'px'
            });
            $("#iEBox_container").focus();   // scroll up to the canvas
            $("#iEBox_overlay").height( $(document).height() );
        },
        _maintainDialog:function(){
            dialogObj._resize();
            dialogObj._reposition();
        },
        _maintainPosition: function(status) {
            if(dialogObj.repositionOnResize ) {
                switch(status) {
                    case true:
                        $(window).on('orientationchange', dialogObj._maintainDialog); // also reposition if device is tilted
                    break;
                    case false:
                        $(window).off('orientationchange', dialogObj._maintainDialog);
                    break;
                }
            }
        }
        
    };
    return dialogObj;
})();

/**
 * class definition for GeoLocationQueryRequest
 * encapsulated success and error handlers 
 */
function GeoLocQuery(){}
GeoLocQuery.prototype={
    init:function(success,failure){
        this._successHandler = success;
        this._errorHandler = failure;
        this._active=true;
        return this;
    },
    _handleSuccess:function(data){
        this._successHandler(data); 
    },
    _handleError:function(err){
        this._errorHandler(err);   
    },
    query:function(){
         _that=this;
         navigator.geolocation.getCurrentPosition(function(pos){
          if(_that._active){
             _that._handleSuccess(pos);
          }
          _that._active=false;
       },function(err){
          if(_that._active){
             _that._handleError(err);
          }
          _that._active=false;
       },{timeout:10000});
    },
    cancel:function(){
        _that._active=false;
    }

};
// GeoLocQuery definition ends here

/**
*
*  Base64 encode / decode
*  http://www.webtoolkit.info/
*
**/
 
var Base64 = {
 
	// private property
	_keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
 
	// public method for encoding
	encode : function (input) {
		var output = "";
		var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
		var i = 0;
 
		while (i < input.length) {
 
			chr1 = input.charCodeAt(i++);
			chr2 = input.charCodeAt(i++);
			chr3 = input.charCodeAt(i++);
 
			enc1 = chr1 >> 2;
			enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
			enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
			enc4 = chr3 & 63;
 
			if (isNaN(chr2)) {
				enc3 = enc4 = 64;
			} else if (isNaN(chr3)) {
				enc4 = 64;
			}
 
			output = output +
			this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +
			this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);
 
		}
 
		return output;
	},
 
	// public method for decoding
	decode : function (input) {
		var output = "";
		var chr1, chr2, chr3;
		var enc1, enc2, enc3, enc4;
		var i = 0;
 
		input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
 
		while (i < input.length) {
 
			enc1 = this._keyStr.indexOf(input.charAt(i++));
			enc2 = this._keyStr.indexOf(input.charAt(i++));
			enc3 = this._keyStr.indexOf(input.charAt(i++));
			enc4 = this._keyStr.indexOf(input.charAt(i++));
 
			chr1 = (enc1 << 2) | (enc2 >> 4);
			chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
			chr3 = ((enc3 & 3) << 6) | enc4;
 
			output = output + String.fromCharCode(chr1);
 
			if (enc3 != 64) {
				output = output + String.fromCharCode(chr2);
			}
			if (enc4 != 64) {
				output = output + String.fromCharCode(chr3);
			}
 
		}
 
		return output;
 
	}
 
	
 
};

/**
 * Utility Singleton for handling PNG Data
 */
var PNGUtil=(function(){
    var slf={
   _LC_Scribble_MetaDataKey:"LC_SCIBBLE_METADATA",
           _isPng:function(b64data){
               return  b64data && b64data.replace(/\s+/g, "").indexOf("iVBORw0KGgo") == 0;   // LC-5711 : trim any leading WhiteSpace
               // TODO :  base64 encoding may have white spaces even between the magic numbers !! Think of a better way to stop stripping white spaces repeatedly in PNGUtil, and cache the result
           },
           _update_crc:function(crc,data){
               var c = crc;
               var n;
               for(n=0;n<data.length;n++){
                  c = this._XOR(slf._crc_table[(this._XOR(c,data.charCodeAt(n))&0xff)>>>0],(c>>>8));
               }
               return c;
           },
		   _XOR:function(a,b){
		       return (a^b)>>>0;
		   },
           _U32Int2Str:function(n){
                return String.fromCharCode((n>>>24)&0xFF)+String.fromCharCode((n>>>16)&0xFF)+String.fromCharCode((n>>>8)&0xFF)+String.fromCharCode(n>>>0&0xFF);
            },
           _init_crc_table:function(){
               var c=0;
               var n,k;
               slf._crc_table=[];
               for(n=0;n<256;n++){
                   c = n;
                   for(k=0;k<8;k++){
                      if(((c&1)>>>0)>0){
                          c = slf._XOR(0xedb88320 , (c>>>1));
                      } else {
                          c = c>>>1;
                      }
                   }
                   slf._crc_table[n]=c;
                }
           },
           _CRC:function(data){
                if(!this._crc_table) this._init_crc_table();
                return this._XOR(this._update_crc(0xffffffff,data) , 0xffffffff);
          },
          _prepareTextChunk:function(content,pad){
              // pad the data appropriately                      
               var len = content.length;
               var lenStr = slf._U32Int2Str(len);
               var chunkType="tEXt";
               var checkSumStr = slf._U32Int2Str(slf._CRC(chunkType+content));
               return lenStr+chunkType+content+checkSumStr;
           },
        _start:function(str){
           slf._startTime = new Date().getTime();
           slf._startFun=str;
        },
        _end:function(){
           var str = "Time "+slf._startFun+": "+(new Date().getTime()-slf._startTime);
          //  $('BODY').append("<p>"+str+"</p><br/>");
        },
        _readU32Int:function(ctx){
            var val=0;
            var d=ctx.d;
            val=((d.charCodeAt(ctx.p++)<<24)|(d.charCodeAt(ctx.p++)<<16)|(d.charCodeAt(ctx.p++)<<8)|(d.charCodeAt(ctx.p++)))>>>0;
             return val;
        },
       _readChunkType:function(ctx){
          var d = ctx.d;
          var str = d[ctx.p++]+d[ctx.p++]+d[ctx.p++]+d[ctx.p++];
          return str;
       },
        _makeReadOnly:function(b64data){
      slf._start("_makeReadOnly");
      // assume a valid png image encoded in base64;
      var bindata = slf._atob(b64data.replace(/\s+/g, '')); // remove white spaces that might have been inserted
      var pngctx={p:0,d:bindata};
      pngctx.p+=8;// skip pngheader
      // read IHDR
      var size = slf._readU32Int(pngctx);
      slf._readChunkType(pngctx); //IHDR
      pngctx.p+=size; //Data
      slf._readU32Int(pngctx);//CRC
      var metadataChunk = slf._prepareTextChunk(slf._LC_Scribble_MetaDataKey+String.fromCharCode(0)+"true");
      var newdata = pngctx.d.substring(0,pngctx.p)+metadataChunk+pngctx.d.substring(pngctx.p);
      var ret= slf._btoa(newdata);
      slf._end();
      return ret;
   },
   _atob:function(inp){
      if(window.atob){ return atob(inp); }
	  return Base64.decode(inp);
   },
   _btoa:function(inp){
      if(window.btoa){ return btoa(inp); }
	  return Base64.encode(inp);
   },
   _isReadOnly:function(b64data){
    slf._start("_isReadOnly");
       if(slf._isPng(b64data)){
           var testStr = slf._LC_Scribble_MetaDataKey+String.fromCharCode(0)+"true";
           var bindata = slf._atob(b64data.replace(/\s+/g, '')); // strip white spaces
           var pngctx={p:0,d:bindata};
           pngctx.p+=8;// skip header
           while(pngctx.p<pngctx.d.length){
               var size = slf._readU32Int(pngctx);
               var type = slf._readChunkType(pngctx);
               if(type=="tEXt"){
                   if(pngctx.d.indexOf(testStr,pngctx.p)==pngctx.p){
                       slf._end();
                       return true;
                   }
                  
              }
              pngctx.p+=size;
              slf._readU32Int(pngctx);// 
          }// while end
       }
       slf._end();
       return false;
   }
    };
    return slf;
})();

/**
 * JQuery widget definition starts here
 */
$.widget( "xfaWidget.ScribbleImageField", $.xfaWidget.imageField, {

    _widgetName:"ScribbleImageField",
    _geoLocQuery:null,
   _emptyImageVal:null,// should be null, but for now
   _extraInfo:null,
   _defaultStatus:"&nbsp;",
   _enforceGeoLoc:!!navigator.userAgent.match(/iPad/i),
   _sigCanvasWidth:696,
   _sigCanvasHeight:390,
   _geoCanvId:null,
    _geoLocAtBottom:false,
   _geoCanvasHeight:100,
   _geoCanvasWidth:696,
   
    _is_readonly:false,
	
    options: {
        tabIndex: 0,
        "role": "img"
    },

    getOptionsMap: function() {
        var parentOptionsMap = $.xfaWidget.defaultWidget.prototype.getOptionsMap.apply(this,arguments);
        return $.extend({},parentOptionsMap,{
            "displayValue": function(val) {
                if(this.options.commitProperty) {
                    if(!val){
                        this._displayValue(this._extractData(this._createEmptyImageData()));
                        this.$userControl.addClass("emptyScribble");
                        this._is_readonly=false;
                    } else {
                        this.$userControl.removeClass("emptyScribble");
                        if(PNGUtil._isPng(val)){
                            var widgetValue = "data:image/png;base64,"+this.options.value;
                        }else {
                            var widgetValue = "data:;base64," + this.options.value;
                        }
                        this._setValue(widgetValue);
                    }
                }
            }
        })
    },

    getEventMap: function() {
        var parentOptionsMap = $.xfaWidget.defaultWidget.prototype.getEventMap.apply(this,arguments);
        return $.extend({},parentOptionsMap,{
            "scribblefocus":xfalib.ut.XfaUtil.prototype.XFA_ENTER_EVENT,
            "click":null,
            "scribbleclick":xfalib.ut.XfaUtil.prototype.XFA_CLICK_EVENT,
            "change":null,
            "scribblechange":xfalib.ut.XfaUtil.prototype.XFA_CHANGE_EVENT,
            "blur":null,
            "scribbleclose":xfalib.ut.XfaUtil.prototype.XFA_EXIT_EVENT
        })
    },

	/**
	 * This function achieves following
	 * 1. Calculate dimensions of canvases to be used
	 * 2. Findout if right or bottom canvas is to be used for geo location
	 */

	 aspectRatioToBeUsed :function(){
        var aspectRatio ;
        if(this.options.aspectRatio && parseFloat(this.options.aspectRatio) > 0){
           aspectRatio = 1/parseFloat(this.options.aspectRatio);  //--in MF ratio is computed as height/width instead of width/height
        } else {
           var imgEl = this.element.children("img"),
               width = imgEl.attr('width'),
               height = imgEl.attr('height'),
               fieldWidth,
               fieldHeight;

           if(width){
              fieldWidth = parseInt(width,10);
           } else {
              fieldWidth = imgEl.width();
           }
           if(height){
              fieldHeight = parseInt(height,10);
           } else {
              fieldHeight = imgEl.height();
           }
           aspectRatio = fieldHeight/fieldWidth;
        }
	    return aspectRatio;
	 },

    _setUpCanvas:function(){
        var aspectRatio ;
		aspectRatio = this.aspectRatioToBeUsed();
       
        // max width, height of generated image
        var maxWidth = 640;
        var maxHeight = 480;
        
        // width of field scaled to fit max image size
        var scaledWidth;
        var scaledHeight;
        
        
		// approx pixels required for rendering geo loc info in 12pt Arial font 
		var approxGeoLocWidth=250;
		var approxGeoLocHeight=84;
        
        scaledWidth = maxWidth;
        scaledHeight = maxWidth*aspectRatio;
        if(scaledHeight>maxHeight){
            scaledHeight = maxHeight;
            scaledWidth = maxHeight/aspectRatio;
        }
        
        // set canvas dimensions
        if(aspectRatio>=1){
			this._geoCanvId='iEBox_geoCanvasBottom';
            this._geoLocAtBottom=true;
          
			
             this._geoCanvasWidth = scaledWidth;
			 // limit height to 30% of full height;
			 this._geoCanvasHeight=Math.min(approxGeoLocHeight,scaledHeight/3);
             this._sigCanvasWidth = scaledWidth;
             this._sigCanvasHeight= scaledHeight-(this._enforceGeoLoc?this._geoCanvasHeight:0);
        } else {
			this._geoCanvId='iEBox_geoCanvasRight';
            this._geoLocAtBottom=false;
           
			
            this._geoCanvasHeight = scaledHeight;
			// limit width to 30% of full width;
			this._geoCanvasWidth=Math.min(approxGeoLocWidth,scaledWidth/3);
            this._sigCanvasHeight= scaledHeight;
            this._sigCanvasWidth= scaledWidth-(this._enforceGeoLoc?this._geoCanvasWidth:0);
        }
       
    },

   render : function() {
       var geoLocMandatoryOnIpad = this.options.geoLocMandatoryOnIpad;
       if(typeof(geoLocMandatoryOnIpad)!="undefined"){
           this._enforceGeoLoc= this._enforceGeoLoc && (/^(true|1)$/i).test($.trim(geoLocMandatoryOnIpad));
       }
       this._wgtId="wid"+~~(Math.random()*2000)+"_"+new Date().getTime();

       var $control = $.xfaWidget.defaultWidget.prototype.render.apply(this, arguments)

       if(this.options.value || this.options.value != this._emptyImageVal){
          this._is_readonly=!!PNGUtil._isReadOnly(this.options.value);
       }
   
       if(this._is_readonly){
          $control.after("<div id='"+this._wgtId+"' class='sc_popUpMenu'></div>");
       } else {
          $control.after("<div id='"+this._wgtId+"' style='display:none;' class='sc_popUpMenu'></div>");
       }
	   
	   this._setUpCanvas();
       return $control;
    },

   click: function() {
        this.focus();
        var tmpEl = this.element.length?this.element[0]:this.element;
        if(this.options.access != "open")
          return;
       if (TouchUtil.POINTER_ENABLED || TouchUtil.TOUCH_ENABLED) {
           // simulate a click event
           tmpEl.dispatchEvent(TouchUtil.getPointerEvent(TouchUtil.POINTER_DOWN));
           tmpEl.dispatchEvent(TouchUtil.getPointerEvent(TouchUtil.POINTER_UP));
        }
        else {
              this.$userControl.triggerHandler("click");
        }
   },

    _attachEventHandlers:function($control){
	     if(TouchUtil.POINTER_ENABLED || TouchUtil.TOUCH_ENABLED){
            this._attachTouchEventHandlers($control);
         } else {
            this._attachMouseEventHandlers($control);
         }
         $control.keydown($.proxy(this._handleKeyDown,this));
    },
	_attachEventHandlerForCrossIcon:function($control){
	    var _that = this;
	    $control.mouseenter(function(event){
             if(_that.options.access != "open")
                    return;
             event.stopPropagation();
             if(_that._is_readonly){
                $('#'+_that._wgtId).css({display:'block'});
                var bodyMoveHandler;
                $('body').on('mousemove',bodyMoveHandler=function(event){
                    if(event.target!=$('#'+_that._wgtId)[0]&&event.target!=_that.$userControl[0]){
                        $('#'+_that._wgtId).css({display:'none'});
                         $('body').off('mousemove',bodyMoveHandler);
                    }
                });
              }
       });

       setTimeout(function(){ $("#"+_that._wgtId).click($.proxy(_that._onCrossClick,_that));},50);  
	},
    _attachTouchEventHandlers:function($control){
        var _timer,_that=this;
        var tmpEl = this.element.length?this.element[0]:this.element;
       tmpEl.addEventListener(TouchUtil.POINTER_DOWN,function(event){
           if(_that.options.access != "open")
              return;
             event.preventDefault();
           _timer = setTimeout(function(){
                _timer=0;
               _that._onCrossClick(event);
            },1000);
        });
       tmpEl.addEventListener(TouchUtil.POINTER_UP,function(event){
            if(_that.options.access != "open")
                return;
            event.preventDefault();
            if(_timer){
               clearTimeout(_timer);
               _that._onImageClick(event);
            } 
        });
		
	   if(TouchUtil.POINTER_ENABLED){
		     this._attachEventHandlerForCrossIcon($control);
			 setTimeout(function(){ $("#"+_that._wgtId).on(TouchUtil.POINTER_UP,function(event){
			        event.stopPropagation();
			 });},50);
	   }
    },

    _attachMouseEventHandlers:function($control){
         var _timer=0,_that=this,_hoverTimer=0;
        $control.dblclick(function(event){
            if(_that.options.access != "open")
                return;
           event.preventDefault();event.stopPropagation();
           if(_timer.val){
             clearTimeout(_timer);_timer =0;
           }
           _that._onCrossClick(event);
        }).click(function(event){
           _that.$userControl.trigger("scribbleclick",event);
           if(_that.options.access != "open")
                return;
           event.preventDefault();
           event.stopPropagation();
           if(_timer){
              clearTimeout(_timer);_timer=0;
            } else {
              _timer = setTimeout(function(){
                 _timer=0;
                 _that._onImageClick(event);
              },500);
            }
       });
	   
	   this._attachEventHandlerForCrossIcon($control);
       
    },

    _onCrossClick:function(event){
        if(!this._is_readonly) return;
        this.$userControl.trigger("scribblefocus",event);
        this.$userControl.trigger("scribbleclick",event);
        event.stopPropagation();
        $.alertBox.yesNo(null,
         this.localeStrings().clearSignatureConfirm,
         this.localeStrings().clearSignature,
         $.proxy(this._removeSigConfirmationHandler,this));
     },

     _removeSigConfirmationHandler:function(isYes){
        if(isYes){
           this._saveValue(this._emptyImageVal);
           this._displayValue(this._extractData(this._createEmptyImageData()));
           this.$userControl.addClass("emptyScribble").trigger("scribbleclose",{});
           this._is_readonly=false;
        }
     },

    _createEmptyImageData:function(){
         if(!this._emptyImageData){
            var emptyCanvasObj = document.createElement('canvas');
            emptyCanvasObj.style.width=this._sigCanvasWidth+'px';
            emptyCanvasObj.style.height=this._sigCanvasHeight+'px';
            emptyCanvasObj.width=this._sigCanvasWidth;
            emptyCanvasObj.height=this._sigCanvasHeight;
            var ctx = emptyCanvasObj.getContext('2d');
            ctx.fillStyle='#ffffff';
            ctx.clearRect(0,0,this._sigCanvasWidth,this._sigCanvasHeight);
            this._emptyImageData = emptyCanvasObj.toDataURL("image/png");
         }
         return this._emptyImageData;
     },

    getCommitValue: function() {
        return this.options.value
    },

    _saveValue:function(val){
        this.options.value=val;
        this.$userControl.trigger('scribblechange');
    },

    _displayValue:function(val){
        if(this.options.commitProperty) {
            //hardcode the widget VALUE by unknown image type
            if(val){
              var widgetValue = "data:image/png;base64,"+val;
                this._setValue(widgetValue);
            }
        }
        else
            this.logger().debug("xfaView","[DefaultWidget._update], User Control or Commit Property is null" );
    },

    _doOk:function(){
        var mainCanvas = document.createElement('CANVAS');
        var geoCnv = $('#'+this._geoCanvId)[0];
        var sigCnv = $('#iEBox_canvas')[0];
        var ctx = mainCanvas.getContext('2d');
       
        if(geoCnv.width>0&&geoCnv.height>0){
            
            if(this._geoLocAtBottom){
                mainCanvas.width=sigCnv.width;
                mainCanvas.height =sigCnv.height+geoCnv.height;
                ctx.drawImage(sigCnv,0,0);
                ctx.drawImage(geoCnv,0,sigCnv.height);
            } else {
                mainCanvas.width=sigCnv.width+geoCnv.width;
                mainCanvas.height =sigCnv.height;
                ctx.drawImage(sigCnv,0,0);
                ctx.drawImage(geoCnv,sigCnv.width,0);
            }
        } else {
             mainCanvas.width=sigCnv.width;
             mainCanvas.height =sigCnv.height;
             ctx.drawImage(sigCnv,0,0);
        }
        imageEditDialog.hide();
        var newdata = mainCanvas.toDataURL("image/png");//(this.myScribbleHandle||"").toString();
        
         var val,val1;
         if((val=/*=*/this._extractData(newdata))){
         //  val1 = PNGUtil._makeReadOnly(val);
            val = PNGUtil._makeReadOnly(val);
            this._saveValue(val);   
            this._is_readonly=true;       
          }
          this._geoLocQuery&&this._geoLocQuery.cancel();// cancel current geo loc request;
        this.$userControl.trigger("scribbleclose")
    },
    _handleOk:function(){
        if(this._enforceGeoLoc){
           this._geoLocQuery = new GeoLocQuery().init($.proxy(function(data){
               this._geoQuerySuccessHandler(data);
               this._doOk();
           },this),$.proxy(this._geoQueryErrorHandler,this));
           this._geoLocQuery.query();
           this._showMessage(this.localeStrings().fetchGeoLocation);
        } else {
          this._doOk();
        }
    },

    _handleCancel:function(){
         imageEditDialog.hide();
         this._geoLocQuery&&this._geoLocQuery.cancel();// cancel current geo loc request;
        this.$userControl.trigger("scribbleclose")
    },

    _handleClear:function(){
        this.myScribbleHandle.setEnabled(true);
        this._is_readonly=false;
        this._makeReadOnly(this._is_readonly);
        $('#iEBox_canvas')[0].width=this._sigCanvasWidth;
         $('#iEBox_caption').width(this._sigCanvasWidth);
		$('#iEBox_canvas')[0].height=this._sigCanvasHeight;
		var geoCanv = $('#'+this._geoCanvId)[0];
        imageEditDialog.enableButtons({Ok:false,Clear:false});
        geoCanv.width=0;
        geoCanv.height=0;
        imageEditDialog._resize();
        this._geoLocQuery&&this._geoLocQuery.cancel();// cancel current geo loc request;
    },
    _makeReadOnly:function(readonly){
       imageEditDialog.enableButtons({Ok:false,Clear:false,Geo:!readonly,Brush:!readonly});
       if(readonly){
		   $('#iEBox_canvas').css({border:'1px solid gray'});
           $('#iEBox_caption').css({display:'none'});

       }
       this._defaultStatus = "&nbsp;";
       this._showMessage(this._defaultStatus);
    },

    _showMessage:function(msg){
        var _that = this;
        if(this._msgTimeout) { clearTimeout(this._msgTimeout); this._msgTimeout=0; }
         $("#iEBox_title").replaceWith('<div id="iEBox_title">'+msg+'</div>');
         this._msgTimeout = window.setTimeout(function(){
             $("#iEBox_title").replaceWith('<div id="iEBox_title">'+_that._defaultStatus+'</div>');
         },15000);
    },

    _geoQueryErrorHandler:function(err){
        this._showMessage(this.localeStrings().errorFetchGeoLocation);
    },

	_getLogMessage:function(key){
		     return this.logMsgs()[key]||key;
	},

    _handleGeo:function(){
          // initiate geolocation 
       if(navigator.geolocation){
           this._geoLocQuery = new GeoLocQuery().init($.proxy(this._geoQuerySuccessHandler,this),$.proxy(this._geoQueryErrorHandler,this));
           this._geoLocQuery.query();
           this._showMessage(this.localeStrings().fetchGeoLocation);
       } else {
           this.logger().debug("xfaView",this._getLogMessage("ALC-FRM-901-011"));
       }
    },

    // This Function is used to fetch the geolocation.
    calculateGeolocation: function(){
      this._handleGeo();
    },

    _handleBrushSelect:function(w){
        if(this.myScribbleHandle&&!this._is_readonly) {
            this.myScribbleHandle.setLineWidth(w);
        }
    },

    _handleBrush:function(evt){
        imageEditDialog.toggleBrushList(evt);
    },
	_handleKeyDown:function(event){
		if(event.keyCode == ENTER_KEY || event.charCode == ENTER_KEY || event.which == ENTER_KEY) { // touch devices may return charCode
		    event.preventDefault();
		    this._onImageClick(event);
		} else if(event.keyCode == DELETE_KEY || event.charCode == DELETE_KEY || event.which == DELETE_KEY) {
		    this._onCrossClick(event);
		}
    },
    _dialogCallback:function(button_val,arg1){
           // add back on click handler
         //  this.$userControl.click($.proxy(this._onImageClick, this));
                     
           switch(button_val){
               case "Ok":
               this._handleOk();
               break;
               case "Cancel":
               this._handleCancel();
               break;
               case "Clear":
               this._handleClear();
               break;
               case "Geo":
               this.calculateGeolocation();
               break;
               case "BrushSelect":
               this._handleBrushSelect(arg1);
               break;
               case "Brush":
               this._handleBrush(arg1);
               break;
              
           }
    },

    _geoQuerySuccessHandler:function(data){
        this._renderPosition(data);
    },

	_fitGeoLocText:function(latStr,longStr,timeStr,ctx,maxWidth,maxHeight){
	    var fontSize=12;
		ctx.font="bold "+fontSize+"pt Arial";
		var width = Math.max(ctx.measureText(latStr).width,ctx.measureText(longStr).width,ctx.measureText(timeStr).width);
		var lineHeight = ctx.measureText("m").width*1.5;
		while((width>maxWidth||3*lineHeight>maxHeight)&&fontSize>1){
		    fontSize--;
		    ctx.font="bold "+fontSize+"pt Arial";
		    width = Math.max(ctx.measureText(latStr).width,ctx.measureText(longStr).width,ctx.measureText(timeStr).width);
		    lineHeight = ctx.measureText("m").width*1.5;
		}
		return {width:width,lineHeight:lineHeight,fontSize:fontSize};
	},

    _renderPosition:function(position){
        if(position&&position.coords){
         this._showMessage("&nbsp;");
            var latStr = this.localeStrings().latitude+": " + position.coords.latitude;
            var longStr = this.localeStrings().longitude+": " + position.coords.longitude;
            var dateObj = new Date();
            var tZone = (dateObj.getTimezoneOffset()/60*-1);
            
            var timeStr = this.localeStrings().time+": "+(dateObj.getMonth()+1)+"/"+dateObj.getDate()+"/"+dateObj.getFullYear()+" "+dateObj.getHours()+":"+dateObj.getMinutes()+":"+dateObj.getSeconds()+((tZone>0)?" +":" ")+(tZone);
            var canvasObj  = $('#'+this._geoCanvId)[0];
			var sigCanvas = $('#iEBox_canvas')[0];
			var dummyCanvas = document.createElement('canvas');
            if(canvasObj){
			   var ctx = canvasObj.getContext('2d');
			   ctx.font="bold 12pt Arial";

			   canvasObj.width=this._geoCanvasWidth;
               canvasObj.height=this._geoCanvasHeight;
			   var layout = this._fitGeoLocText(latStr,longStr,timeStr,ctx,canvasObj.width,canvasObj.height);
               var aspectRatio ;
     		   aspectRatio = this.aspectRatioToBeUsed();
			   if(!this._enforceGeoLoc){
			       if(this._geoLocAtBottom){
                     dummyCanvas.height = this._sigCanvasHeight-canvasObj.height;
                     dummyCanvas.width = dummyCanvas.height/aspectRatio;
                   } else {
                     dummyCanvas.width = this._sigCanvasWidth-canvasObj.width;
					 dummyCanvas.height = dummyCanvas.width*aspectRatio;
				   }
				   // move drawn signature to a temporary canvas and scale it to new dimension
                   dummyCanvas.getContext('2d').drawImage(sigCanvas,0,0,dummyCanvas.width,dummyCanvas.height);
                   if(this._geoLocAtBottom){
                     sigCanvas.height = dummyCanvas.height;
                     sigCanvas.getContext('2d').drawImage(dummyCanvas,(sigCanvas.width-dummyCanvas.width)/2,0);
                   } else {
                     sigCanvas.width = dummyCanvas.width;
                     sigCanvas.getContext('2d').drawImage(dummyCanvas,0,(sigCanvas.height-dummyCanvas.height)/2);
                   }
                   $('#iEBox_caption').width(sigCanvas.width);
				   imageEditDialog.enableButtons({Clear:true});
			   }
			      
			   var fwidth = layout.width;
               var fheight = layout.lineHeight;
			   var bottomMargin=2;
               ctx.fillStyle='#555555';
               ctx.font="bold "+layout.fontSize+"pt Arial";
               ctx.fillText(latStr,0,canvasObj.height-2*fheight-bottomMargin);
               ctx.fillText(longStr,0,canvasObj.height-fheight-bottomMargin);
               ctx.fillText(timeStr,0,canvasObj.height-bottomMargin);
			   
			   imageEditDialog._resize();
            }
        }
    },
    _scribbleCallback:function(){
       imageEditDialog.enableButtons({Clear:true,Ok:true});  //  enable clear and ok buttons
    },
    _onImageClick:function(){
       if(!imageEditDialog.getIsOpen()){
           var _that = this;
           imageEditDialog.show("&nbsp;",$.proxy(this._dialogCallback, this));
           if(!this._enforceGeoLoc){
               $('#iEBox_Geo').css({display:'inline-block'});
           }
           var image = new Image();
           image.onload=function(){
               _that.myScribbleHandle = new Scribble("iEBox_canvas",image,image.width,image.height,$.proxy(_that._scribbleCallback,_that));
               _that.myScribbleHandle.setEnabled(!_that._is_readonly);
               $('#iEBox_caption').width(image.width);
               $('#iEBox_container').css({display:'table'});
               imageEditDialog._resize();
               imageEditDialog._reposition();      // recalculate position, so that the values are updated, esp. in iPad
           }
           if(!this.options.value||this.options.value==this._emptyImageVal){
               this._is_readonly=false;
               this.$userControl.addClass("emptyScribble");
               image.src = this._createEmptyImageData();
           } else {
               this.$userControl.removeClass("emptyScribble");
               if(PNGUtil._isPng(this.options.value)){
                   this._is_readonly = !!PNGUtil._isReadOnly(this.options.value);
			       image.src = "data:image/png;base64,"+this.options.value;//this.createBl _that.$userControl.attr(_that.options.commitProperty);
               } else {
                   image.src = "data:;base64," + this.options.value;//this.createBl _that.$userControl.attr(_that.options.commitProperty);
		       }
           }
           this._makeReadOnly(this._is_readonly);
       }
    },

    _extractData:function(datauri){
        var idx;
        if(datauri!=null&&datauri.length>0&&datauri.indexOf("data:")==0){
            if((idx=datauri.indexOf(","))>0){
                return datauri.substr(idx+1);
            }
        }
    },

    _setValue:function(val){
        this.$userControl.prop(this.options.commitProperty, val);
        this.$userControl.attr(this.options.commitProperty, val);
        if(this._dummyImg){
            this._dummyImg.setAttribute(this.options.commitProperty,val);
        }
    }
});
 //hack for IOS5 touch bug
  $(function(){
         $('body').on('touchstart', function(e) {});
  });
  
})($,xfalib);
(function ($, window) {

    var _defaults = {
        placeHolderText : "Enter comments here"
    };

    var AdobeFileAttachment = function (element, options) {
        this.options = options;
        this.$elementFileUploadBtn = [];
        this.$elementFileList = [];
        this.$element = $(element);
        if (this.$element.attr("multiple") && !xfalib.ut.Utilities._isDataContainerSupported()) {
            // remove multiple attribute if multi file selection in one go is not supported
            this.$element.removeAttr("multiple");
        }
        this.$parent = this.$element.parent();
        this.invalidFeature = {
            "SIZE":1,
            "NAME":2,
            "MIMETYPE":3
        };
        Object.freeze(this.invalidFeature);
        // initialize the regex initially
        this.regexMimeTypeList  = this.options.mimeType.map(function (value, i) {
            try {
                return new RegExp(value.trim());
            } catch (e) {
                // failure during regex parsing, don't return anything specific to this value since the value contains
                // incorrect regex string
                if(window.console) {
                    console.log(e);
                }
            }
        });
    };

    var isBrowserIE9OrIE10 = ($.browser.msie && ($.browser.version === '9.0' || $.browser.version === '10.0')),
        fileLabelsCount = 0;


    AdobeFileAttachment.prototype = {
        _fileIframeName : "guide-fu-iframe",
        _addFile : "Add File",

        clear: function () {
            this.$element.val('');
            this.$elementFileList.empty();
        },

        destroy: function () {
            this.$fileDomElements = $.map(this.$fileDomElements, function(item){
                // since item can be null or object, doing this check
                if(_.isObject(item) && item.val().length === 0) {
                    //TODO: remove item from dom, since there is a memory leak
                    return item;
                }
            });
            this.values = [];
            if(isBrowserIE9OrIE10){
                if(_.last(this.$fileDomElements) == null){
                    this.cloneFileInputAndUpdateIdForIE9();
                } else {
                    this.updateLabelForAttr(_.last(this.$fileDomElements).attr("id"));
                }
            }
            this.$element.trigger("change.fileupload");
        },

        _setUrl : function(url, index){
            this.$elementFileList.find("span.guide-fu-fileName").eq(index).data("key", url);
        },

        _getUrl : function(index) {
            return this.$elementFileList.find("span.guide-fu-fileName").eq(index).data("key");
        },
        getSetFilePathAndReturnNamePathMap: function(valueList) {

            var mapOfObjectsHavingTempPathAndFileNames = {},
                $temp,
                tempPath;

            $.each(this.$elementFileList.children(), function ( index, childLiElement) {
                $temp = $(childLiElement).find("span.guide-fu-fileName");
                tempPath = $temp.data("key");
                if(!tempPath && valueList && valueList[index]) {
                    $temp.data("key", valueList[index]);
                }
                mapOfObjectsHavingTempPathAndFileNames[$temp.html()] = tempPath || $temp.data("key");
            });
            return mapOfObjectsHavingTempPathAndFileNames;
        },


        value : function(value) {
            if(!_.isUndefined(value)) {
                var _self = this,
                    comments = this.comment(),
                    isChange = false,
                    fileNames = _.isArray(this.options.fileNames) ? this.options.fileNames : null,
                    oldUrls = {};
                // Cache the url before deletion
                this.$elementFileList.children().find("span.guide-fu-fileName").each(function(){
                    var url = $(this).data("key");
                    if(!_.isUndefined(url)){
                        var fileName = url.substring(url.lastIndexOf("/") + 1);
                        oldUrls[fileName] = url;
                    }
                });
                this.$elementFileList.empty();
                if(value != null) {
                    var arr = value.split("\n");
                    // contruct initial file name and value map
                    // this is done only once in entire live cycle, its done here, since we get value here
                    if (fileNames && _.isEmpty(this._initialFileValueFileNameMap)) {
                        for (var index = 0; index < fileNames.length; index++) {
                            _self._initialFileValueFileNameMap[arr[index]] = fileNames[index]
                        }
                    }
                    // Update the value array with the file
                    this.values = _.map(arr, function(fileName, index){
                        // Check if file Name is a path, if yes get the last part after "/"
                        var slash = fileName.lastIndexOf("/"),
                            fileUrl = fileName,
                            fileUploadUrl = null;
                        if(slash !== -1) {
                            // Store the cached url here
                            fileUrl = fileUploadUrl = fileName;
                            fileName = fileName.substring(slash + 1);
                            // case: when you click on save second time
                            if((_.isObject(_self.$fileDomElements[index]) && _self.$fileDomElements[index].val().length > 0) || _.isString(_self.$fileDomElements[index])){
                                isChange = true;
                                _self.$fileDomElements[index] = null;
                            } else if(_self.$fileDomElements[index] !== null) { // create a dummy file dom for the cached value
                                 isChange = true;
                                _self.$fileDomElements.splice(index, 0, null);
                            }
                        } else if (oldUrls[fileName]) {
                            fileUploadUrl = oldUrls[fileName];
                        }
                        // if fileNames options is explicitly passed, use it
                        if (fileNames && _self._initialFileValueFileNameMap[fileUrl]) {
                            fileName = _self._initialFileValueFileNameMap[fileUrl];
                        }
                        _self.showFileList(fileName, comments[index], fileUploadUrl);
                        return fileUrl;
                    });
                    if(isChange){
                        this.$element.trigger("change.fileupload");
                    }
                } else {
                    if(_.isArray(this.values) && this.values.length !== 0){
                        this.destroy();
                    }
                }
            }
            else {
                return this.values;
            }
        },

        fileAttachment: function(){
            return this.values;
        },

        comment : function(value){
            var _self = this,
                $elem = null,
                comments;
            if (!_.isUndefined(value)) {
                if(value != null) {
                    comments = value.split("\n");
                    $elem = this.$elementFileList.find('div.guide-fu-comment');
                    $elem.each(function(index){
                        $(this).text(comments[index]);
                    });
                }
            }
            else {
                $elem = this.$elementFileList.find('div.guide-fu-comment');
                comments = [];
                $elem.each(function(){
                    comments.push($(this).text());
                });
                return comments;
            }
        },

        multiSelect : function(value){
            if(value !== undefined)
                this.options.multiSelect = value;
            else
                return this.options.multiSelect;
        },

        fileSizeLimit : function(value){
            if(value !== undefined)
                this.options.fileSizeLimit = value;
            else
                return this.options.fileSizeLimit;
        },

        mimeType : function(value){
            if(value !== undefined)
                this.options.mimeType = value;
            else
                return this.options.mimeType;
        },

        access : function(value){
            if(value == "readOnly") {
                this.$element.attr("disabled", "disabled");
                //for readOnly hide the delete icon in file list
                $(this.$parent).addClass('guide-fu-disabled');
            }
            else if(value == "open") {
                this.$element.removeAttr("disabled");
                $(this.$parent).removeClass('guide-fu-disabled');
            }
        },

        fileList : function(value) {
            var filtered,
                _self = this;
            if(value !== undefined){
                this.$fileDomElements = [];
                _.each(value, function(item, index){
                    if((_.isObject(item) && (isBrowserIE9OrIE10 || item.val().length > 0)) || (_.isString(item))){
                         // check if index is within the length
                         // this is written for delete case
                         // if item is a string, then it should be set null
                         if(_.isString(item)){
                             item = null;
                         }
                         _self.$fileDomElements[index] = item;
                    }
                });
                filtered = this.$fileDomElements;
                // In case of IE9, get the last element of fileDom and update the id for label
                if(isBrowserIE9OrIE10 && value !== null){
                    // Case: if it is single select, and then we do a restore and then after attaching another file we click save
                    if(_.last(this.$fileDomElements) == null){
                        this.cloneFileInputAndUpdateIdForIE9();
                    } else {
                        this.updateLabelForAttr(_.last(this.$fileDomElements).attr("id"));
                    }
                }
            }
            else {
                // here filtered is a new array
                // A new array is returned over here so that the user of this API doesn't try to change the widget array directly
                filtered = $.map(this.$fileDomElements, function(item, index){
                    if(!item) {
                        return _self._getUrl(index);
                    } else if((item[0].files && item[0].files.length !== 0)
                            || (_self.options.multiSelect || item[0].value.length > 0)) {
                        return item;
                    }
                });
            }
            return filtered;
        },

        // file preview html
        fileItemPreview: function(){
            return $("<span></span>").addClass("guide-fu-filePreview glyphicon glyphicon-ok");
        },

        // force flag indicates that forcefully set the dom but don't update the options
        buttonText: function (value, force) {
            if (value !== undefined) {
                if(!force)
                    this.options.buttonText = value;
                this.$elementFileUploadBtn.find('span.guide-fu-label').html(value);
            } else {
                return this.options.buttonText;
            }
        },

        // To change the icon of the button, the user should customize the class
        btnIcon: function () {
            return $("<span></span>").addClass("guide-fu-icon glyphicon glyphicon-folder-open");
        },

        btnLabel: function(){
            return $("<span></span>").addClass("guide-fu-label").html(this.options.buttonText);
        },

        fileItemList: function(){
            return this.$parent.find(this.options.fileItemListClass);
        },

        getNewCommentElementSummary : function(text){
            return $("<div title='Click to edit' tabindex='0'></p>").addClass("guide-fu-comment").text(text || _defaults.placeHolderText);
        },

        getNewCommentElement : function(text){
            return $("<div contenteditable='true' tabindex='0'></div>").addClass("guide-fu-comment").text(text || "");
        },

        fileItem: function(fileName, comment, fileUrl){
            var $fileItem = $("<li></li>").addClass("guide-fu-fileItem");
            var nameWithoutMarker = xfalib.ut.Utilities._getNameWithoutMarker(fileName);
            var $elem = $("<span tabindex='0'></span>").addClass("guide-fu-fileName").attr("aria-label", nameWithoutMarker).text(nameWithoutMarker).appendTo($fileItem).keypress(function(e) {
                if (e.keyCode === 13 || e.charCode === 32) {
                    $(e.target).click();
                }
            }).click($.proxy(this.handleFilePreview, this));
            if(this.options.disablePreview) {
               $elem.addClass('non-preview-fileName');
            }
            if(fileUrl != null){
                $elem.attr("data-key", fileUrl);
            }
            $("<span tabindex='0'></span>").addClass("guide-fu-fileClose close").attr("role", "button").attr("aria-label", xfalib.locale.Strings.FileCloseAccessText + nameWithoutMarker).text("x").appendTo($fileItem).keypress(function(e) {
                if (e.keyCode === 13 || e.charCode === 32) {
                    $(e.target).click();
                }
            })
                .click($.proxy(this.handleClick, this));

            this.fileItemPreview().appendTo($fileItem);

            if(this.options.showComment){
                this.getNewCommentElementSummary(comment).appendTo($fileItem).focus($.proxy(this.handleCommentClick, this)).click($.proxy(this.handleCommentClick, this));
            }
            return $fileItem;
        },

        toggleFileUploadBtn: function(){
            if(this.options.multiSelect) {
                // Change the look of file upload button
                if(this.$elementFileList.children().length > 0){
                    // Change the text
                    this.buttonText(this._addFile, true);
                    // Change the icon too
                    this.$elementFileUploadBtn.find('span.guide-fu-icon').removeClass("glyphicon-folder-open").addClass("glyphicon-plus");
                } else {
                    this.buttonText(this.options.buttonText);
                    this.$elementFileUploadBtn.find('span.guide-fu-icon').removeClass("glyphicon-plus").addClass("glyphicon-folder-open");
                }
            }
        },

        showInvalidMessage: function(fileName, invalidFeature){
            var that = this;
            var IS_IPAD = navigator.userAgent.match(/iPad/i) !== null,
                IS_IPHONE = (navigator.userAgent.match(/iPhone/i) !== null);
            if(IS_IPAD || IS_IPHONE){
                setTimeout(function() {
                  that.invalidMessage(that,fileName, invalidFeature);
                }, 0);
            }
            else {
               this.invalidMessage(this,fileName, invalidFeature);
            }
        },

        invalidMessage: function(refObj,fileName, invalidFeature){
            if(invalidFeature === refObj.invalidFeature.SIZE) {
                alert(xfalib.ut.LocalizationUtil.prototype.getLocalizedMessage("", xfalib.locale.Strings["FileSizeGreater"], [fileName, refObj.options.fileSizeLimit]));
            } else if (invalidFeature === refObj.invalidFeature.NAME) {
                alert(xfalib.ut.LocalizationUtil.prototype.getLocalizedMessage("", xfalib.locale.Strings["FileNameInvalid"], [fileName]));
            } else if (invalidFeature === refObj.invalidFeature.MIMETYPE) {
                alert(xfalib.ut.LocalizationUtil.prototype.getLocalizedMessage("", xfalib.locale.Strings["FileMimeTypeInvalid"], [fileName]));
            }
        },

        /***
         * Finds the value in the array, if the value is a url then it uses the filename in the url to search for the text
         * This is done since our model stores the URL too in case of draft restore or clicking on save in guide
         * @param text          string representing the text of which the index is to be found
         * @param $elem         reference to the jquery element. This is used if there are duplicate file names present in the file upload.
         * @returns {number}
         * @private
         */
        _getIndexOfText : function(text, $elem){
            var index = -1,
                self = this,
                isDuplicatePresent = false;
            _.find(this.values, function(value, iter){
                // if value is a url, then compare with last
                var tempValue = value,
                    // can't use getOrElse here since value can have "." in URL and getOrElse splits based on period to find key inside object
                    fileName =  (_.isObject(self._initialFileValueFileNameMap) && typeof self._initialFileValueFileNameMap[value] !== undefined) ? self._initialFileValueFileNameMap[value] : null;
                if(tempValue.match(/\//g) && tempValue.match(/\//g).length > 1){
                    tempValue =  value.substring(value.lastIndexOf("/")+1);
                    tempValue = xfalib.ut.Utilities._getNameWithoutMarker(tempValue);
                }
                // we pass file name explicityly as options, if passed use that as fallback to find the URL
                if(tempValue === text || fileName === text){
                    index = iter;
                    isDuplicatePresent = self.values.indexOf(value, index + 1) !== -1;
                    if($elem && isDuplicatePresent){
                        // now check if duplicate present and get its correct index
                        // today all files are wrapped under .guide-fu-fileItem node
                        index = $elem.closest(".guide-fu-fileItem").index();
                    }
                    // check if there is a duplicate
                    // this is to just break the loop
                    return value;
                }
            });
            return index;
        },


        /*
         * Since input file element might contain multiple files.
         * This function takes absolute file index as parameter & returns position of the file w.r.t input file elt
         */
        _getFileObjIdx : function (index) {
            if (index >= 0) {
                var currentIdx = 0;
                for (var fileInputEltIdx = 0; fileInputEltIdx < this.$fileDomElements.length; fileInputEltIdx++) {
                    if (this.$fileDomElements[fileInputEltIdx]) {
                        var files = this.$fileDomElements[fileInputEltIdx][0].files;
                        if (files) {
                            var filesLength =  files.length;
                            if ( index <= currentIdx + filesLength - 1 ) {
                                return [fileInputEltIdx, index - currentIdx];
                            }
                            currentIdx+=files.length;
                        }
                    } else {
                        if (index == currentIdx) {
                            return [fileInputEltIdx,0];
                        }
                        currentIdx++;
                    }
                }
            }
            return null;
        },

        /*
         * This function returns FileList object of the passed file array
         */
        _getFileListItem : function (files) {
            try {
                var dataContainer = new DataTransfer() || (new ClipboardEvent("")).clipboardData;
                _.each(files, function (file) {
                    dataContainer.items.add(file);
                });
                return dataContainer.files;
            } catch(err) {
                console.error(err);
                throw err;
            }
        },

        _updateFilesInDom : function($fileDom, files) {
            // in safari, a change event is trigged if files property is changed dynamically
            // hence adding this check to clear existing state only for safari browsers
            this._isFileUpdate = true;
            $fileDom[0].files = this._getFileListItem(files);
            this._isFileUpdate = false;
        },

        /*
         * This function deletes files at specified indexes from input dom elt
         */
        _deleteFilesFromInputDom : function ($fileDomElt, deletedIndexes) {
            var remainingFiles = [];
            _.each($fileDomElt[0].files, function(file,idx){
                if(!deletedIndexes.includes(idx)){
                    remainingFiles.push(file);
                }
            });
            try {
                // in safari, a change event is trigged if files property is changed dynamically
                // hence adding this check to clear existing state only for safari browsers
                this._updateFilesInDom($fileDomElt, remainingFiles);
            } catch(err){
                console.error("Deleting files is not supported in your browser");
            }
        },

        /**
         * This event listener gets called on click of close button in file upload
         *
         * @param event
         */
        handleClick: function(event){

            var $elem = $(event.target),
                text = $elem.prev().text(),
                index = this._getIndexOfText(text, $elem),
                url = $elem.prev().data("key"),
                objectUrl = $elem.prev().data("objectUrl");
            if (index != -1) {
                this.values.splice(index, 1);
                var fileObjIdx = this._getFileObjIdx(index);
                var $fileDomElt = this.$fileDomElements[fileObjIdx[0]];
                if (!$fileDomElt || $fileDomElt[0].files.length === 1) {
                    this.$fileDomElements.splice(fileObjIdx[0], 1);
                } else {
                    this._deleteFilesFromInputDom($fileDomElt, [fileObjIdx[1]]);
                }
                if (isBrowserIE9OrIE10) {
                    this.cloneFileInputAndUpdateIdForIE9();
                }
                if (url != null) {
                    // remove the data so that others don't use this url
                    $elem.prev().removeData("key");
                }
                if(objectUrl) {
                    // revoke the object URL to avoid memory leaks in browser
                    // since file is anyways getting deleted, remove the object URL's too
                    window.URL.revokeObjectURL(objectUrl);
                }
            }
            // Remove the dom from view
            //All bound events and jQuery data associated with the element are also removed
            $elem.parent().remove();
            // trigger the change event to update the value
            this.$element.trigger("change.fileupload");
            // Set the focus on file upload button after click of close
            this.$elementFileUploadBtn.focus();

        },


        _previewFileUsingObjectUrl : function (file) {
            if (file) {
                if (window.navigator && window.navigator.msSaveOrOpenBlob) { // for IE
                    window.navigator.msSaveOrOpenBlob(file, file.name);
                } else {
                    var url = window.URL.createObjectURL(file);
                    window.open(url, '', 'scrollbars=no,menubar=no,height=600,width=800,resizable=yes,toolbar=no,status=no');
                    return url;
                }
            }
        },

        // this function maintains a map for
        handleFilePreview: function(event){
            if(!this.options.disablePreview) {
                var $elem = $(event.target),
                    text = $elem.text(),
                    index = this._getIndexOfText(text, $elem),
                    fileDom = null,
                    fileName = null,
                    fileUrl = null,
                    timeStamp = new Date().getTime();

                // for draft usecase, if text contains "/" in it, it means the file is already uploaded
                // text should contain the path, assuming that the fileUrl is stored in data element

                if (index != -1) {
                    // Store the url of file as data
                    if(!_.isUndefined($elem.data("key")))
                        fileUrl = $elem.data("key");

                    if(fileUrl)  {
                        //prepend context path if not already appended
                        if (!(fileUrl.lastIndexOf(this.options._getUrl, 0) === 0)) {
                            fileUrl =  this.options._getUrl + fileUrl;
                        }
                        this.previewFile.apply(this, [null, {"fileUrl" : fileUrl}]);
                    } else {
                        var previewFileObjIdx = this._getFileObjIdx(index);
                        var previewFile = this.$fileDomElements[previewFileObjIdx[0]][0].files[previewFileObjIdx[1]];
                        var objectUrl = this._previewFileUsingObjectUrl(previewFile);
                        if (objectUrl) {
                            $elem.data("objectUrl", objectUrl);
                        }
                    }
                }
            }
        },

        previewFile: function(event){
            var url = null;
            if(_.isUndefined(arguments[1]))
                url = this.$element[this.options.uploaderPluginName]("getFileUrl");
            else
                url = arguments[1].fileUrl;
            var lastIndex = url.lastIndexOf('/');
            //to make sure url has a slash '/'
            if(lastIndex >= 0) {
                //encode the filename after last slash to ensure the handling of special characters
                url = url.substr(0, lastIndex) +'/'+ encodeURIComponent(url.substr(lastIndex + 1));
            }
            // this would work for dataURl or normal URL
            // todo: add support to preview base 64 encoded image, to preview base64 encoded binary, we would probably need
            // todo: the content type in the widget too
            window.open(url, '', 'scrollbars=no,menubar=no,height=600,width=800,resizable=yes,toolbar=no,status=no');

        },

        resetIfNotMultiSelect: function(){
            if(!this.options.multiSelect){
                // Reset the value and file array
                this.values = [];
                //this.comments = [];
            }
        },

        showFileList: function(fileName, comment, fileUrl){
            if(!this.options.multiSelect || fileName == null || _.isUndefined(fileName)) {
                // if not multiselect, remove all the children of file list
                this.$elementFileList.empty();
            }

            // Add the file item
            // On click of close, remove the element and update the model
            // handle on click of preview button
            if(fileName != null) {
                this.$fileItem = this.$elementFileList.append(this.fileItem(fileName, comment, fileUrl));
            }
        },

        /**
         * Handles the click on comment field
         *
         * TODO: Implement show/hide behaviour instead of replaceWith
         * This may be cause problem during bubble up of event
         *
         * @param event
         */
        handleCommentClick : function(event){
            var $commentElem = null,
                $elem = $(event.target);
            if ($elem.text() === _defaults.placeHolderText) {
                $commentElem = this.getNewCommentElement()
            } else {
                $commentElem = this.getNewCommentElement($(event.target).text());
            }
            $elem.replaceWith($commentElem);
            // register the event again
            if(isBrowserIE9OrIE10){
                $commentElem.focus().focusout($.proxy(this.handleCommentBlur, this));
            } else {
                $commentElem.focus().blur($.proxy(this.handleCommentBlur, this));
            }
        },

        handleCommentBlur : function(event){
            var $commentSummaryElem = null,
                $elem = $(event.target);
            if ($elem.text() === _defaults.placeHolderText) {
                $commentSummaryElem = this.getNewCommentElementSummary();
            } else {
                $commentSummaryElem = this.getNewCommentElementSummary($(event.target).text());
            }
            $elem.replaceWith($commentSummaryElem);
            $commentSummaryElem.focus($.proxy(this.handleCommentClick,this)).click($.proxy(this.handleCommentClick,this));
            // Add a div with the html
            this.$element.trigger("change.fileupload");
        },

        // checks if file name is valid or not to prevent security threats
        isValid : function(fname) {
            var rg1=/^[^\\/:\*\;\$\%\?"<>\|]+$/; // forbidden characters \ / : * ? " < > | ; % $
            var rg2=/^\./; // cannot start with dot (.)
            var rg3=/^(nul|prn|con|lpt[0-9]|com[0-9])(\.|$)/i; // forbidden file names
            return rg1.test(fname) && !rg2.test(fname) && !rg3.test(fname);
        },

        handleChange: function (evnt) {
            if (!this._isFileUpdate) {
                var currFileName = '',
                    inValidSizefileNames = '',
                    inValidNamefileNames = '',
                    inValidMimeTypefileNames = '',
                    $elem = $(evnt.target),
                    files = $elem[0].files;
                // Initially set the invalid flag to false
                // if not multiselect then remove the extra domELement clone
                if (!this.options.multiSelect && this.$fileDomElements.length > 1) {
                    this.$fileDomElements.splice(0, 1)
                }

                var isInvalidSize = false,
                    isInvalidFileName = false,
                    isInvalidMimeType = false;
                this.resetIfNotMultiSelect();
                // Iterate through all the files
                if (isBrowserIE9OrIE10) { // IE9 doesn't support FileList, hence files variable is undefined
                    currFileName = $elem.val().split("\\").pop();
                    //update the last element of array
                    if (this.$fileDomElements.length > 0) {
                        this.$fileDomElements[this.$fileDomElements.length - 1] = $elem;
                    }
                    this.cloneFileInputAndUpdateIdForIE9();

                    // In case of IE9, only do this
                    if (_.isUndefined(files)) {
                        this.showFileList(currFileName);
                        this.values.push(currFileName);
                        // trigger the change event to update the value
                        this.$element.trigger("change.fileupload");
                    }
                }
                if (!_.isUndefined(files)) {
                    var invalidFilesIndexes = [];
                    _.each(files, function (file, fileIndex) {
                        var isCurrentInvalidFileSize = false,
                            isCurrentInvalidFileName = false,
                            isCurrentInvalidMimeType = false;
                        currFileName = file.name.split("\\").pop();
                        // Now size is in MB
                        var size = file.size / 1024 / 1024;
                        // check if file size limit is within limits
                        if ((size > parseFloat(this.options.fileSizeLimit))) {
                            isInvalidSize = isCurrentInvalidFileSize = true;
                            inValidSizefileNames = currFileName + "," + inValidSizefileNames;
                        } else if (!this.isValid(currFileName)) {
                            // check if file names are valid (ie) there are no control characters in file names
                            isInvalidFileName = isCurrentInvalidFileName = true;
                            inValidNamefileNames = currFileName + "," + inValidNamefileNames;
                        } else if (file.type) {
                            var isMatch = this.regexMimeTypeList.some(function (rx) {
                                return rx.test(file.type);
                            });
                            if (!isMatch) {
                                isInvalidMimeType = isCurrentInvalidMimeType = true;
                                inValidMimeTypefileNames = currFileName + "," + inValidMimeTypefileNames;
                            }
                        }

                        // if the file is not invalid, show it and push it to internal array
                        if (!isCurrentInvalidFileSize && !isCurrentInvalidFileName && !isCurrentInvalidMimeType) {
                            this.showFileList(currFileName);
                            this.values.push(currFileName);
                        } else {
                            invalidFilesIndexes.push(fileIndex);
                        }


                    }, this);

                    if (invalidFilesIndexes.length > 0) {
                        var currentFileDomIndex,
                            $currentFileDomElement,
                            filesCount;
                        if (this.$fileDomElements.length > 0) {
                            currentFileDomIndex = this.$fileDomElements.length - 1;
                            $currentFileDomElement = this.$fileDomElements[currentFileDomIndex];
                            if ($currentFileDomElement && $currentFileDomElement.length > 0) {
                                filesCount = $currentFileDomElement[0].files.length;
                                //if all the files are invalid remove the input element as well otherwise only remove the invalid files.
                                if (filesCount === invalidFilesIndexes.length) {
                                    this.$fileDomElements.splice(-1, 1);
                                } else {
                                    this._deleteFilesFromInputDom($currentFileDomElement, invalidFilesIndexes);
                                }
                            }
                        }

                        // in case of IE10, create one extra element
                        if (isBrowserIE9OrIE10) {
                            this.cloneFileInputAndUpdateIdForIE9();
                        }
                    }

                    // trigger the change event to update the value
                    this.$element.trigger("change.fileupload");
                }

                if (isInvalidSize) {
                    this.showInvalidMessage(inValidSizefileNames.substring(0, inValidSizefileNames.lastIndexOf(',')), this.invalidFeature.SIZE);
                } else if (isInvalidFileName) {
                    this.showInvalidMessage(inValidNamefileNames.substring(0, inValidNamefileNames.lastIndexOf(',')), this.invalidFeature.NAME);
                } else if (isInvalidMimeType) {
                    this.showInvalidMessage(inValidMimeTypefileNames.substring(0, inValidMimeTypefileNames.lastIndexOf(',')), this.invalidFeature.MIMETYPE);
                }
            }
        },

        cloneFileInputAndUpdateIdForIE9 : function(){
            var elem = _.last(this.$fileDomElements),
                elemExists = elem != null,
                elemHasValue = elemExists && elem.val().length > 0,
                elemId = null,
                selector = null;

            // CQ-4237903 : create clone to handle the case when user clicks cancel in chrome and for multiselect
            // on clicking cancel in chrome file browser, chrome removes all the files from the input element
            // remove the extra clone in $fileDomElement on handleChange
            if(!elemExists || elemHasValue) {
                elem = this.$element.clone();
                // copy the data attributes
                elem.data(this.$element.data());
                if(isBrowserIE9OrIE10){
                    elemId = this.$element.attr("id") + (++fileLabelsCount);
                    elem.attr("id", elemId);
                    elem.css({
                        'position' : 'absolute',
                        'top' : '-2000px',
                        'left': '-2000px'
                    });
                    elem.appendTo('body');
                    this.updateLabelForAttr(elemId);
                }
                elem.change($.proxy(this.handleChange, this));
                this.$fileDomElements.push(elem);
            }
            // Case: if it is not multiselect and if the first file dom element is null
            // this case would hit when we restore a single select file attachment and attach a new file
            if(!this.options.multiSelect && this.$fileDomElements[0] === null){
                //Splice null out of it, since we are attaching a new file
                this.$fileDomElements.splice(0, 1);
            }
            // if the browser is not IE9, then click it
            if(!isBrowserIE9OrIE10) {
                elem.click();
            }
            return true;
        },

        /**
         * In case of IE9, get the last element of fileDom and update the id for label
         *
         * @param fileInputId
         */
        updateLabelForAttr : function(fileInputId){
            this.$label.attr("for" , fileInputId);
        },

        createLabelForFileInput : function (fileInputId){
            if(isBrowserIE9OrIE10) {
                this.$label = $("<label></label>").addClass("guide-fu-attach-button button")
                        .text(this.options.buttonText)
                        .attr('for',fileInputId);
                this.$elementFileUploadBtn.replaceWith(this.$label);
                this.$label.parent().attr("tabindex", 0).attr("role", "button").attr("aria-label", this.options.screenReaderText || "");
            }
        },


        constructor: function () {
            // Initialize the self instance
            var _self = this,
                isFirst = true;
            //jquery instance of file upload button
            this.$elementFileUploadBtn = this.$parent.find(this.options.buttonClass);
            this.$elementFileUploadBtn.attr("aria-label", this.options.screenReaderText || "");
            if(isBrowserIE9OrIE10){
                this.elementId = this.$element.attr("id");
                this.createLabelForFileInput(this.$element.attr("id"));
            }

            // html for file list
            this.$elementFileList = $(this.fileItemList());
            // Initialize the value and file(Refer FileList class mdn)
            this.values = [];
            this._initialFileValueFileNameMap = {};
            // List of dom elements of input type file
            this.$fileDomElements = [];

            var flag = false,
                $currElem = null;

            $(document).mousedown(function(e) {
                $currElem = $(e.target);
            });
            // Enter key should result in click of button
            this.$elementFileUploadBtn
                .focus(function(){
                    _self.$element.trigger("focus.fileupload");
                })
                .click($.proxy(this.cloneFileInputAndUpdateIdForIE9, this))
                .blur(function(event){
                    // Check if the currElem does not belong to the fileItemList
                    if(!flag && $currElem!= null && $currElem.closest(".guide-fu-fileItemList").length <=0){
                        _self.$element.trigger("focusout.fileupload");
                    }
                    flag = false;
                });
            //Initialize the filePreview Plugin
            this.$element[this.options.uploaderPluginName]({
                iframeContainer: this.options.iframeContainer,
                _filePath: this.options._filePath,
                _uuidGenerator: this.options._uuidGenerator,
                _getUrl: this.options._getUrl

            });
            // Getting input file value
            // listening on fileuploaded event
            this.$element.change($.proxy(this.handleChange, this))
                .on("adobeFileUploader.fileUploaded", $.proxy(this.previewFile, this));
        }
    };

    $.fn.adobeFileAttachment = function (option, value) {
        var get = '',
            element = this.each(function () {
                // in case of input type file
                if ($(this).attr('type') === 'file') {
                    var $this = $(this),
                        data = $this.data('adobeFileAttachment'),
                        options = $.extend({}, AdobeFileAttachment.prototype.defaults, typeof option === 'object' && option);

                    // Save the adobeFileAttachment data in jquery
                    if (!data) {
                        $this.data('adobeFileAttachment', (data = new AdobeFileAttachment(this, options)));
                        data.constructor();
                    }

                    // code to get and set an option
                    if (typeof option === 'string') {
                        get = data[option](value);
                    }
                }
            });

        if (typeof get !== 'undefined') {
            return get;
        } else {
            return element;
        }
    };

    // fileSizeLimit is in MB, default value is 2MB
    AdobeFileAttachment.prototype.defaults = {
        'buttonText': 'Attach',
        'multiSelect': false,
        'fileSizeLimit': 2,
        'uploaderPluginName': "adobeFileUploader",
        'mimeType' : ['audio/*', 'video/*', 'image/*', 'text/*', 'application/pdf']
    };

})($, window);
(function($) {
    var xfaUtil = xfalib.ut.XfaUtil.prototype;
    $.widget( "xfaWidget.fileUpload", $.xfaWidget.abstractWidget, {

        _widgetName:"fileUpload",
        _superPrototype : $.xfaWidget.abstractWidget.prototype,
        getOptionsMap: function(){
            var parentOptionsMap = this._superPrototype.getOptionsMap.apply(this,arguments),
                newMap = $.extend({},parentOptionsMap, $.extend({}, this.options, {
                    "value" : function(value) {
                        this.$userControl.adobeFileAttachment("value", value);
                    },
                    "fileList": function(value){
                        this.$userControl.adobeFileAttachment("fileList", value);
                    },
                    "comment" : function(value){
                        this.$userControl.adobeFileAttachment("comment", value);
                    },
                    // "access" can be either open or readonly
                    "access" : function(value){
                        this.$userControl.adobeFileAttachment("access", value);
                    }

                }));

            return newMap;

        },
        // TODO: Will need to remove this functions
        //  will be tracked by LC-391200

        _initializeOptions: function () {
            _.each(this.optionsHandler, function (value, key) {
                // overriding the behaviour of _initializeOptions
                // only for _uuidGenerator
                // as we font want getUUID to be called at render time
                if (typeof value === "function" && key !== '_uuidGenerator' ) {
                        value.apply(this, [this.options[key]])
                }
            }, this)
        },

        _getFileList: function(){
            return this.$userControl.adobeFileAttachment("fileList");
        },

        _getComment: function(){
            return this.$userControl.adobeFileAttachment("comment");
        },
        _getFileNamePathMap: function (pathList) {
            return this.$userControl.adobeFileAttachment("getSetFilePathAndReturnNamePathMap", pathList);
        },
        getEventMap: function() {
            var parentEventMap = this._superPrototype.getEventMap.apply(this, arguments),
                newMap = $.extend({}, parentEventMap,
                    {
                        "change" : null,
                        "focusout.fileupload" : xfaUtil.XFA_EXIT_EVENT,
                        "focus.fileupload" : xfaUtil.XFA_ENTER_EVENT,
                        "change.fileupload" : xfaUtil.XFA_CHANGE_EVENT
                    });
            return newMap;
        },
        render: function() {
            var $el = this._superPrototype.render.apply(this,arguments);
            $el.adobeFileAttachment(this.getOptionsMap());
            return $el;
        },
        showDisplayValue: function() {
             //since value can't be set in file element input, leaving this fn empty
        },
        showValue: function() {
            //since value can't be set in file element input, leaving this fn empty
        },
        getCommitValue: function() {
            this.options.fileList = this._getFileList();
            this.options.comment = this._getComment();
            return this.$userControl.adobeFileAttachment("value");
        }
    });
})($);

/**
 * Adobe FilePreview Widget Plugin
 *
 * Options expected by file preview is the url
 *
 * Options Required Are:
 *
 *  iframeName: Name of the Iframe
 *  iframeContainer: Container of the iframe(eg Body)
 *  fileUploadPath: Path where the file is to be uploaded
 *  fileUploadServlet: Servlet where the file is to be uploaded
 *
 */
(function ($) {

    var AdobeFileUploader = function (element, options) {
        this.options = options;
        this.$element = $(element);
    };

    AdobeFileUploader.prototype = {

        _fileIframeName: "guide-fu-iframe",

        _filePath: "/tmp/fd/mf",

        _iframeContainer: "body#formBody",


        fileIframe: function (name) {
            return $("<iframe></iframe>").attr({
                style: "display:none",
                name: name
            });
        },

        uploadFile: function (fileObject) {
            var multiple = false,
                fileName = null,
                actionUrl = null,
                fileUploadPath = fileObject.fileUploadPath,
                uuid;

            if (!fileUploadPath) {
                uuid = fileObject._uuidGenerator();
            }

            // if uuid exists only then upload the file in the current  instance
            if (_.isObject(fileObject) && (fileUploadPath || uuid)) {
                var fileDom = fileObject.fileDom,
                    $form = $(this.options.iframeContainer).find(".filePreview");
                fileName = fileObject.fileName;
                multiple = fileObject.multiple;
                if(!fileUploadPath) {
                    fileUploadPath = this.options.fileUploadPath + "/" + uuid;
                }
                if (fileDom !== null) {
                    //prepend contextpath
                    actionUrl = fileObject._getUrl + fileUploadPath;
                    if (!multiple) {
                        if (!(fileUploadPath.lastIndexOf(fileObject._getUrl, 0) === 0)) {
                            this.fileUrl = fileObject._getUrl + fileUploadPath + "/" + fileName;
                        } else {
                            this.fileUrl = fileUploadPath + "/" + fileName;
                        }
                    } else {
                        this.fileUrl = actionUrl;
                    }
                    // done to solve issue LC-5835
                    if($form.length === 0) {
                        $form = $("<form method='post' enctype='multipart/form-data'/>")
                            .addClass("filePreview")
                            // create id so that it does not intercept with other forms in the page
                            .attr({
                                id : "form" + new Date().valueOf(),
                                action : actionUrl,
                                target : this.options.iframeName
                            })
                            .appendTo(this.options.iframeContainer);
                    } else {
                        /// first empty all children, using detach so that data is not clear
                        $form.children().detach();
                        // now update the new attributes
                        $form.attr({
                            action : actionUrl,
                            target : this.options.iframeName
                        });
                    }
                    // this is done so that the other events attached at some other level in DOM Tree don't interfere
                    $form.one("submit", function(evnt){
                        evnt.stopPropagation();
                    });

                     var data = new FormData();

                    if (multiple) {
                        _.each(fileDom, function (fileDomElement, index) {
                            // OOTB, this code is still used in dashboard
                            if(fileDomElement !== null && !_.isString(fileDomElement)) {
                                $(fileDomElement[0]).attr('name', fileName[index]).appendTo($form);
                                // fileDomElement might contain multiple files so all the files needs to be added to formdata.
                                var currentFileNames = fileName[index].split("\n");
                                for(var fileIndex = 0; fileIndex < currentFileNames.length; fileIndex++) {
                                    data.append(currentFileNames[fileIndex], fileDomElement[0].files[fileIndex]);
                                }
                            }
                        }, this);
                    } else {
                        fileDom.attr('name', fileName).appendTo($form);
                        data.append(fileName, fileDom[0].files[0]);
                    }

                    /* UseCase: Suppose the fileName is in other language, on click of fileName, it tries to upload the file
                     so that it could be preview, this change would ensure that the file is properly previewed supporting
                     the given UTF-8 charset */
                    $("<input type='hidden' name='_charset_' value='UTF-8'/>").appendTo($form);
                    data.append("_charset_", "UTF-8");
                    if (!multiple) {
                        this.fileMap[this.fileUrl] = this.$element;
                    }
                    var self = this;
                    $.ajax({
                        url: $form.attr("action"),
                        data: data,
                        cache: false,
                        contentType: false,
                        processData: false,
                        method: 'POST',
                        type: 'POST',
                        success: function(data){
                            if (!multiple) {
                                self.handleSingleFileUpload(data);
                            } else {
                                self.handleMultipleFileUpload(data);
                            }
                        },
                        error: function() {
                            this.$element.trigger("adobeFileUploader.fileUploadFailed");
                        }
                    });
                }
            }
            return this.fileUrl;
        },

        handleMultipleFileUpload: function (data) {
            this.$element.trigger("adobeFileUploader.multipleFileUploaded");
        },

        getFileUrl: function () {
            return this.fileUrl;
        },

        getUrlContentsFromUploadData: function (data) {
            var temp;
            if(data != null) {
                temp = $(data).find("#ChangeLog").text().split("br", 2)[1];
            } else {
                var selector = this.options.iframeContainer + " iframe[name='" + this.options.iframeName + "']";
                temp = $(selector).contents().find("#ChangeLog").text().split("br", 2)[1];
            }
            
            temp = temp.substring(temp.indexOf("created") + 9, temp.indexOf(";<"));
            temp = temp.substring(0, temp.length - 2);
            var index = temp.indexOf("/jcr:content");
            if (index !== -1)
                temp = temp.substring(0, index);
            return temp;
        },

        handleSingleFileUpload: function (data) {
            var url = this.getUrlContentsFromUploadData(data);

            //prepend context path
            url = this.options._getUrl + url;
            if (url in this.fileMap) {
                this.fileMap[url].trigger("adobeFileUploader.fileUploaded");
            }
        },

        initialize: function () {
            // Put iframe inside the iframe container
            // On the load of iframe, display the contents of file
            // since there is only one iframe for all the file attachments, there may be race condition
            if (this.$iframe == null || this.$iframe.length === 0) {
                this.$iframe = this.fileIframe(this.options.iframeName).appendTo(this.options.iframeContainer);
                // since there is only iframe for the preview of all file attachments
                // this map is added in the closure scope
                // map contains the url(key) vs fileDomElement(value)
                // it helps avoids the race condition
                this.fileMap = {};
            }
        }
    };

    $.fn.adobeFileUploader = function (option, value) {
        var get = '',
            element = this.each(function () {
                // in case of input type file
                if ($(this).attr('type') === 'file') {
                    var $this = $(this),
                        data = $this.data('adobeFileUploader'),
                        options = $.extend({}, AdobeFileUploader.prototype.defaults(option, value), typeof option === 'object' && option);

                    // Save the adobeFileAttachment data in jquery
                    if (!data) {
                        $this.data('adobeFileUploader', (data = new AdobeFileUploader(this, options)));
                        data.initialize();
                    } else {
                        // update elements if not equal, since sometimes one can clone too
                        if(data.$element.get(0) !== this) {
                            data.$element = $(this);
                        }
                    }

                    // code to get and set an option
                    if (typeof option === 'string') {
                        get = data[option](value);
                    }
                }
            });

        if (typeof get !== 'undefined') {
            return get;
        } else {
            return element;
        }
    };


    AdobeFileUploader.prototype.defaults = function (options,value)  {
        var propertyObject = {};
        if(typeof options == 'object') {
            propertyObject._fileIframeName = options._fileIframeName;
            propertyObject._filePath = options._filePath;
            propertyObject.actionUrl = options.actionUrl;
            propertyObject._getUrl = options._getUrl;
        }
        if(typeof  value == 'object') {
            propertyObject._fileIframeName = value._fileIframeName;
            propertyObject._filePath = value._filePath;
            propertyObject.actionUrl = value.actionUrl;
            propertyObject._getUrl = options._getUrl;
        }
        return {
            'fileUploadPath': propertyObject._filePath || AdobeFileUploader.prototype._filePath,
            'iframeName': AdobeFileUploader.prototype._fileIframeName + new Date().valueOf(),
            'fileUploadServlet': propertyObject._filePath || AdobeFileUploader.prototype._filePath,
            'iframeContainer': propertyObject._iframeContainer || AdobeFileUploader.prototype._iframeContainer,
            '_getUrl': propertyObject._getUrl || ""
        };
    };

})($);

/*******************************************************************************
 * ADOBE CONFIDENTIAL
 *  ___________________
 *
 *   Copyright 2013 Adobe Systems Incorporated
 *   All Rights Reserved.
 *
 *  NOTICE:  All information contained herein is, and remains
 *  the property of Adobe Systems Incorporated and its suppliers,
 *  if any.  The intellectual and technical concepts contained
 *  herein are proprietary to Adobe Systems Incorporated and its
 *  suppliers and are protected by all applicable intellectual property
 *  laws, including trade secret and copyright laws.
 *  Dissemination of this information or reproduction of this material
 *  is strictly forbidden unless prior written permission is obtained
 *  from Adobe Systems Incorporated.
 ******************************************************************************/

(function(_,xfalib) {
    var Constants = {
        accessValues : ["open","protected","readOnly","nonInteractive"],
        presenceValues : ["visible", "hidden","inactive","invisible"],
        itemSaveValues : [0,1],
        valueOverrideValues : [0,1],
        oneOfChild : {type: "oneOfChild", min:0, max:1},
        zeroOrMore : {type: "zeroOrMore",min:0, max:Infinity},
        zeroOrOne : {type: "zeroOrOne",min:0, max:1},
        zeroOrTwo : {type: "zeroOrTwo", min:0, max:2},
        zeroOrFour : {type: "zeroOrFour", min:0, max:4},
        oneOrMore : {type: "oneOrMore", min:1, max:Infinity},

        encryptDataOperationValues : ["encrypt", "decrypt"],
        requiredTypeValues : ["optional", "required"],
        dataValues : ["link", "embed"],
        hScrollPolicyValues : ["auto", "off", "on"],
        disableAllValues : ["0", "1"],
        formatTestValues : ["warning", "disabled", "error"],
        nullTestValues : ["disabled", "error", "warning" ],
        scriptTestValues : ["error", "disabled", "warning"],
        afterValues : ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"],
        beforeValues : ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"],
        startNewValues : ["0", "1"],
        circularValues : ["0", "1"],
        handValues : ["even", "left", "right"],
        highlightValues : ["inverted", "none", "outline", "push"],
        activityValues : ["click", "change", "docClose", "docReady", "enter",
            "exit", "full", "indexChange", "initialize",
            "mouseDown", "mouseEnter", "mouseExit", "mouseUp",
            "postExecute", "postOpen", "postPrint", "postSave",
            "postSign", "postSubmit", "preExecute", "preOpen",
            "prePrint", "preSave", "preSign", "preSubmit",
            "ready", "validationState"],
        listenValues : ["refOnly", "refAndDescendents"],
        breakValues : ["close", "open"],
        targetTypeValues : ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"],
        signTypeValues : ["PDF1.3", "PDF1.6"],
        signDataOperationValues : ["sign", "clear", "verify"],
        aspectValues : ["fit", "actual", "height", "none", "width"],
        transferEncodingValues : ["none", "package", "base64"],
        manifestActionValues : ["include", "all", "exclude"],
        traverseDelegateValues : ["0", "1"],
        traverseOperationValues : ["next", "back", "down", "first", "left", "right", "up"],
        slopeValues : ["\\", "/"],
        excludeAllCapsValues : ["0", "1"],
        excludeInitialCapValues : ["0", "1"],
        hyphenateValues : ["0", "1"],
        allowNeutralValues : ["0", "1"],
        markValues : ["default", "check", "circle", "cross", "diamond", "square", "star"],
        shapeValues : ["square", "round"],
        commitOnValues : [ "select", "exit"],
        openValues : ["userControl", "always", "multiSelect", "onEntry" ],
        textEntryValues : ["0", "1"],
        linearTypeValues : ["toRight", "toBottom", "toLeft", "toTop"],
        edgeCapValues : ["square", "butt", "round"],
        strokeValues : ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"],
        cornerInvertedValues : ["0", "1"],
        cornerJoinValues : ["square","round"],
        speakDisableValues : ["0", "1"],
        speakPriorityValues : [ "custom", "caption", "name", "toolTip"],
        captionPlacementValues : ["left", "bottom", "inline", "right", "top"],
        orientationValues : ["portrait", "landscape"],
        mediumTrayInValues : ["auto", "delegate", "pageFront"],
        mediumTrayOutValues : ["auto", "delegate"],
        patternTypeValues : ["crossHatch", "crossDiagonal", "diagonalLeft", "diagonalRight", "horizontal", "vertical"],
        keepIntactValues : ["none", "contentArea", "pageArea"],
        keepNextValues : ["none", "contentArea", "pageArea"],
        keepPreviousValues : ["none", "contentArea", "pageArea"],
        passThroughValues : ["0", "1"],
        allowRichTextValues : ["0", "1"],
        multiLineValues : ["1", "0"],
        vScrollPolicyValues : ["auto", "off", "on"],
        kerningModeValues : ["none", "pair"],
        lineThroughValues : ["0", "1", "2"],
        lineThroughPeriodValues : ["all", "word"],
        fontOverlineValues : ["0", "1", "2"],
        fontOverlinePeriodValues : ["all", "word"],
        postureValues : ["normal", "italic"],
        underlineValues : ["0", "1", "2"],
        underlinePeriodValues : ["all", "word"],
        fontWeightValues : ["normal", "bold"],
        checksumValues : ["none", "1mod10", "1mod10_1mod11", "2mod10", "auto"],
        dataPrepValues : ["none", "flateCompress"],
        printCheckDigitValues : ["0", "1"],
        textLocationValues : ["below", "belowEmbedded", "none", "above", "aboveEmbedded"],
        truncateValues : ["0", "1"],
        upsModeValues : ["usCarrier", "internationalCarrier", "secureSymbol", "standardSymbol"],
        mdpPermissionsValues : ["2", "1", "3"],
        mdpSignatureTypeValues : ["filler", "author"],
        connectUsageValues : ["exportAndImport", "exportOnly", "importOnly"],
        radialTypeValues : ["toEdge", "toCenter"],
        credentialServerPolicyValues : ["optional", "required"],
        dateTimeEditPickerValues : ["host", "none"],
        bindMatchValues : ["once", "dataRef", "global", "none"],
        runAtValues : ["client", "both", "server"],
        statelessValues : ["0", "1"],
        executeTypeValues : ["import", "remerge"],
        calcOverrideValues : ["disabled", "error", "ignore", "warning" ],
        embedPDFValues : ["0", "1"],
        submitFormatValues : ["xdp", "formdata", "pdf", "urlencoded", "xfd", "xml" ],
        setRelationValues : ["ordered" , "choice" , "unordered"],
        firstTraversal : "first",
        nextTraversal : "next",
        ScribbleImageField : "ScribbleImageField",
        scribbleChangeEvent : "scribbleChange",
        calendarIconMaxWidth : 40

    };
    xfalib.template.Constants = Constants;
})(_,xfalib);
(function(_, xfalib){

var XfaTemplateSchema = {};

var TemplateSchema = xfalib.template.TemplateSchema = xfalib.ut.Class.extend({
    initialize : function() {
        var elem = null;
        XfaTemplateSchema["field"] = elem = this.createElement();
        this.addAttributes(elem,[
                                    ["access",xfalib.template.Constants.accessValues,0],
                                    ["h","measurement",0],
                                    ["w","measurement",0],
                                    ["x","measurement",0],
                                    ["y","measurement",0],
                                    ["presence",xfalib.template.Constants.presenceValues,0],
                                    ["name","string",""],
                                    ["relevant", "string", "" ],
                                    ["locale","string","en_US"]
                                   ]);
        this.addChildren(elem, [
                                    ["items","zeroOrTwo"],
                                    ["extras","zeroOrOne"],
                                    ["desc","zeroOrOne"],
                                    ["event","zeroOrMore"],
                                    ["value","zeroOrOne"],
                                    ["ui","zeroOrOne"],
                                    ["assist","zeroOrOne"],
                                    ["border", "zeroOrOne"]  ,
                                    ["para", "zeroOrOne"]  ,
                                    ["caption", "zeroOrOne"]  ,
                                    ["validate","zeroOrOne"]  ,
                                    ["margin", "zeroOrOne"] ,
                                    ["font", "zeroOrOne"],
                                    ["calculate","zeroOrOne"],
                                    ["format","zeroOrOne"],
                                    ["bindItems","zeroOrMore"]
                                ]);

        XfaTemplateSchema["area"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["x","measurement",0],
            ["y","measurement",0],
            ["relevant", "string", "" ],
            ["name","string",""]
        ]);
        this.addChildren(elem, [
            ["extras","zeroOrOne"],
            ["desc","zeroOrOne"],
            ["field","zeroOrMore"],
            ["draw","zeroOrMore"],
            ["exclGroup","zeroOrMore"],
            ["instanceManager","zeroOrMore"],
            ["area","zeroOrMore"],
            ["subform","zeroOrMore"],
            ["subformSet","zeroOrMore"]
        ]);

        XfaTemplateSchema["subformSet"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["relation",xfalib.template.Constants.setRelationValues,0],
            ["relevant","string",""],
            ["name","string",""]
        ]);
        this.addChildren(elem, [
            ["bookend","zeroOrOne"],
            ["break","zeroOrOne"],
            ["desc","zeroOrOne"],
            ["extras","zeroOrOne"],
            ["occur","zeroOrOne"],
            ["overflow","zeroOrOne"],
            ["breakAfter","zeroOrMore"],
            ["breakBefore","zeroOrMore"],
            ["instanceManager","zeroOrMore"],
            ["subform","zeroOrMore"],
            ["subformSet","zeroOrMore"]
        ]);

        XfaTemplateSchema["contentArea"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["name","string",""],
            ["h","measurement",0],
            ["w","measurement",0],
            ["x","measurement",0],
            ["relevant", "string", "" ],
            ["y","measurement",0]
        ]);
        this.addChildren(elem, [
            ["extras","zeroOrOne"],
            ["desc","zeroOrOne"]
        ]);

        XfaTemplateSchema["date"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["name","string",""]
        ]);

        XfaTemplateSchema["decimal"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["name","string",""],
            ["leadDigits","integer",-1],
            ["fracDigits","integer",2]
        ]);

        XfaTemplateSchema["draw"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["h","measurement",0],
            ["w","measurement",0],
            ["x","measurement",0],
            ["y","measurement",0],
            ["presence",xfalib.template.Constants.presenceValues,0],
            ["name","string",""],
            ["access", xfalib.template.Constants.accessValues, 0],  // TODO : fix schema violation
            ["relevant", "string", "" ],
            ["locale","string","en_US"]

        ]);
        this.addChildren(elem, [
            ["extras","zeroOrOne"],
            ["desc","zeroOrOne"],
            ["value","zeroOrOne"],
            ["ui","zeroOrOne"],
            ["border", "zeroOrOne"]  ,
            ["font", "zeroOrOne"]  ,
            ["para", "zeroOrOne"]  ,
            ["caption", "zeroOrOne"]  ,
            ["assist","zeroOrOne"],
            ["font", "zeroOrOne"],
            ["margin", "zeroOrOne"]
        ]);

        XfaTemplateSchema["exclGroup"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["access",xfalib.template.Constants.accessValues,0],
            ["h","measurement",0],
            ["w","measurement",0],
            ["x","measurement",0],
            ["y","measurement",0],
            ["relevant", "string", "" ],
            ["presence",xfalib.template.Constants.presenceValues,0],
            ["name","string",""]
        ]);
        this.addChildren(elem, [
            ["extras","zeroOrOne"],
            ["desc","zeroOrOne"],
            ["field","zeroOrMore"],
            ["assist","zeroOrOne"],
            ["border", "zeroOrOne"]  ,
            ["para", "zeroOrOne"]  ,
            ["caption", "zeroOrOne"]  ,
            ["validate","zeroOrOne"],
            ["margin", "zeroOrOne"]
        ]);

        XfaTemplateSchema["float"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["name","string",""]
        ]);

        XfaTemplateSchema["integer"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["name","string",""]
        ]);

        XfaTemplateSchema["items"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["save",xfalib.template.Constants.itemSaveValues,0],
            ["presence",xfalib.template.Constants.presenceValues,0],
            ["name","string",""]
        ]);
        this.addChildren(elem, [
            ["text","zeroOrMore"],
            ["integer","zeroOrMore"],
            ["date","zeroOrMore"],
            ["decimal","zeroOrMore"],
            ["float","zeroOrMore"]
        ]);

        XfaTemplateSchema["occur"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["initial","integer",1],
            ["max","integer",1],
            ["min","integer",1]
        ]);
        this.addChildren(elem, [
            ["extras","zeroOrOne"]
        ]);

        XfaTemplateSchema["pageArea"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["relevant", "string", "" ],
            ["name","string",""]
        ]);
        this.addChildren(elem, [
            ["occur","zeroOrOne"],
            ["extras","zeroOrOne"],
            ["desc","zeroOrOne"],
            ["area","zeroOrMore"],
            ["field","zeroOrMore"],
            ["draw","zeroOrMore"],
            ["exclGroup","zeroOrMore"],
            ["instanceManager","zeroOrMore"],
            ["subform","zeroOrMore"],
            ["contentArea","zeroOrMore"]
        ]);



        XfaTemplateSchema["pageSet"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["relevant", "string", "" ],
            ["name","string",""]
        ]);
        this.addChildren(elem, [
            ["occur","zeroOrOne"],
            ["extras","zeroOrOne"],
            ["pageArea","zeroOrMore"],
            ["pageSet","zeroOrMore"]
        ]);

        XfaTemplateSchema["subform"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["access",xfalib.template.Constants.accessValues,0],
            ["h","measurement",0],
            ["w","measurement",0],
            ["x","measurement",0],
            ["y","measurement",0],
            ["presence",xfalib.template.Constants.presenceValues,0],
            ["name","string",""],
            ["relevant", "string", "" ],
            ["locale","string","en_US"]
        ]);
        this.addChildren(elem, [
            ["occur","zeroOrOne"],
            ["extras","zeroOrOne"],
            ["desc","zeroOrOne"],
            ["pageSet","zeroOrOne"],
            ["variables","zeroOrOne"],
            ["area","zeroOrMore"],
            ["field","zeroOrMore"],
            ["draw","zeroOrMore"],
            ["exclGroup","zeroOrMore"],
            ["instanceManager","zeroOrMore"],
            ["subform","zeroOrMore"],
            ["assist","zeroOrOne"],
            ["border", "zeroOrOne"],
            ["para", "zeroOrOne"],
            ["validate","zeroOrOne"],
            ["subformSet","zeroOrMore"],
            ["bind","zeroOrOne"],
            ["margin", "zeroOrOne"]
        ]);

        XfaTemplateSchema["text"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["name","string",""],
            ["maxChars","integer",0]
        ]);

        XfaTemplateSchema["exData"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["name","string",""],
            ["maxLength","integer",-1],
            ["transferEncoding",xfalib.template.Constants.transferEncodingValues,0],
            ["contentType","string","text/plain"]
        ]);


        XfaTemplateSchema["extras"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["name","string",""]
        ]);
        this.addChildren(elem, [
            ["text","zeroOrMore"],
            ["integer","zeroOrMore"],
            ["date","zeroOrMore"],
            ["decimal","zeroOrMore"],
            ["float","zeroOrMore"],
            ["value", "zeroOrOne"],
            ["extras","zeroOrMore"]
        ]);

        XfaTemplateSchema["desc"] = elem = this.createElement();
        this.addChildren(elem, [
            ["text","zeroOrMore"],
            ["integer","zeroOrMore"],
            ["date","zeroOrMore"],
            ["decimal","zeroOrMore"],
            ["float","zeroOrMore"]
        ]);

        XfaTemplateSchema["variables"] = elem = this.createElement();
        this.addChildren(elem, [
            ["boolean","zeroOrMore"],
            ["date","zeroOrMore"],
            ["dateTime","zeroOrMore"],
            ["decimal","zeroOrMore"],
            ["exData","zeroOrMore"],
            ["float","zeroOrMore"],
            ["image","zeroOrMore"],
            ["integer","zeroOrMore"],
            ["manifest","zeroOrMore"],
            ["script","zeroOrMore"],
            ["script","zeroOrMore"],
            ["time","zeroOrMore"]
        ]);


//------------------------------------------------------------------------------------------------------------------------------
        XfaTemplateSchema["para"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["hAlign","string","left"],
            ["lineHeight","measurement","0pt"],
            ["marginLeft","measurement","0in"],
            ["marginRight","measurement","0in"],
            ["orphans","integer",0],
            ["preserve","string",""],
            ["radixOffset","measurement","0in"],
            ["spaceAbove","measurement","0in"],
            ["spaceBelow","measurement","0in"],
            ["tabDefault","string",""],
            ["tabStops","string",""],
            ["textIndent","measurement","0in"],
            ["vAlign","string","top"],
            ["widows","integer",0],
            ["wordSpacingMaximum","string",""],
            ["wordSpacingMinimum","string",""],
            ["wordSpacingOptimum","string",""]
        ]);

        XfaTemplateSchema["encryptData"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["operation", xfalib.template.Constants.encryptDataOperationValues, 0 ]  ,
            ["target", "string", "" ]
        ]);
        this.addChildren(elem, [
            ["filter", "zeroOrOne"]  ,
            ["manifest", "zeroOrOne"]
        ]);


        XfaTemplateSchema["issuers"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["type", xfalib.template.Constants.requiredTypeValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["certificate", "zeroOrMore"]
        ]);


        XfaTemplateSchema["imageEdit"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["data", xfalib.template.Constants.dataValues, 1 ]
        ]);
        this.addChildren(elem, [
            ["border", "zeroOrOne"]  ,
            ["extras", "zeroOrOne"]  ,
            ["margin", "zeroOrOne"]
        ]);


        XfaTemplateSchema["bookend"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["leader", "string", "" ]  ,
            ["trailer", "string", "" ]
        ]);


        XfaTemplateSchema["reason"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["name","string",""]
        ]);


        XfaTemplateSchema["passwordEdit"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["hScrollPolicy", xfalib.template.Constants.hScrollPolicyValues, 0 ]  ,
            ["passwordChar", "string", "" ]
        ]);
        this.addChildren(elem, [
            ["border", "zeroOrOne"]  ,
            ["extras", "zeroOrOne"]  ,
            ["margin", "zeroOrOne"]
        ]);


        XfaTemplateSchema["validate"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["disableAll", xfalib.template.Constants.disableAllValues, 0 ]  ,
            ["formatTest", xfalib.template.Constants.formatTestValues, 0 ]  ,
            ["nullTest", xfalib.template.Constants.nullTestValues, 0 ]  ,
            ["scriptTest", xfalib.template.Constants.scriptTestValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["extras", "zeroOrOne"]  ,
            ["message", "zeroOrOne"]  ,
            ["picture", "zeroOrOne"]  ,
            ["script", "zeroOrOne"]
        ]);


        XfaTemplateSchema["break"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["after", xfalib.template.Constants.afterValues, 0 ]  ,
            ["afterTarget", "string", "" ]  ,
            ["before", xfalib.template.Constants.beforeValues, 0 ]  ,
            ["beforeTarget", "string", "" ]  ,
            ["bookendLeader", "string", "" ]  ,
            ["bookendTrailer", "string", "" ]  ,
            ["overflowLeader", "string", "" ]  ,
            ["overflowTarget", "string", "" ]  ,
            ["overflowTrailer", "string", "" ]  ,
            ["startNew", xfalib.template.Constants.startNewValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["extras", "zeroOrOne"]
        ]);


        XfaTemplateSchema["time"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["name", "string", "" ]
        ]);


        XfaTemplateSchema["certificate"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["name", "string", "" ]
        ]);


        XfaTemplateSchema["lockDocument"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["type", xfalib.template.Constants.requiredTypeValues, 0 ]
        ]);


        XfaTemplateSchema["arc"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["circular", xfalib.template.Constants.circularValues, 0 ]  ,
            ["hand", xfalib.template.Constants.handValues, 0 ]  ,
            ["startAngle", "string", "0" ]  ,
            ["sweepAngle", "string", "360" ]
        ]);
        this.addChildren(elem, [
            ["edge", "zeroOrOne"]  ,
            ["fill", "zeroOrOne"]
        ]);


        XfaTemplateSchema["button"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["highlight", xfalib.template.Constants.highlightValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["extras", "zeroOrOne"]
        ]);


        XfaTemplateSchema["event"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["activity", xfalib.template.Constants.activityValues, 0 ]  ,
            ["listen", xfalib.template.Constants.listenValues, 0 ]  ,
            ["name", "string", "" ],
            ["ref", "string", "" ]
        ]);
        this.addChildren(elem, [
            ["extras", "zeroOrOne"]  ,
            ["encryptData", "oneOfChild"]  ,
            ["execute", "oneOfChild"]  ,
            ["script", "oneOfChild"]  ,
            ["signData", "oneOfChild"]  ,
            ["submit", "oneOfChild"]
        ]);


        XfaTemplateSchema["boolean"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["name", "string", "" ]
        ]);


        XfaTemplateSchema["margin"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["bottomInset", "measurement", "0in" ]  ,
            ["leftInset", "measurement", "0in" ]  ,
            ["rightInset", "measurement", "0in" ]  ,
            ["topInset", "measurement", "0in" ]
        ]);
        this.addChildren(elem, [
            ["extras", "zeroOrOne"]
        ]);


        XfaTemplateSchema["border"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["break", xfalib.template.Constants.breakValues, 0 ]  ,
            ["hand", xfalib.template.Constants.handValues, 0 ]  ,
            ["presence", xfalib.template.Constants.presenceValues, 0 ]  ,
            ["relevant", "string", "" ]
        ]);
        this.addChildren(elem, [
            ["corner", "zeroOrFour"]  ,
            ["edge", "zeroOrFour"]  ,
            ["extras", "zeroOrOne"]  ,
            ["fill", "zeroOrOne"]  ,
            ["margin", "zeroOrOne"]
        ]);


        XfaTemplateSchema["breakAfter"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["leader", "string", "" ]  ,
            ["startNew", xfalib.template.Constants.startNewValues, 0 ]  ,
            ["target", "string", "" ]  ,
            ["targetType", xfalib.template.Constants.targetTypeValues, 0 ]  ,
            ["trailer", "string", "" ]
        ]);
        this.addChildren(elem, [
            ["script", "zeroOrOne"]
        ]);


        XfaTemplateSchema["signature"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["type", xfalib.template.Constants.signTypeValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["border", "zeroOrOne"]  ,
            ["extras", "zeroOrOne"]  ,
            ["filter", "zeroOrOne"]  ,
            ["manifest", "zeroOrOne"]  ,
            ["margin", "zeroOrOne"]
        ]);


        XfaTemplateSchema["signData"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["operation", xfalib.template.Constants.signDataOperationValues, 0 ]  ,
            ["ref", "string", "" ]  ,
            ["target", "string", "" ]
        ]);
        this.addChildren(elem, [
            ["filter", "zeroOrOne"]  ,
            ["manifest", "zeroOrOne"]
        ]);


        XfaTemplateSchema["image"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["aspect", xfalib.template.Constants.aspectValues, 0 ]  ,
            ["contentType", "string", "" ]  ,
            ["href", "string", "" ]  ,
            ["name", "string", "" ]  ,
            ["transferEncoding", xfalib.template.Constants.transferEncodingValues, 2 ]
        ]);


        XfaTemplateSchema["oids"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["type", xfalib.template.Constants.requiredTypeValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["oid", "zeroOrMore"]
        ]);


        XfaTemplateSchema["solid"] = elem = this.createElement();
        this.addChildren(elem, [
            ["extras", "zeroOrOne"]
        ]);


        XfaTemplateSchema["manifest"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["action", xfalib.template.Constants.manifestActionValues, 0 ],
            ["name", "string", "2" ]
        ]);
        this.addChildren(elem, [
            ["extras", "zeroOrOne"]  ,
            ["ref", "zeroOrMore"]
        ]);



        XfaTemplateSchema["traverse"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["delegate", xfalib.template.Constants.traverseDelegateValues, 0 ]  ,
            ["operation", xfalib.template.Constants.traverseOperationValues, 0 ]  ,
            ["ref", "string", "" ]
        ]);
        this.addChildren(elem, [
            ["extras", "zeroOrOne"]  ,
            ["script", "zeroOrOne"]
        ]);


        XfaTemplateSchema["line"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["hand", xfalib.template.Constants.handValues, 0 ]  ,
            ["slope", xfalib.template.Constants.slopeValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["edge", "zeroOrOne"]
        ]);


        XfaTemplateSchema["digestMethods"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["type", xfalib.template.Constants.requiredTypeValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["digestMethod", "zeroOrMore"]
        ]);


        XfaTemplateSchema["reasons"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["type", xfalib.template.Constants.requiredTypeValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["reason", "zeroOrMore"]
        ]);


        XfaTemplateSchema["defaultUi"] = elem = this.createElement();
        this.addChildren(elem, [
            ["extras", "zeroOrOne"]
        ]);


        XfaTemplateSchema["hyphenation"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["excludeAllCaps", xfalib.template.Constants.excludeAllCapsValues, 0 ]  ,
            ["excludeInitialCap", xfalib.template.Constants.excludeInitialCapValues, 0 ]  ,
            ["hyphenate", xfalib.template.Constants.hyphenateValues, 0 ]  ,
            ["ladderCount", "integer", 2 ]  ,
            ["pushCharacterCount", "integer", 3 ]  ,
            ["remainCharacterCount", "integer", 3 ]  ,
            ["wordCharacterCount", "integer", 7 ]
        ]);


        XfaTemplateSchema["rectangle"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["hand", xfalib.template.Constants.handValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["corner", "zeroOrFour"]  ,
            ["edge", "zeroOrFour"]  ,
            ["fill", "zeroOrOne"]
        ]);


        XfaTemplateSchema["encryptionMethod"] = elem = this.createElement();


        XfaTemplateSchema["checkButton"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["allowNeutral", xfalib.template.Constants.allowNeutralValues, 0 ]  ,
            ["mark", xfalib.template.Constants.markValues, 0 ]  ,
            ["shape", xfalib.template.Constants.shapeValues, 0 ]  ,
            ["size", "string", "10pt" ]
        ]);
        this.addChildren(elem, [
            ["border", "zeroOrOne"]  ,
            ["extras", "zeroOrOne"]  ,
            ["margin", "zeroOrOne"]
        ]);


        XfaTemplateSchema["choiceList"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["commitOn", xfalib.template.Constants.commitOnValues, 0 ]  ,
            ["open", xfalib.template.Constants.openValues, 0 ]  ,
            ["textEntry", xfalib.template.Constants.textEntryValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["border", "zeroOrOne"]  ,
            ["extras", "zeroOrOne"]  ,
            ["margin", "zeroOrOne"]
        ]);


        XfaTemplateSchema["oid"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["name", "string", "" ]
        ]);


        XfaTemplateSchema["encoding"] = elem = this.createElement();


        XfaTemplateSchema["ui"] = elem = this.createElement();
        this.addChildren(elem, [
            ["extras", "zeroOrOne"]  ,
            ["picture", "zeroOrOne"]  ,
            ["barcode", "oneOfChild"]  ,
            ["button", "oneOfChild"]  ,
            ["checkButton", "oneOfChild"]  ,
            ["choiceList", "oneOfChild"]  ,
            ["dateTimeEdit", "oneOfChild"]  ,
            ["defaultUi", "oneOfChild"]  ,
            ["exObject", "oneOfChild"]  ,
            ["imageEdit", "oneOfChild"]  ,
            ["numericEdit", "oneOfChild"]  ,
            ["passwordEdit", "oneOfChild"]  ,
            ["signature", "oneOfChild"]  ,
            ["textEdit", "oneOfChild"]
        ]);


        XfaTemplateSchema["linear"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["type", xfalib.template.Constants.linearTypeValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["color", "zeroOrOne"]  ,
            ["extras", "zeroOrOne"]
        ]);


        XfaTemplateSchema["edge"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["cap", xfalib.template.Constants.edgeCapValues, 0 ]  ,
            ["presence", xfalib.template.Constants.presenceValues, 0 ]  ,
            ["stroke", xfalib.template.Constants.strokeValues, 0 ]  ,
            ["thickness", "string", "0.5pt" ]
        ]);
        this.addChildren(elem, [
            ["color", "zeroOrOne"]  ,
            ["extras", "zeroOrOne"]
        ]);


        XfaTemplateSchema["corner"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["inverted", xfalib.template.Constants.cornerInvertedValues, 0 ]  ,
            ["join", xfalib.template.Constants.cornerJoinValues, 0 ]  ,
            ["presence", xfalib.template.Constants.presenceValues, 0 ]  ,
            ["radius", "string", "0in" ]  ,
            ["stroke", xfalib.template.Constants.strokeValues, 0 ]  ,
            ["thickness", "string", "0.05pt" ]
        ]);
        this.addChildren(elem, [
            ["color", "zeroOrOne"]  ,
            ["extras", "zeroOrOne"]
        ]);


        XfaTemplateSchema["toolTip"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["rid", "string", "" ]
        ]);


        XfaTemplateSchema["speak"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["disable", xfalib.template.Constants.speakDisableValues, 0 ]  ,
            ["priority", xfalib.template.Constants.speakPriorityValues, 0 ]  ,
            ["rid", "string", "" ]
        ]);


        XfaTemplateSchema["caption"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["placement", xfalib.template.Constants.captionPlacementValues, 0 ]  ,
            ["presence", xfalib.template.Constants.presenceValues, 0 ]  ,
            ["reserve", "string", "-1" ]
        ]);
        this.addChildren(elem, [
            ["extras", "zeroOrOne"]  ,
            ["font", "zeroOrOne"]  ,
            ["margin", "zeroOrOne"]  ,
            ["para", "zeroOrOne"]  ,
            ["value", "zeroOrOne"]
        ]);


        XfaTemplateSchema["comb"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["numberOfCells", "integer", 0 ]
        ]);


        XfaTemplateSchema["medium"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["imagingBBox", "string", "" ]  ,
            ["long", "string", "0in" ]  ,
            ["orientation", xfalib.template.Constants.orientationValues, 0 ]  ,
            ["short", "string", "0in" ]  ,
            ["stock", "string", "" ]  ,
            ["trayIn", xfalib.template.Constants.mediumTrayInValues, 0 ]  ,
            ["trayOut", xfalib.template.Constants.mediumTrayOutValues, 0 ]
        ]);


        XfaTemplateSchema["ref"] = elem = this.createElement();


        XfaTemplateSchema["pattern"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["type", xfalib.template.Constants.patternTypeValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["color", "zeroOrOne"]  ,
            ["extras", "zeroOrOne"]
        ]);


        XfaTemplateSchema["keep"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["intact", xfalib.template.Constants.keepIntactValues, 0 ]  ,
            ["next", xfalib.template.Constants.keepNextValues, 0 ]  ,
            ["previous", xfalib.template.Constants.keepPreviousValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["extras", "zeroOrOne"]
        ]);


        XfaTemplateSchema["digestMethod"] = elem = this.createElement();


        XfaTemplateSchema["signing"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["type", xfalib.template.Constants.requiredTypeValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["certificate", "zeroOrMore"]
        ]);


        XfaTemplateSchema["encryption"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["type", xfalib.template.Constants.requiredTypeValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["certificate", "zeroOrMore"]
        ]);


        XfaTemplateSchema["subjectDNs"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["type", xfalib.template.Constants.requiredTypeValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["subjectDN", "zeroOrMore"]
        ]);


        XfaTemplateSchema["encrypt"] = elem = this.createElement();
        this.addChildren(elem, [
            ["certificate", "zeroOrOne"]
        ]);


        XfaTemplateSchema["value"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["override", xfalib.template.Constants.valueOverrideValues, 0 ]  ,
            ["relevant", "string", "" ]
        ]);
        this.addChildren(elem, [
            ["arc", "oneOfChild"]  ,
            ["boolean", "oneOfChild"]  ,
            ["date", "oneOfChild"]  ,
            ["dateTime", "oneOfChild"]  ,
            ["decimal", "oneOfChild"]  ,
            ["exData", "oneOfChild"]  ,
            ["float", "oneOfChild"]  ,
            ["image", "oneOfChild"]  ,
            ["integer", "oneOfChild"]  ,
            ["line", "oneOfChild"]  ,
            ["rectangle", "oneOfChild"]  ,
            ["text", "oneOfChild"]  ,
            ["time", "oneOfChild"]
        ]);


        XfaTemplateSchema["traversal"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["passThrough", xfalib.template.Constants.passThroughValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["extras", "zeroOrOne"]  ,
            ["traverse", "zeroOrMore"]
        ]);


        XfaTemplateSchema["textEdit"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["allowRichText", xfalib.template.Constants.allowRichTextValues, 0 ]  ,
            ["hScrollPolicy", xfalib.template.Constants.hScrollPolicyValues, 0 ]  ,
            ["multiLine", xfalib.template.Constants.multiLineValues, 1 ]  ,
            ["vScrollPolicy", xfalib.template.Constants.vScrollPolicyValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["border", "zeroOrOne"]  ,
            ["comb", "zeroOrOne"]  ,
            ["extras", "zeroOrOne"]  ,
            ["margin", "zeroOrOne"]
        ]);


        XfaTemplateSchema["stipple"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["rate", "integer", 50 ]
        ]);
        this.addChildren(elem, [
            ["color", "zeroOrOne"]  ,
            ["extras", "zeroOrOne"]
        ]);


        XfaTemplateSchema["font"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["baselineShift", "string", "0in" ]  ,
            ["fontHorizontalScale", "string", "" ]  ,
            ["fontVerticalScale", "string", "" ]  ,
            ["kerningMode", xfalib.template.Constants.kerningModeValues, 0 ]  ,
            ["letterSpacing", "string", "" ]  ,
            ["lineThrough", xfalib.template.Constants.lineThroughValues, 0 ]  ,
            ["lineThroughPeriod", xfalib.template.Constants.lineThroughPeriodValues, 0 ]  ,
            ["overline", xfalib.template.Constants.fontOverlineValues, 0 ]  ,
            ["overlinePeriod", xfalib.template.Constants.fontOverlinePeriodValues, 0 ]  ,
            ["posture", xfalib.template.Constants.postureValues, 0 ]  ,
            ["size", "string", "10pt" ]  ,
            ["typeface", "string", "" ]  ,
            ["underline", xfalib.template.Constants.underlineValues, 0 ]  ,
            ["underlinePeriod", xfalib.template.Constants.underlinePeriodValues, 0 ]  ,
            ["weight", xfalib.template.Constants.fontWeightValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["extras", "zeroOrOne"]  ,
            ["fill", "zeroOrOne"]
        ]);


        XfaTemplateSchema["barcode"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["charEncoding", "string", "" ]  ,
            ["checksum", xfalib.template.Constants.checksumValues, 0 ]  ,
            ["dataColumnCount", "string", "" ]  ,
            ["dataLength", "string", "" ]  ,
            ["dataPrep", xfalib.template.Constants.dataPrepValues, 0 ]  ,
            ["dataRowCount", "string", "" ]  ,
            ["endChar", "string", "" ]  ,
            ["errorCorrectionLevel", "string", "" ]  ,
            ["moduleHeight", "string", "5mm" ]  ,
            ["moduleWidth", "string", "0.25mm" ]  ,
            ["printCheckDigit", xfalib.template.Constants.printCheckDigitValues, 0 ]  ,
            ["rowColumnRatio", "string", "" ]  ,
            ["startChar", "string", "" ]  ,
            ["textLocation", xfalib.template.Constants.textLocationValues, 0 ]  ,
            ["truncate", xfalib.template.Constants.truncateValues, 0 ]  ,
            ["type", "string", "" ]  ,
            ["upsMode", xfalib.template.Constants.upsModeValues, 0 ]  ,
            ["wideNarrowRatio", "string", "" ]
        ]);
        this.addChildren(elem, [
            ["encrypt", "zeroOrOne"]  ,
            ["extras", "zeroOrOne"]
        ]);


        XfaTemplateSchema["assist"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["role", "string", "" ]
        ]);
        this.addChildren(elem, [
            ["speak", "zeroOrOne"]  ,
            ["toolTip", "zeroOrOne"]
        ]);


        XfaTemplateSchema["breakBefore"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["leader", "string", "" ]  ,
            ["startNew", xfalib.template.Constants.startNewValues, 0 ]  ,
            ["target", "string", "" ]  ,
            ["targetType", xfalib.template.Constants.targetTypeValues, 0 ]  ,
            ["trailer", "string", "" ]
        ]);
        this.addChildren(elem, [
            ["script", "zeroOrOne"]
        ]);


        XfaTemplateSchema["format"] = elem = this.createElement();
        this.addChildren(elem, [
            ["extras", "zeroOrOne"]  ,
            ["picture", "zeroOrOne"]
        ]);


        XfaTemplateSchema["keyUsage"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["crlSign", "string", "" ]  ,
            ["dataEncipherment", "string", "" ]  ,
            ["decipherOnly", "string", "" ]  ,
            ["digitalSignature", "string", "" ]  ,
            ["encipherOnly", "string", "" ]  ,
            ["keyAgreement", "string", "" ]  ,
            ["keyCertSign", "string", "" ]  ,
            ["keyEncipherment", "string", "" ]  ,
            ["nonRepudiation", "string", "" ]  ,
            ["type", xfalib.template.Constants.requiredTypeValues, 0 ]
        ]);



        XfaTemplateSchema["picture"] = elem = this.createElement();

        XfaTemplateSchema["mdp"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["permissions", xfalib.template.Constants.mdpPermissionsValues, 0 ]  ,
            ["signatureType", xfalib.template.Constants.mdpSignatureTypeValues, 0 ]
        ]);


        XfaTemplateSchema["overflow"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["leader", "string", "" ]  ,
            ["target", "string", "" ]  ,
            ["trailer", "string", "" ]
        ]);


        XfaTemplateSchema["numericEdit"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["hScrollPolicy", xfalib.template.Constants.hScrollPolicyValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["border", "zeroOrOne"]  ,
            ["comb", "zeroOrOne"]  ,
            ["extras", "zeroOrOne"]  ,
            ["margin", "zeroOrOne"]
        ]);


        XfaTemplateSchema["appearanceFilter"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["type", xfalib.template.Constants.requiredTypeValues, 0 ]
        ]);


        XfaTemplateSchema["filter"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["addRevocationInfo", "string", "" ]  ,
            ["name", "string", "" ],
            ["version", "string", "" ]
        ]);
        this.addChildren(elem, [
            ["appearanceFilter", "zeroOrOne"]  ,
            ["certificates", "zeroOrOne"]  ,
            ["digestMethods", "zeroOrOne"]  ,
            ["encodings", "zeroOrOne"]  ,
            ["encryptionMethods", "zeroOrOne"]  ,
            ["handler", "zeroOrOne"]  ,
            ["lockDocument", "zeroOrOne"]  ,
            ["mdp", "zeroOrOne"]  ,
            ["reasons", "zeroOrOne"]  ,
            ["timeStamp", "zeroOrOne"]
        ]);


        XfaTemplateSchema["renderAs"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["APIVersion", "string", "" ]
        ]);
        this.addChildren(elem, [
            ["svg", "zeroOrOne"]
        ]);


        XfaTemplateSchema["timeStamp"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["server", "string", "" ]  ,
            ["type", xfalib.template.Constants.requiredTypeValues, 0 ]
        ]);


        XfaTemplateSchema["connect"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["connection", "string", "" ]  ,
            ["ref", "string", "" ]  ,
            ["usage", xfalib.template.Constants.connectUsageValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["picture", "zeroOrOne"]
        ]);


        XfaTemplateSchema["dateTime"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["name", "string", "" ]
        ]);


        XfaTemplateSchema["bindItems"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["connection", "string", "" ]  ,
            ["labelRef", "string", "" ]  ,
            ["ref", "string", "" ]  ,
            ["valueRef", "string", "" ]
        ]);


        XfaTemplateSchema["encodings"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["type", xfalib.template.Constants.requiredTypeValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["encoding", "zeroOrMore"]
        ]);


        XfaTemplateSchema["radial"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["type", xfalib.template.Constants.radialTypeValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["color", "zeroOrOne"]  ,
            ["extras", "zeroOrOne"]
        ]);


        XfaTemplateSchema["certificates"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["credentialServerPolicy", xfalib.template.Constants.credentialServerPolicyValues, 0 ]  ,
            ["url", "string", "" ]  ,
            ["urlPolicy", "string", "" ]
        ]);
        this.addChildren(elem, [
            ["encryption", "zeroOrOne"]  ,
            ["issuers", "zeroOrOne"]  ,
            ["keyUsage", "zeroOrOne"]  ,
            ["oids", "zeroOrOne"]  ,
            ["signing", "zeroOrOne"]  ,
            ["subjectDNs", "zeroOrOne"]
        ]);


        XfaTemplateSchema["svg"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["height", "string", "" ]  ,
            ["viewBox", "string", "" ]  ,
            ["width", "string", "" ]
        ]);


        XfaTemplateSchema["fill"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["presence", xfalib.template.Constants.presenceValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["color", "zeroOrOne"]  ,
            ["extras", "zeroOrOne"]  ,
            ["linear", "oneOfChild"]  ,
            ["pattern", "oneOfChild"]  ,
            ["radial", "oneOfChild"]  ,
            ["solid", "oneOfChild"]  ,
            ["stipple", "oneOfChild"]
        ]);


        XfaTemplateSchema["setProperty"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["connection", "string", "" ]  ,
            ["ref", "string", "" ]  ,
            ["target", "string", "" ]
        ]);


        XfaTemplateSchema["encryptionMethods"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["type", xfalib.template.Constants.requiredTypeValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["encryptionMethod", "zeroOrMore"]
        ]);


        XfaTemplateSchema["dateTimeEdit"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["hScrollPolicy", xfalib.template.Constants.hScrollPolicyValues, 0 ]  ,
            ["picker", xfalib.template.Constants.dateTimeEditPickerValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["border", "zeroOrOne"]  ,
            ["comb", "zeroOrOne"]  ,
            ["extras", "zeroOrOne"]  ,
            ["margin", "zeroOrOne"]
        ]);


        XfaTemplateSchema["message"] = elem = this.createElement();
        this.addChildren(elem, [
            ["text", "zeroOrMore"]
        ]);


        XfaTemplateSchema["color"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["cSpace", "string", "SRGB" ]  ,
            ["value", "string", "" ]
        ]);
        this.addChildren(elem, [
            ["extras", "zeroOrOne"]
        ]);


        XfaTemplateSchema["subjectDN"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["delimiter", "string", "" ],
            ["name", "string", "" ]
        ]);


        XfaTemplateSchema["bind"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["match", xfalib.template.Constants.bindMatchValues, 0 ]  ,
            ["ref", "string", "" ]
        ]);
        this.addChildren(elem, [
            ["picture", "zeroOrOne"]
        ]);


        XfaTemplateSchema["handler"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["type", xfalib.template.Constants.requiredTypeValues, 0 ]
        ]);


        XfaTemplateSchema["occur"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["initial", "integer", 1 ]  ,
            ["max", "integer", 1 ]  ,
            ["min", "integer", 1 ]
        ]);
        this.addChildren(elem, [
            ["extras", "zeroOrOne"]  ,
            ["script", "zeroOrOne"]
        ]);

        XfaTemplateSchema["script"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["binding", "string", "" ]  ,
            ["contentType", "string", "" ]  ,
            ["name", "string", "" ],
            ["runAt", xfalib.template.Constants.runAtValues, 0 ]  ,
            ["stateless", xfalib.template.Constants.statelessValues, 0 ]
        ]);

        XfaTemplateSchema["execute"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["connection", "string", "" ]  ,
            ["executeType", xfalib.template.Constants.executeTypeValues, 0 ]  ,
            ["runAt", xfalib.template.Constants.runAtValues, 0 ]
        ]);

        XfaTemplateSchema["calculate"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["override", xfalib.template.Constants.calcOverrideValues, 0 ]
        ]);
        this.addChildren(elem, [
            ["extras", "zeroOrOne"]  ,
            ["message", "zeroOrOne"]  ,
            ["script", "zeroOrOne"]
        ]);

        XfaTemplateSchema["submit"] = elem = this.createElement();
        this.addAttributes(elem,[
            ["embedPDF", xfalib.template.Constants.embedPDFValues, 0 ]  ,
            ["format", xfalib.template.Constants.submitFormatValues, 0 ]  ,
            ["target", "string", "" ]  ,
            ["textEncoding", "string", "" ]  ,
            ["xdpContent", "string", "" ]
        ]);
        this.addChildren(elem, [
            ["encrypt", "zeroOrOne"]  ,
            ["encryptData", "zeroOrMore"]  ,
            ["signData", "zeroOrMore"]
        ]);

    },

    addAttributes: function(element,attrArray) {
        _.each(attrArray, function(elem) {
            element.attributes[elem[0]] = {
                                        type:elem[1],
                                        "default":elem[2]
                                       }
        });
    },

    addChildren: function(element,childrenArray) {
        _.each(childrenArray, function(elem) {
            element.children[elem[0]] = {
                relation : xfalib.template.Constants[elem[1]]
            };
        });
    },

    createElement: function() {
        return {attributes: {},children: {}};
    },

    getDefaultAttribute: function(element,attribute) {
        var elem =  XfaTemplateSchema[element];
        if(!elem)
            return "";
        var attr = elem.attributes[attribute];
        if(!attr)
            return undefined;
        if(attr.type instanceof Array) {
            return attr.type[attr["default"]];
        } else
            return attr["default"];
    },

    hasAttribute: function (element, attribute) {
        var elem = XfaTemplateSchema[element];
        if (!elem) {
            return false;
        }
        return _.has(elem.attributes, attribute);
    },

    getChildren : function(element){
        if(XfaTemplateSchema[element])
            return XfaTemplateSchema[element].children;
        else
            return null;
    },

    _getRelation: function(parent,child) {
       var p = XfaTemplateSchema[parent];
       if(!p)
          return null;
       var c = p.children[child]
       if(c)
           return c.relation;
       return null;
    },

    _getDataType: function(element,attribute) {
        var attr =  XfaTemplateSchema[element].attributes[attribute];
        return attr.type;
    },

    _getOneOfChild: function(element) {
        var res = {};
        _.each(XfaTemplateSchema[element].children,
            function(obj,clas) {
                if(obj.relation.type == "oneOfChild")
                    res[clas] = true
            });
        return res;
    }

});
})(_, xfalib);
/**
 * @package xfalib.ut.Version
 * @import xfalib.ut.Class
 */

(function(_, xfalib){
    var Version = xfalib.ut.Version = xfalib.ut.Class.extend({

        ES4: 1100,
        ES4SP1: 1101,
        P9A: 1102, //added new version for P9A -> not being used but still if we need someday

        current: function() {
            return this.P9A;
        },

        initialize : function(options){
            Version._super.initialize.call(this);
            this._originalVersion = options != null ? options.originalVersion : this.current();
            this._override = options ? options.override : {} ;
            if(!this._override) {
                this._override = {};
            }
        },


        isSame : function(v) {
            return (this._originalVersion == v);
        },

        isAfter: function(v) {
            return (this._originalVersion > v);
        },

        isAfterOrSame : function(v) {
            return this.isAfter(v) || this.isSame(v);
        },

        isPrevious: function(v) {
            return (this._originalVersion < v);
        },

        isPreviousOrSame : function(v) {
            return this.isPrevious(v) || this.isSame(v);
        },

        isOn : function(flag) {
            //function to control if a particular flag is on
            //since it might dependent on version so it is in Version class
           return(this._override[flag]);
        }

    });
})(_, xfalib);
(function(_,xfalib){
    xfalib.script.mixin.AddAssist = {
        propertyDescriptors : {
            "assist" : {
                get : function() {
                    return this.getElement("assist", 0);
                },

                set : function(value) {
                    return this.setElement(value, "assist");
                }
            }
        }
    }
})(_, xfalib);


(function(_,xfalib){
    xfalib.script.mixin.AddBorder = {
        propertyDescriptors : {
            "border" : {
                get : function() {
                    return this.getElement("border", 0);
                },

                set : function(value) {
                    return this.setElement(value, "border");
                }
            }
        }
    }
})(_, xfalib);


(function(_,xfalib){
    xfalib.script.mixin.AddCaption = {
        propertyDescriptors : {
            "caption" : {
                get : function() {
                    return this.getElement("caption", 0);
                },

                set : function(value) {
                    return this.setElement(value, "caption");
                }
            }
        }
    }
})(_, xfalib);


(function(_,xfalib){
    xfalib.script.mixin.AddPresence = {
        propertyDescriptors : {
            "presence" : {
                get : function() {
                    //Avoided getAttribute call to avoid any regression in case something is missing in Template Schema
                    return this.getOrElse(this.jsonModel.presence, xfalib.script.Node.prototype._defaults.presence);
                },
                set : function(sPresence) {
                    var oldPresence = this.jsonModel.presence;
                    this.setAttribute(sPresence, "presence");
                    if (this.jsonModel.presence != oldPresence) {
                        this._calculateEffectivePresence();
                        var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED,
                            this,"presence",oldPresence,this.jsonModel.presence);
                        this.trigger(evnt.name,evnt);
                    }
                }
            }
        }
    }
})(_,xfalib);

(function(_,xfalib){
    xfalib.script.mixin.AddXYWH = {
        propertyDescriptors : {
            "h" : {
                get : function() {
                    return this.getOrElse(this.jsonModel.h, xfalib.script.Node.prototype._defaults.h);
                },
                set : function(value) {
                    this.setAttribute(value,"h");
                    var event = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.DOM_CHANGED,
                               this,"h",value, value);
                    this.trigger(event.name,event);
                }
            },

            "w" : {
                get : function() {
                    return this.getOrElse(this.jsonModel.w, xfalib.script.Node.prototype._defaults.w);
                },
                set : function() {

                }
            },

            "x" : {
                get : function() {
                    return this.getOrElse(this.jsonModel.x, xfalib.script.Node.prototype._defaults.x);
                },
                set : function() {

                }
            },

            "y" : {
                get : function() {
                    return this.getOrElse(this.jsonModel.y, xfalib.script.Node.prototype._defaults.y);
                },
                set : function() {

                }
            }
        }
    }
})(_,xfalib);

(function(_,xfalib){
    xfalib.script.mixin.AddFillColor = {
        propertyDescriptors : {
            "fillColor" : {
                get : function() {
                   return (this.border.fill.color.value == "") ? "255,255,255" : this.border.fill.color.value;
                },

                set : function(color) {
                    if(this.border && this.border.fill && this.border.fill.color) {
                        this.border.fill.presence="visible";
                        this.border.fill.color.value = color;
                    }
                }
            }
        }
    }
})(_,xfalib);
(function(_,xfalib){
    xfalib.script.mixin.AddBorderColor = {
        propertyDescriptors : {
            "borderColor" : {
                get : function() {
                    return this.border.edge.color.value;
                },

                set : function(color) {
                    //TODO: Set border.edge.presence property to visible once Border is implemented
                    this.border.edge.color.value = color ;
                }
            }
        }
    }
})(_, xfalib);

(function(_,xfalib){
    xfalib.script.mixin.AddBorderWidth = {
        propertyDescriptors : {
            "borderWidth" : {
                get : function() {
                    return this.border.edge.thickness;
                },
                set : function(value) {
                    this.border.edge.thickness = value ;
                }
            }
        }
    }
})(_, xfalib);(function(_,xfalib){
    xfalib.script.mixin.AddPara = {
        propertyDescriptors : {
            "para" : {
                get : function() {
                    return this.getElement("para", 0);
                },

                set : function(value) {
                    return this.setElement(value, "para");
                }
            }
        }
    }
})(_, xfalib);


(function(_,xfalib){
    xfalib.script.mixin.AddMargin = {
        propertyDescriptors : {
            "margin" : {
                get : function() {
                    return this.getElement("margin", 0);
                },

                set : function(value) {
                    return this.setElement(value, "margin");
                }
            }
        }
    }
})(_, xfalib);


/**
 * @package xfalib.script.Object
 * @import xfalib.ut.EventClass
 * @fileOverview The file creates the Object Class required for XFA library
 * @version 0.0.1
 */

(function(_, xfalib){
    /**
     * Creates a new class
     * @class Base XFA class. All the other classes are a subclass of this.
     * @constructor
     * @property {string} className represents the name of the class for this object
     */
    var xfaObject = xfalib.script.Object = xfalib.ut.EventClass.extend({
        msClassName : "object",
        initialize : function(){
            //For perf reason, we are computing className at intialize time instead of accessing it via propertyDescriptor
            this.className = this.jsonModel._class || this.msClassName;
        }
    });

})(_, xfalib);
/**
 * @package xfalib.script.XfaList
 * @import xfalib.ut.Class
 */

(function(_, xfalib){
    var XfaList = xfalib.script.XfaList = xfalib.ut.Class.extend({

        initialize : function() {
            XfaList._super.initialize.call(this);
            this.currentIndex = -1;
            this.moArraylist =  new Array();
            this.mParent = this.options.parent;
        },

        item : function(nIndex) {
            if(nIndex <= this.currentIndex)
                return this.moArraylist[nIndex];
            return null;
        },

        _append : function(oParam) {
            this.moArraylist[++this.currentIndex] = oParam;
        },

        append : function(oParam) {
            if(this.mParent && this.mParent instanceof xfalib.script.DOMElement)   {
                var relation = this.mParent._xfa()._templateSchema._getRelation(this.mParent.className,oParam.className);
                switch(relation.type)
                 {
                 case "zeroOrOne":
                 break;
                 case "zeroOrTwo":
                 break;
                 case "zeroOrMore":
                this.mParent._addChild(oParam);
                break;
                 default:

                 }

            }
            this._append(oParam);
        },

        remove : function(oParam) {
            var index = this.moArraylist.indexOf(oParam);
            if(index >= 0) {
                this.moArraylist.splice(index,1);
                this.currentIndex--;
            }
        },

        insert : function(oInsert,oBefore) {
            var index = this.moArraylist.indexOf(oBefore);
            this.currentIndex++;
            if(index <= 0)
                index = this.currentIndex;
            this.moArraylist.splice(index,0,oInsert);
        },

        _concat : function(oList) {
            if(oList == null)
                return;
            for(var i =0; i< oList.length;i++) {
                this._append(oList.item(i));
            }
        },

        namedItem : function(oParam){
            var node = this._find(function(obj) {
                return obj.getAttribute("name") === oParam;
            });
            if(node === undefined) return null;
            return node;
        },

        _find : function(fn) {
            return _.find(this.moArraylist,fn);
        },

        _filter : function(fn) {
            return _.filter(this.moArraylist,fn);
        }
    });

    XfaList.defineProps({
        "length" : {
            get : function() {
                return this.moArraylist.length;
            }
        }
    });
})(_, xfalib);

/**
 * @package xfalib.script.SOMExpression
 * @import xfalib.ut.Class
 */
 
(function(_, xfalib){
    var SOMExpression = xfalib.script.SOMExpression = xfalib.ut.Class.extend({
        initialize : function() {
            SOMExpression._super.initialize.call(this);
            // Format: subformA[n|*]
            // Format: subformA[n|*].[predicate expr]
            // Format: subformA.[predicate expr]
            // predicate expr: boolean expression that may include object references and
            // SOMExpressions

            this._expr = this.options.expression;
            this.scalerMatch = null;
            this.predicate = null;
            this.name = this.options.expression;
            this.index = this.options.defaultOccurrence;
            this._bDefaultIndex = true;
            this._matchCount = 0;

            var arr = this._parseExpression(this.options.expression);
            if (arr == null)
                return;

            if (arr.length == 1)
                this.name = arr[0];
            else if (arr.length == 2) {
                this.name = arr[0];
                if (arr[1] != '') {
                    // Strip brackets
                    var occ = arr[1].substring(1, arr[1].length - 1);
                    if (occ == '*')
                        this.index = '*';
                    else
                        this.index = parseInt(occ);

                    this._bDefaultIndex = false;
                }
            } else if (arr.length == 3) {
                this.name = arr[0];
                if (this.options.ignorePredicate == false) {
                    // Strip brackets
                    this.predicate = arr[2].substring(1, arr[2].length - 1);
                    this.index = '*';
                }
            }
        },

        equals : function(obj) {
          return this.namesEqual(obj) || this.classesEqual(obj);
        },

        evalPredicate : function (obj) {
            // Default: true, indicating obj passes pred expr qualification
            var bPredicateResult = true;

            //TODO: Implement later
            /*
             if (this.predicate != null && obj != null)
             {
             var parser:KParser = new KParser();
             var result:Object = parser.evaluateExpression (this.predicate, obj);
             if (result is Boolean)
             {
             trace ("evalPredicate() on: " + this.predicate + ", result: " + result);
             bPredicateResult = result;
             }
             }
             */
            return bPredicateResult;
        },

        namesEqual : function(obj) {
            if (this.name == obj.getAttribute("name")){
                var bPredResult = this.evalPredicate(obj);

                if (((this.index == '*') || (this.index == obj.index)) && bPredResult == true)
                    return true;

                //
                // If the SOM expression does not have a specific index
                // record a name match with the obj with the lowest index
                //
                if (this._bDefaultIndex && bPredResult)
                {
                    if ((this.scalerMatch == null) || (obj.index < this.scalerMatch.index))
                        this.scalerMatch = obj;
                }
            }
            return false;
        },

        classesEqual : function ( obj){
            var bRet = false;
            var bPredResult = this.evalPredicate(obj);

            if (this.name == "#"+obj.className){
                if (this.index == '*' && bPredResult == true){
                    bRet = true;
                }
                else{
                    if (this.index == obj.mnClassIndex && bPredResult == true)
                        bRet = true;
                    else
                        bRet = false;
                }
            }
            return bRet;
        },

        tagEquals : function (obj) {
            var parent = obj.parent;
            var max;
            if(parent) {
                try {
                    var relation = parent._getRelation(obj);
                    if(relation)
                        max = relation.max;
                }
                catch(e) {
                    this._xfa().Logger.debug("xfa", "incomplete schema.");
                }
            }
            //if this obj is the only possible child of its type then ignore class index.
            return this.name == obj.className && (max == 1 || this.index =='*' || this.index == obj.mnClassIndex)
        },

        _parseExpression : function(sSomExpression) {
            if (sSomExpression == null) {
                return null;
            }

            var arr = [];
            var buf = "";
            var inBrace = 0;
            var bEscape = false;
            for ( var j = 0; j < sSomExpression.length; j++) {
                var s = sSomExpression.charAt(j);
                if (s == "[" && !inBrace) {
                    inBrace++;
                    arr.push(buf);
                    buf = "";
                }
                if (s == "[" && inBrace) {
                    inBrace++;
                    buf += s;
                } else if (s == "]" && inBrace) {
                    --inBrace;
                    buf += s;
                } else if (s == "\\") {
                    bEscape = true;
                } else if (s == "." && !inBrace && !bEscape) {
                    arr.push(buf);
                    buf = "";
                } else {
                    buf += s;
                    bEscape = false;
                }

                if (j == sSomExpression.length - 1)
                    arr.push(buf);
            }
            return arr;
        },

        splitExpression : function(sSomExpression) {
            if (sSomExpression == null)
                return null;

            var arr = [];
            var buf = "";
            var inBrace = 0;
            var bEscape = false;
            for ( var j = 0; j < sSomExpression.length; j++) {
                var s = sSomExpression.charAt(j);
                if (s == "[") {
                    inBrace++;
                    buf += s;
                } else if (s == "]") {
                    --inBrace;
                    buf += s;
                } else if (s == "\\") {
                    bEscape = true;
                    buf += s;
                } else if (s == "." && inBrace == 0 && bEscape == false) {
                    if (buf.length == 0)
                        arr.push(".."); // elipsis
                    else {
                        if (buf.indexOf("#variables") < 0) {
                            arr.push(buf);
                        }
                    }
                    buf = "";
                } else {
                    buf += s;
                    bEscape = false;
                }

                if (j == sSomExpression.length - 1) {
                    if (buf.indexOf("#variables") < 0) {
                        arr.push(buf);
                    }
                }
            }

            if (arr.length == 1)
                return arr;

            var out = [];
            var pattern = /^\[.*\]/;
            for ( var i = 0; i < arr.length; i++) {
                var seg = String(arr[i]);
                if (seg.match(pattern) && i > 0)
                    out.splice(i - 1, 1, arr[i - 1] + "." + seg);
                else
                    out.push(arr[i]);
            }
            return out;
        }

    });

    SOMExpression.defineProps({
        "expression" : {
            get : function() {
                return this._expr;
            },
            set : function(expression) {            	
            	expression = this.validateInput(expression,"string");
                this._expr = expression;
            }
        }
    });

})(_, xfalib);



/**
 * @package xfalib.script.XfaModelEvent
 * @import xfalib.script.Object
 * @fileOverview The file creates the XfaModelEvent Class required for XFA library
 * @version 0.0.1
 */
(function(_,xfalib) {

    var XfaModelEvent = xfalib.script.XfaModelEvent = xfalib.script.Object.extend({
        msClassName: "eventPseudoModel"
    });

    XfaModelEvent.defineProps({
        "prevText" : {
            get : function(){
                return this.jsonModel.prevText;
            }
        },
        "newText" : {
            get : function(){
                return this.jsonModel.newText;
            }
        },
        "fullText": {
            get: function () {
                return this.jsonModel.fullText;
            }
        },
        "name" : {
            get : function(){
                return this.jsonModel.name;
            }
        },
        "keyDown" : {
            get : function(){
                return this.jsonModel.keyDown;
            }
        },
        "modifier" : {
            get : function(){
                return this.jsonModel.modifier;
            }
        },
        "target" : {
            get : function(){
                return this.jsonModel.target;
            }
        },
        "shift" : {
            get : function(){
                return this.jsonModel.shift;
            }
        },
        "change" : {
            get : function(){
                return this.jsonModel.change;
            },
            set : function(value){
                this.jsonModel.change = value;
                var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED,this.target,
                    'change',value,null);
                this.target.trigger(evnt.name,evnt);
            }
        },
        "_property" : {
            get : function(){
                return this.jsonModel._property;
            },

            set : function(value){
                this.jsonModel._property = value;
            }
        }
    });

    XfaModelEvent.createEvent = function(nm,tgt,prop,oldVal,newVal) {
        var evnt = {
            name:nm,
            target:tgt,
            _property:prop,
            prevText:oldVal,
            newText:newVal
        };
        return new XfaModelEvent({"jsonModel" : evnt});
    };

    XfaModelEvent.FORM_MODEL_CHANGED = "formModelChanged";
    XfaModelEvent.RAW_VALUE_CHANGED = "rawValueChanged";
    XfaModelEvent.CHILD_ADDED = "childAdded";
    XfaModelEvent.CHILD_REMOVED = "childRemoved";
    XfaModelEvent.CHILD_MOVED = "childMoved";
    XfaModelEvent.OBJECT_DESTROYED = "objectDestroyed";
    XfaModelEvent.FORM_MODEL_REFRESH = "formModelRefresh";
    XfaModelEvent.DOM_CHANGED = "domChanged";
})(_,xfalib);
/**
 * @package xfalib.script.Layout
 * @import xfalib.script.Class
 */

(function(_, xfalib){
    var Layout = xfalib.script.Layout = xfalib.ut.Class.extend({
        initialize : function(){
            this.pagingManager = null ;
            Layout._super.initialize.call(this);

        },

        _xfa : function() {
            return xfalib.script.Xfa.Instance;
        },

        relayout: function() {
        },

        page: function(node){
            return this.pagingManager.findPage(node.htmlId) + 1;
        },

        pageCount: function() {
            if(this.pagingManager)
                return(this.pagingManager.pageCount());
        },

        absPageCount: function() {
            if(this.pagingManager)
                return(this.pagingManager.pageCount());
        },

        pageContent : function(pageNum, className, bPageArea){
            if(this.pagingManager){
                return this.pagingManager._pageContent(pageNum, className, bPageArea);
            }
            else
                return new xfalib.script.XfaList();
        },

        px2pt: function(px) {
            return px/2;
        },

        pt2inch: function(pt) {
            return pt/72;
        },

        pt2mm: function(pt) {
            return (pt*25.4)/72;
        },

        h: function(node, unit, offset) {
            if(this.pagingManager)    {
                this.pagingManager._makePageForHtmlId(node.htmlId);
                var layout = this.pagingManager.getLayout(node.htmlId);
                if(layout) {
                    var h = this.px2pt(layout.extenth) ;
                    if(unit == "inch" || unit == "in")
                        h = this.pt2inch(h);
                    if(unit == "mm")
                        h = this.pt2mm(h);
                    if(offset != undefined)
                        h= 0;
                    return h;
                }
                else return 0;

            }

        },

        w: function(node, unit, offset) {
            if(this.pagingManager)    {
                this.pagingManager._makePageForHtmlId(node.htmlId);
                var layout = this.pagingManager.getLayout(node.htmlId);
                if(layout)      {
                    var w = this.px2pt(layout.extentw) ;
                    if(unit == "inch" || unit == "in")
                        w = this.pt2inch(w);
                    if(unit == "mm")
                        w = this.pt2mm(w);
                    if(offset != undefined)
                        w= 0;
                    return w ;
                }
                else return 0;

            }
        },

        x: function(node, unit, offset) {
            if(this.pagingManager)    {
                this.pagingManager._makePageForHtmlId(node.htmlId);
                var layout = this.pagingManager.getLayout(node.htmlId);
                if(layout){
                    var x = this.px2pt(layout.extentx) ;
                    if(unit == "inch" || unit == "in")
                        x = this.pt2inch(x);
                    if(unit == "mm")
                        x = this.pt2mm(x);
                    if(offset != undefined)
                        x= 0;
                    return x;
                }
                else return 0;

            }
        },

        y: function(node, unit, offset) {
            if(this.pagingManager)    {
                this.pagingManager._makePageForHtmlId(node.htmlId);
                var layout = this.pagingManager.getLayout(node.htmlId);
                if(layout){
                    var y = this.px2pt(layout.extenty) ;
                    if(unit == "inch" || unit == "in")
                        y = this.pt2inch(y);
                    if(unit == "mm")
                        y = this.pt2mm(y);
                    if(offset != undefined)
                        y= 0;
                    return y;
                }
                else return 0;

            }
        }

    });
    Layout.defineProps({
        "ready" : {
            get : function(){
                return true;
            }
        }
    });
})(_, xfalib);

/**
 * @package xfalib.script.Node
 * @import xfalib.script.Object
 * @import xfalib.script.SOMExpression
 * @import xfalib.script.XfaList
 * @fileOverview The file creates the Node Class required for XFA library
 * @version 0.0.1
 */


(function(_, xfalib){
    var Node = xfalib.script.Node = xfalib.script.Object.extend({
        _defaults : {
            "presence" : "visible"
        },

        initialize : function(){
            Node._super.initialize.call(this);
            /**
             * @private
             * @type xfalib.script.Node
             */
            this.mParent = null;
            /**
             * @private
             * @type string
             */
            this.mnIndex = 0;
            /**
             * @private
             * @type string
             */
            this.mnClassIndex = 0;
        },

        playJson : function(pJsonModel) {
            // tabIndex should be exempted because we are already computing it in _insert Instance
            // CQ-4324970: replace default FS_DATA_SOM present in FS_EXTRAS with dataSom present in extras for repeated elements.
             if(this.resolveNode("#extras.FS_EXTRAS.FS_DATA_SOM") && pJsonModel.extras && pJsonModel.extras.dataSom) {
                              this.resolveNode("#extras.FS_EXTRAS.FS_DATA_SOM").value = pJsonModel.extras.dataSom;
                              }
            this.copyObject(pJsonModel, this.jsonModel, {exceptions : ["htmlId", "children","tabIndex"], keepReference : true});
        },

        //TODO: REMOVE this when the actual implementation is available
        saveXML : function() {
            return "";
        },

        //TODO: REMOVE this when the actual implementation is available
        loadXML : function() {
        },

        _computeJsonDiff : function(diff_level){
            var dest = {};
            dest._class = this.className;
            if(this.jsonModel.hasOwnProperty("name")){
                dest.name = this.jsonModel.name;
            }
            var changeFound = false;
            var initialJson = this._xfa()._xfaTemplateCache.getInitialFormDomRef(this.htmlId);
            if(!initialJson)
                initialJson = this._xfa()._xfaTemplateCache.getInitialFormDomRef(this._templateId()) || {};
            var initialPropLength = _.filter(initialJson, function(value, key){
                return key !="extras";
            }, this).length;
            var jsonPropLength = _.filter(this.jsonModel, function(value, key){
                return key !="extras";
            }, this).length;

            if(jsonPropLength != initialPropLength){
                //We need to compare property sizes without 'extra' property since this is not actually part of schema
                changeFound = diff_level===0;   // only need _class and name during submission & restoreFormState
            }

            _.each(this.jsonModel, function(value, key){
                if(key === "_class" || key === "children" || key === "extras" || key == "{default}"){
                    return;
                }
                else {
                    //Note: We are assuming that any key that is present in templateJson would also be there in model json though it's value may be null/undefined
                    if(value !== initialJson[key]){
                        if(_.isArray(value)){
                            xfalib.runtime.xfa.Logger.error("xfa", "key:"+key + " has unexpected array value:"+JSON.stringify(value) + "parent:\n"+ JSON.stringify(src)) ;
                        }
                        else if(_.isObject(value)){
                            xfalib.runtime.xfa.Logger.error("xfa", "key:"+key + " has unexpected object value:"+JSON.stringify(value) + "parent:\n"+ JSON.stringify(src)) ;
                        }
                        else{
                            if (diff_level===0) {   // only need _class and name during submission & restoreFormState, rest will stripped by computeJsonDIff-s
                                dest[key] = value;
                                changeFound = true;
                            }
                        }
                    }
                }
            }, this);

            if (diff_level === 1) {
                if (this._xfa()._templateSchema.hasAttribute(this.className, 'access') &&
                    _.contains(["exclGroup", "field", "subform"], this.className)) {
                    dest.access = this.jsonModel.access;
                    changeFound = true;
                }
                if (this._xfa()._templateSchema.hasAttribute(this.className, 'presence') &&
                    _.contains(["exclGroup", "field", "items", "subform", "draw"], this.className)) {
                    dest.presence = this.jsonModel.presence;
                    changeFound = true;
                }
            }
            return {"changed" : changeFound,
                jsonDifference : dest
            };
        },

        _getSomExpression : function() {
            if (this.mParent == null)
                return "xfa[0]." + this._escapeQualifiedName();
            else
                return this.mParent.somExpression + "." + this._escapeQualifiedName();
        },

        _escapeQualifiedName : function() {
            var name = "#" + this.className,
                index = this.mnClassIndex,
                objName = this.getAttribute("name")
            if (objName.length > 0) {
                name = objName;
                index = this.index;
            }
            var qname = name + "[" + index + "]";
            return qname.replace(/\./, "\\.");
        },

        _xfa : function() {
            return xfalib.script.Xfa.Instance;
        },

        _resetData: function() {

        },

        /**
         * Evaluates the specified SOM expression, beginning with the current XML form
         * object model object, and returns the value of the object specified in the SOM
         * expression
         *
         * @function
         */
        resolveNode : function() {
            var nodes = null;
            if (arguments.length == 1)
                nodes = this._resolveNodesCommon(this, arguments[0], false, true);
            else
                nodes = this._resolveNodesCommon(arguments[0], arguments[1], false,
                    true);

            if (nodes && nodes.length > 0)
                return nodes.item(0);
            else {

                //xfa.Logger.debug("resolveNode for somExpression " + arguments[1]
                //    + " failed");
                return null;
            }
        },

        /**
         * Evaluates the specified SOM expression, beginning with the current XML form
         * object model object, and returns the value of the object specified in the SOM
         * expression
         *
         * @function
         */
        resolveNodes : function() {
            var nodes = null;
            if (arguments.length == 1)
                nodes = this._resolveNodesCommon(this, arguments[0], true, true);
            else
                nodes = this._resolveNodesCommon(arguments[0], arguments[1], true, true);
            return nodes;
        },

        _objInList: function(obj) {
            var list = new xfalib.script.XfaList();
            list._append(obj);
            return list;
        },

        _findProperty: function(oSom) {
            var arr = new xfalib.script.XfaList();
          if(oSom.index == 0) {
              //check whether som is a dynamic property
              if(this.resolveProperties && this.resolveProperties.indexOf(oSom.name) != -1)
                arr._append(this[oSom.name])
          }
          return arr;
        },

        _resolveNodesCommon : function(obj, sSomExpression, bMultiple, bFirst) {
            var arr1 = xfalib.script.SOMExpression.prototype.splitExpression(sSomExpression);
            if(arr1[0] == '$') {
                arr1.splice(0,1,this.somExpression);
                sSomExpression = arr1.join(".");
            }
            if(arr1[0].charAt(0) == '$' || arr1[0] == 'xfa' || arr1[0] == 'this') {
                var root, i = arr1[0].length + 1;
                switch(arr1[0]) {
                    case "xfa":
                    case "$xfa":
                        root = this._xfa();
                        break;
                    case "$template":
                        root = this._xfa().template
                        break;
                    case "$form":
                        root = this._xfa().form;
                        break;
                    case "this":
                        root = this._xfa()._contextNode();
                        break;
                }
                if(arr1.length == 1)
                    return this._objInList(root)
                return this._resolveNodesCommon(root,sSomExpression
                    .substr(i), bMultiple, bFirst);
            }

            var nCurrentIndex = 0;
            // TODO: Do contextNode mumbo jumbo
            if (this._xfa() && (this._xfa()._contextNode() != null))
                nCurrentIndex = this._xfa()._contextNode().index;

            var oChildren = null; // returned as either an array of single object
            var oParent = obj;
            var si = 0;
            var bRootMatch = false;

            //
            // See if the first token of the expression matches this node
            // On the first call the children are checked first
            //
            var oSOM = xfalib.script.XfaModelRegistry.prototype.createSomExpression(arr1[0], obj.index);
            if ((bFirst == false) && (oSOM.equals(obj) || (oSOM.scalerMatch == obj))) {
                bRootMatch = true;
                //
                // found
                //
                if ((arr1.length == 1)) {
                    //
                    // If the expression only has one token then the expression matches
                    // this node
                    //
                    if (!bMultiple) {
                        var list = new xfalib.script.XfaList();
                        list._append(obj);
                        return list;
                    }

                    oParent = obj.parent;
                    if (oParent == null) {
                        oChildren = new xfalib.script.XfaList();
                        oChildren._append(obj);
                        return oChildren;
                    }
                    si = 0;
                } else {
                    //
                    // If the expression has more than one token then start looking for
                    // a match of subsequent tokens with the children of this node.
                    //
                    si = 1;
                    oSOM = xfalib.script.XfaModelRegistry.prototype.createSomExpression(arr1[1], 0);
                }
            } else {
                //
                // Check for match with one of the child nodes
                //
                oSOM = xfalib.script.XfaModelRegistry.prototype.createSomExpression(arr1[0], nCurrentIndex);
            }

            if (obj._isContainerNode()) {
                var bElipsis = false;

                for ( var j = si; j < arr1.length; j++) {
                    if (arr1[j] == "..") {
                        bElipsis = true;
                        j++;
                        if (j == arr1.length)
                            break;
                        oSOM = xfalib.script.XfaModelRegistry.prototype.createSomExpression(arr1[j], 0);
                    }

                    var bLast = ((j + 1) == arr1.length);
                    oChildren = new xfalib.script.XfaList();

                    if (!(oParent instanceof xfalib.script.XfaList)) {
                        var oParentList = new xfalib.script.XfaList();
                        oParentList._append(oParent);
                        oParent = oParentList;
                    }

                    for ( var k = 0; k < oParent.length; k++) {
                        var children,
                            parent = oParent.item(k);
                        if(parent != null && parent._isContainerNode()) {
                            if (bElipsis) {
                                children = parent._findChildrenDeep(oSOM,
                                    bMultiple);
                                bElipsis = false;
                            } else {
                                children = parent._findChildren(oSOM, bMultiple);
                                if(children.length == 0) {
                                    children = parent._findProperty(oSOM);
                                }
                            }
                        }

                        oChildren._concat(children);
                    }

                    if (oChildren.length == 0) {
                        break;
                    }

                    bRootMatch = true;
                    if (bLast == false) {
                        oSOM = xfalib.script.XfaModelRegistry.prototype.createSomExpression(arr1[j + 1], 0);
                        oParent = oChildren;
                    }
                }
            }

            if (oChildren && (oChildren.length != 0)) {
                return oChildren;
            }

            if ((bRootMatch == true) || (obj.parent == null)) {
                if (bFirst == true) {
                    //
                    // Try again attempting to match the current node
                    //
                    return this._resolveNodesCommon(obj, sSomExpression, bMultiple,
                        false);
                }
                if (obj.parent != null)
                    return this._resolveNodesCommon(obj.parent, sSomExpression,
                        bMultiple, false);

                if (bMultiple)
                    return new xfalib.script.XfaList();

                return null;
            } else {
                //
                // try parent
                return this._resolveNodesCommon(obj.parent, sSomExpression, bMultiple,
                    false);
            }
        },

        /**
         * @private
         * @function
         * @returns {boolean} returns whether the node is an instance of a container
         *          Node or not
         */
        _isContainerNode : function() {
            return false;
        },

        _isXFAContainerNode : function() {
            return false;
        },

        /**
         * @private
         * @function
         * @returns {boolean} returns whether the node is an instance of a Field or not
         */
        _isField : function() {
            return false;
        },

        /**
         * @private
         * @function
         * @returns {boolean} returns whether the node is an instance of a subform or
         *          not
         */
        _isSubform : function() {
            return false;
        },

        _isExclusionGroup : function() {
            return false;
        },

        _findChildren : function(oSOM, bMultiple) {
            return null;
        },

        _findChildrenDeep : function(oSOM, bMultiple) {
            return null;
        },

        /**
         * @private
         * @function
         * @returns {boolean} returns whether the node is an instance of a content Node
         *          or not
         */
        _isContent : function() {
            return false;
        },

        _isEventNode : function(){
            return false;
        },

        clone : function() {
            var clonedJson = {};
            this.copyObject(this.jsonModel, clonedJson,{exceptions : ["htmlId"]} );
            var node = xfalib.script.XfaModelRegistry.prototype.createModel(clonedJson);
            return node;
        },

        nakedFieldReferences : function(nIndex, createGetterSetter,obj) {
            return;
        },

        getAttribute: function(name, bPeek) {
            var attrValue = undefined;
            //Bug#3609434 : check only for undefined
            if(name && !_.isUndefined(this.jsonModel[name])) {
                attrValue = this.jsonModel[name];
            }
            else if(bPeek !== false) {
                attrValue = this._getDefaultAttribute(name);
            } else {
                return null;
            }
            if(name == "name" && (_.isUndefined(attrValue) || _.isNull(attrValue))){
                /* LC-8150: If attrName is name and attrValue is undefined or null then we return empty string instead of null.
                * Reason being most of the code assume that every node would have name property
                * */
                attrValue = "";
            }
            return attrValue;
        },

        /*
         * conditions for putting a node in global context
         * 1. It should have a name
         * 2. Its index should match with the index provided
         *                  OR
         * 2. There should not be more than one node with the same name in its normalizedParent Bug#3594282
         */
        getNaked : function(nIndex,createGetterSetter,Obj,scope) {
            var nodeName = this.getOrElse(this.jsonModel, "name", "");
            if ((nodeName != null) && (nodeName.length != 0) && ((scope && scope.moNameArray[nodeName] == 1) || (nIndex == this.index))) {
                //TODO: keep a state whether this node was previously naked or not. If yes do nothing
                var oObject = document[nodeName];
                if ((oObject == null) || (oObject instanceof xfalib.script.Node)) {
                    if(createGetterSetter ){
                        if(Obj._private["_"+nodeName+"_"]==null || Obj._private["_"+nodeName+"_"]==undefined){
                            this._createGetterSetter(Obj, nodeName, this);
                        }
                    }
                    else
                        Obj["_"+nodeName+"_"] = Obj["_"+nodeName+"_"] || this;
                }
            }
        },

        _getNakedThis : function(){
            return this;
        },

        toJSONString : function() {
            return JSON.stringify(this.jsonModel);
        },

        /**
         * @private
         *
         * this function performs initialization for this node.
         */
        _initialize : function() {

        },

        /**
         * @private
         * @function indicate that this is a Form node (~~).
         */
        _isForm : function() {
            return false;
        },

        _destroy : function(oChild) {
            var evnt = xfalib.script.XfaModelEvent.createEvent( xfalib.script.XfaModelEvent.OBJECT_DESTROYED, this,
                'destroy', null, this);
            this.trigger(evnt.name,evnt);
            this.off();
            var prop =  "_"+this.getAttribute("name")+"_";
            if (xfalib.runtime.hasOwnProperty(prop) && typeof xfalib.runtime[prop] != "undefined")
                if (xfalib.runtime[prop].somExpression == this.somExpression)
                    xfalib.runtime[prop] = undefined;
            this._xfa()._xfaTemplateCache.removeModel(this.htmlId);
        },

        _matches : function(oNode) {
            return (oNode != null && this.somExpression == oNode.somExpression);
        },

        _setFocus : function() {
            var evnt = xfalib.script.XfaModelEvent.createEvent( xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED, this,
                'focus', null, this);
            this.trigger(evnt.name,evnt);
        },

        _templateRef : function(){
            return this._xfa()._xfaTemplateCache.getTemplateRef(this.getOrElse(this.jsonModel, "extras.htmlId", null));
        },

        _templateId : function(){
            return this.getOrElse(this._templateRef(), "extras.htmlId", null);
        },

        _createGetterSetter : function(container,name,obj) {
            var iName = "_" + name + "_";
            if(!container.hasOwnProperty(name)){
                Object.defineProperty(container,name,{
                    get: function() {
                        if(this._private[iName]) {
                            return this._private[iName]._getNakedThis();
                        }
                        return undefined;
                    },
                    set : function(val) {
                        var obj = this._private[iName];
                        obj[obj._default] = val;
                    }
                });
            }
            container._private[iName]=obj;
        },

        _getDefaultAttribute : function(attribute) {
            return this._xfa()._templateSchema.getDefaultAttribute(this.className, attribute);
        },

        _getDefaultElement : function(elName, index, append) {
            var relation = this._xfa()._templateSchema._getRelation(this.className, elName);
            if(relation == xfalib.template.Constants.zeroOrOne || relation == xfalib.template.Constants.oneOfChild ||
                ((relation == xfalib.template.Constants.zeroOrTwo || relation == xfalib.template.Constants.zeroOrFour) && index == 0)){
                var defaultEl = xfalib.script.XfaModelRegistry.prototype.createModel({_class : elName});
                if(defaultEl && append){
                    this._addChild(defaultEl._getNakedThis());
                }
                return defaultEl;
            }
            else
                return null;
        },

        _getDataType: function(attribute) {
            return this._xfa()._templateSchema._getDataType(this.className, attribute);
        },

        _getRelation: function(child) {
            return  this._xfa()._templateSchema._getRelation(this.className,child.className);
        },

        //this function filters the nodes based on a filterFn.
        //this processes not only immediate children but goes recursively through the whole tree
        _filterNodes:function(filterFn) {
            var nodeList = new xfalib.script.XfaList();
            if (this._isContainerNode()) {
                var children = this._getChildren();
                for(var i=0; i< children.length; i++){
                    var n = children.item(i);
                    if(filterFn(n))
                        nodeList._append(n);
                    nodeList._concat(n._filterNodes(filterFn));
                }
            }
            return nodeList;
        },

        getElement: function(className,index, bPeek) {
            index = index || 0;
            var arr = this._findChildren(xfalib.script.XfaModelRegistry.prototype.createSomExpression(className+"["+index+"]"),false);
            if(arr && arr.length >0)
                return arr.item(0);
            else if(!bPeek && (this._getOneOfChild &&  !this._getOneOfChild(true)))
                return this._getDefaultElement(className, index, true);
            else
                return null;
        },

        setElement: function(element, className,index){
            if(_.isNumber(element) || _.isBoolean(element) || _.isDate(element) || _.isString(element)){
                var childNode = this.getElement(className, index);
                if(childNode && childNode._default){
                    childNode[childNode._default] = element;
                }
            }
            return null;
        },

        setAttribute: function(value, attrName){
            this.jsonModel[attrName] = this.validateInput(value, this._getDataType(attrName),this.jsonModel[attrName]);
        },

        /**
         * Return the DataSOMMap after adding an entry in the map for the node. The entry contains the value of the node
         * along with its Data SOM. If there is no Data SOM then return the unmodified map
         * @param map
         * @private
         */
        _getDataSomMap : function(map) {
            return map;
        },

        /**
         * Update the value of the node with the value provided in the input map. The map contains the values of the fields
         * mapped with their DataSOM. The function is empty for all the nodes, except for Field, Subform and Area.
         * @param map
         * @private
         */
        _restoreDataSomMap : function (map) {

        },

        _playDataXML: function(xmlDocument, contextNode) {

        },

        generateDataXML: function(rootNode, contextNode) {

        }

    });

    Node.defineProps({
        "parent" : {
            get : function() {
                return this.mParent;
            },
            set : function(parent) {
                parent = this.validateInput(parent, "object",null);
                this.mParent = parent;
            },
            resolve:true
        },

        "name"  : {
            get : function() {
                return this.getAttribute("name");
            },
            set : function(sName) {
                //sName = this.validateInput(sName, "string");
                //this.jsonModel.name = sName;
            },
            configurable:true
        },

        "nodes" : {
            get : function() {
                if (this._isContainerNode()) {
                    return this._getChildren();
                }
                return new xfalib.script.XfaList();
            }
        },

        "index" : {
            get : function() {
                return this.mnIndex;
            },
            set : function(nIndex) {
                nIndex = this.validateInput(nIndex, "integer",this.mnIndex);
                this.mnIndex = nIndex;
            }
        },

        "somExpression" : {
            get : function() {
                return this._getSomExpression();
            },
            set : function() {
                xfalib.runtime.xfa.Logger.error("xfa", xfalib.locale.LogMessages["ALC-FRM-901-006"],["setting SomExpression"])
                throw "unsupported operation";
            }
        },

        "isContainer" : {
            get : function() {
                return this._isXFAContainerNode();
            }
        },

        "htmlId" : {
            get : function(){
                return this.getOrElse(this.jsonModel, "extras.htmlId", null);
            },
            set : function(sHtmlId){
                this.jsonModel.extras = this.jsonModel.extras || {};
                this.jsonModel.extras.htmlId = sHtmlId;
            }
        },

        "isNull" : {
            get : function(){
                return false;
            }
        },

        "all" : {
            get : function(){
                var list = new xfalib.script.XfaList();
                var som = xfalib.script.XfaModelRegistry.prototype.createSomExpression(this.jsonModel.name+"[*]");
                try {
                    if(this.jsonModel.name)  {
                        if(this.parent)
                            return this.parent._findChildrenDeep(som, true);
                        else return list;
                    }
                    else throw "Name undefined" ;
                }
                catch(e)   {
                    console.error("Get operation all requires the node to have a name");
                }


            }
        },

        "extras" :{
            get: function() {
                return this.getElement("extras",0)
            }
        }

    });
})(_, xfalib);


/**
 * @package xfalib.script.Element
 * @import xfalib.script.Node
 * @fileOverview The file creates the Element Class required for XFA
 *               library
 * @version 0.0.2
 */

(function (_, xfalib) {
    /**
     * @class The class represents all the XFA Objects which can contain other XFA
     *        nodes inside them
     * @extends com.adobe.xfa.scripting.Node
     *
     * @property {Array} children children of the Element
     *
     * @constructor
     * @param {string}
     *            name the name of the node
     *
     * @type {*|void}
     */
    var Element = xfalib.script.Element = xfalib.script.Node.extend({

        initialize: function () {
            Element._super.initialize.call(this);
            this._moChildNodes = [];
            this.mnCurrentIndex = -1;
            this.moNameArray = new Object();
            this.moNormalizedChildren = new Array();
            this._private = {};
            this._initChildren();
        },

        _initChildren: function () {
            var children = new Array();
            var lastCreatedInstanceManager = null;

            if (this.jsonModel.children) {
                var j = 0;
                for (var i = 0; i < this.jsonModel.children.length; i++) {
                    var child = this.jsonModel.children[i];
                    var childModel = xfalib.script.XfaModelRegistry.prototype.createModel(child);
                    if (childModel instanceof xfalib.script.InstanceManager) {
                        lastCreatedInstanceManager = childModel;
                    }
                    else if (childModel instanceof xfalib.script.Subform) {
                        if (lastCreatedInstanceManager != null) {
                            if (lastCreatedInstanceManager.name.length == 0)
                                lastCreatedInstanceManager.name = "_" + childModel.name;
                            lastCreatedInstanceManager._manageChild(childModel);
                        }
                    }
                    if (childModel) {
                        children[j++] = childModel;
                    }
                }
                this.children = children;
            }
        },

        _getChildren: function (child) {
            var parent = this;
            var obj = {"parent": parent};
            var list = new xfalib.script.XfaList(obj);
            for (var i = 0; i < this.moChildNodes.length; i++) {
                list._append(this.moChildNodes[i]._getNakedThis());
            }
            return list;
        },

        /**
         * The functions adds a child to this containerNode
         *
         * @function
         * @param {node}
         *            child The child node to add to this Element
         *
         */
        _addChild: function (child) {
            if (child != null) {
                this._addChildAt(child, this.moChildNodes.length);
            }
        },

        /**
         * @private
         * @function returns true if this is a scopeless container
         *
         */
        scopeless: function () {
            return false;
        },

        //includeDomElement tells whether DOMElement should be escalated to their parent
        appendNormalizedChildren: function (oNormalizedChildren, includeDomElement) {
            var i = 0;
            for (i = 0; i < this.moChildNodes.length; i++) {
                var oChild = this.moChildNodes[i];
                if (oChild != null) {
                    //CQ-102341 : border child of unnamed subform was getting appended to parent subform
                    if(includeDomElement === true || !(oChild instanceof xfalib.script.dom.Border)) {
                        oNormalizedChildren.push(oChild);
                    }
                    var oContainer = oChild;
                    if (oContainer
                        && (oContainer._isContainerNode() && oContainer.scopeless())) {
                        oContainer.appendNormalizedChildren(oNormalizedChildren, false);
                    }
                }
            }
        },

        /**
         * @private
         *
         * adds a dynamic property to this container.
         *
         * @param sName
         *            the name of the property to be added.
         * @param oValueObject
         *            the value of the property that is added.
         * @return the 0 based index of the property name.
         */
        _addProperty: function (sName, oValueObject, createGetterSetter) {
            var nIndex = 0;
            if ((sName != null) && (sName.length > 0)) {
                if (oValueObject == null) {
                    //
                    // just reset it
                    //
                    if (this[sName])
                        this[sName] = null;
                    this.moNameArray[sName] = 0;
                } else {
                    //
                    // add it as a property also keep track of the index
                    //
                    this.moNameArray[sName] = this.moNameArray[sName] || nIndex;
                    nIndex = this.moNameArray[sName]++;
                    if (nIndex == 0 && createGetterSetter) {
                        //
                        // Only put the first instance as a property of the container
                        // don't overwrite non dynamic properties
                        //
                        this._createGetterSetter(this, sName, oValueObject);
                    }
                }
            }
            return nIndex;
        },

        normalizeChildren: function () {
            this.moNormalizedChildren = new Array();
            this.appendNormalizedChildren(this.moNormalizedChildren, true);
            var bScopeless = this.scopeless();

            if (bScopeless) {
                //
                // must scope children in the parent container
                //
                var oParent = this.parent;
                if (oParent != null)
                    oParent.normalizeChildren();
            }

            var i = 0;
            this.moNameArray = new Object();
            for (; i < this.moNormalizedChildren.length; i++) {
                var oChild = this.moNormalizedChildren[i];
                //
                // Set properties and indices based on normalized children
                //
                var createGetterSetter = this._requireGetterSetter(oChild);
                var index = this._addProperty(this.getOrElse(oChild.jsonModel, "name", ""), oChild, createGetterSetter);
                var classIndex = this._addProperty('#' + oChild.className, oChild, false);
                if (!bScopeless) {
                    //
                    // scope indexes relative to this container
                    //
                    oChild.index = index;
                    oChild.mnClassIndex = classIndex;
                }
            }
        },

        /**
         * @private
         * @function
         * @returns {boolean} returns whether the node is an instance of a container
         *          Node or not
         */
        _isContainerNode: function () {
            return true;
        },

        _requireGetterSetter: function (oChild) {
            //Tests whether dynamic getter/setter should be generated for this child which happens for infinite cardinality
            var relation = this._getRelation(oChild);
            return (relation == null || relation.max == Infinity);
        },

        _findChildren: function (oSOM, bMultiple) {
            var arr = new xfalib.script.XfaList();
            var elemFound = false;
            for (var j = 0; j < this.moNormalizedChildren.length; j++) {
                var oChild = this.moNormalizedChildren[j];
                var relation = this._getRelation(oChild);
                if (oSOM.equals(oChild) || (relation && relation.max != Infinity && oSOM.tagEquals(oChild))) {
                    arr._append(oChild._getNakedThis());
                    elemFound = true;
                }
                if (elemFound && !bMultiple)
                    return arr;
                else if (elemFound && oSOM.index != '*')
                    break;
            }

            if (oSOM.scalerMatch != null) {
                if (bMultiple == false) {
                    arr._append(oSOM.scalerMatch._getNakedThis());
                    return arr;
                }
                else {
                    // arr = [];
                    // arr.length = oSOM.scalarMatch;
                }
            }

            return arr;
        },

        /**
         * @private
         *
         * like _findChildren but searches deep for a match
         */
        _findChildrenDeep: function (oSOM, bMultiple) {
            var oObject = this._findChildren(oSOM, bMultiple);
            if (oObject == null || oObject.length == 0) {
                var oChildren = this.children;
                for (var j = 0; j < oChildren.length; j++) {
                    oObject = oChildren[j]._findChildrenDeep(oSOM, bMultiple);
                    if (oObject && oObject.length > 0)
                        break;
                }
            }
            return oObject;
        },

        /**
         * @private
         *
         * get the index of the specified child.
         *
         * @param {com.adobe.xfa.scripting.Node}
         *            oNode the node of which the index is to be found.
         * @return {number} the 0 based index of the node or -1 if not found.
         */
        _getChildIndex: function (oNode) {
            return this.moChildNodes.indexOf(oNode);
        },

        /**
         * @private
         *
         * add specified child to the specified index.
         *
         * @param oNode
         *            the node to be added.
         * @param nINdex
         *            the index where the child will be inserted.
         */
        _addChildAt: function (oNode, nIndex) {
            this.moChildNodes.splice(nIndex, 0, oNode);
            this.jsonModel.children = this.jsonModel.children || [];
            this.jsonModel.children.splice(nIndex, 0, oNode.jsonModel);
            oNode.parent = this;
            this.normalizeChildren();
            this._postAddChild(oNode);
        },

        _postAddChild: function (oNode) {
            oNode._initialize();
            if (oNode instanceof xfalib.script.DOMElement || oNode instanceof xfalib.script.GenericText) {
                oNode.on(xfalib.script.XfaModelEvent.DOM_CHANGED, this);
            }
        },

        _destroy: function (oChild) {
            for (var i = 0; i < this.moChildNodes.length; i++) {
                var child = this.moChildNodes[i];
                if (child != null)
                    child._destroy();
            }
            Element._super._destroy.call(this, oChild);
        },

        _removeAll: function () {
            _.each(this.moChildNodes, function (oChild, index) {
                oChild._destroy();
            });
            this.moChildNodes = [];
            this.jsonModel.children = [];
            this.normalizeChildren();
            //ToDo add event trigger like _remove method if required
        },

        _removeChild: function (oChild) {
            oChild._destroy();
            var nIndex = this.moChildNodes.indexOf(oChild);
            this.moChildNodes.splice(nIndex, 1);
            this.jsonModel.children.splice(nIndex, 1);
            this.normalizeChildren();
            this._postRemoveChild(oChild);
        },

        _postRemoveChild: function (oChild) {
            //do nothing here
        },

        /**
         * @private
         *
         * initialize this Container Node
         */
        _initialize: function () {
            if ((this.moChildNodes == null) || (this.moChildNodes.length == 0)) {
                this.mbInitialized = true;
                return;
            }

            if (this._xfa() == null) {
                throw (xfalib.locale.LogMessages["ALC-FRM-901-003"]);
            }

            // Init this
            if (this.parent == null) {
                this.index = 0;
                //this._xfa()._pushContextNode(this);
            }

            //
            // loop through the controls that are child components of this container
            // copy into array, since moChildNodes may be modified as we initialize
            // InstanceManagers
            //

            var oChildren = this.moChildNodes;
            for (var i = 0; i < oChildren.length; i++) {
                var oNode = oChildren[i];
                if (oNode == null)
                    xfalib.runtime.xfa.Logger.error("xfa", xfalib.locale.LogMessages["ALC-FRM-901-004"], [this.getAttribute("name"), i]);
                else
                    oNode._initialize();
            }

            this.mbInitialized = true;

        },

        playJson: function (pJsonModel) {
            /*
             * playJson assumption: The non dom elements should always maintain the structural hierarchy.
             * For dom elements, we support only value and items. rest are ignored.
             */
            Element._super.playJson.call(this, pJsonModel);
            var schemaChildren = this._xfa()._templateSchema.getChildren(this.className);
            _.each(schemaChildren, function (schemaChildProps, schemaChildTag) {
                // if schemaChildTag is a DOMelem other than items,value continue
                if (xfalib.script.dom[schemaChildTag.charAt(0).toUpperCase() + schemaChildTag.substring(1)] !== undefined // TODO : take care of those domElements with 2nd order inheritance
                    && !_.contains(["value", "items"], schemaChildTag)) {
                    return;
                }
                if (this.playJsonForElement(schemaChildTag, pJsonModel)) {   // continue if this childTag has special handling
                    return;
                }

                var relation = schemaChildProps.relation;
                var newJChildren = _.filter(_.compact(pJsonModel.children), function (jChild) {
                    return jChild._class == schemaChildTag;
                }, this);
                var oldMChildren = _.filter(this.moChildNodes, function (mChild) {
                    return mChild.className == schemaChildTag;
                }, this);
                var oneOfChildProcessed = false;

                // to merge field items having bingdItems property
                // honour saveProperty while playingJson for new and old children
                // items have zeroOrTwo relation
                if (schemaChildTag == "items" && this.getElement("#bindItems") && oldMChildren.length && newJChildren.length) {
                    var childIndex = -1,
                        newChild = null,
                        oldChild = null;
                    childIndex = _.findIndex(oldMChildren , function (oldMChild) {
                        return this.getOrElse(oldMChild, "save", 0) == 1;
                    }, this);
                    oldChild = oldMChildren.splice(childIndex, 1);
                    childIndex = _.findIndex(newJChildren , function (newJChild) {
                        return this.getOrElse(newJChild, "save", 0) == 1;
                    }, this);
                    newChild = newJChildren.splice(childIndex, 1);
                    oldChild[0].playJson(newChild[0]);  // playJson for item having save property

                    oldChild = oldMChildren.shift();
                    newChild = newJChildren.shift();
                    if (oldChild && newChild) {
                        oldChild.playJson(newChild);  //playJson for item without save property
                    }
                }

                switch (relation) {
                    case xfalib.template.Constants.zeroOrOne :
                        if (newJChildren.length > 0 && oldMChildren.length == 0) { //Addition
                            var newMChild = xfalib.script.XfaModelRegistry.prototype.createModel(newJChildren[0]);
                            this._addChild(newMChild);
                        }
                        else if (newJChildren.length == 0 && oldMChildren.length > 0) { //removal
                            this._removeChild(oldMChildren[0]);
                        }
                        else if (newJChildren.length > 0 && oldMChildren.length > 0) {
                            oldMChildren[0].playJson(newJChildren[0]);
                        }
                        break;

                    case xfalib.template.Constants.oneOfChild :
                        if (!oneOfChildProcessed && newJChildren.length > 0 && oldMChildren.length > 0) {
                            // For the time being let's assume oneOfChild type can not be modified and can not be added/removed
                            oldMChildren[0].playJson(newJChildren[0]);
                            oneOfChildProcessed = true;
                        }
                        break;

                    default :
                        _.each(oldMChildren, function (oldMChild) {
                            var newJChild = newJChildren.shift();
                            if (newJChild) {
                                oldMChild.playJson(newJChild);
                            }
                            else {
                                this._removeChild(oldMChild);
                            }
                        }, this);
                        if (newJChildren.length > 0) {
                            _.each(newJChildren, function (newJChild) {
                                var newMChild = xfalib.script.XfaModelRegistry.prototype.createModel(newJChild);
                                this._addChild(newMChild);
                            }, this);
                        }
                        break;
                }
            }, this);
        },

        playJsonForElement: function (elName, pJsonModel) {
            return false;
        },


        _computeJsonDiff: function (diff_level) {
            if (diff_level===0 && this._newChild == true) {
                return {
                    "changed": true,
                    "jsonDifference": this.jsonModel
                };
            }
            var diff = Element._super._computeJsonDiff.call(this, diff_level);
            var attrChangeFound = diff.changed;
            var dest = diff.jsonDifference;
            var initialJson = this._xfa()._xfaTemplateCache.getInitialFormDomRef(this.htmlId);
            if (!initialJson) {
                initialJson = this._xfa()._xfaTemplateCache.getInitialFormDomRef(this._templateId()) || {};
            }
            var childChangeFound = false;
            var initialJsonChildren = this.getOrElse(initialJson, "children", []);
            if (this.getOrElse(this.moChildNodes, "length", 0) != this.getOrElse(initialJsonChildren, "length", 0)) {
                childChangeFound = true;
            }
            else {
                childChangeFound = (null != _.find(this.moChildNodes, function (mChild, index) {
                    if ((mChild.className != initialJsonChildren[index]._class) || (mChild.jsonModel.name !== initialJsonChildren[index].name)) {
                        return true;
                    }
                    return false;
                }, this));
            }

            var destChildren = [];
            _.each(this.moChildNodes, function (mChild, index) {
                var childDiff = mChild._computeJsonDiff(diff_level) || {};
                if (!(diff_level>0 && _.isEmpty(childDiff.jsonDifference))) {  // skip if during submission & restoreFormState the childDiff is empty
                    destChildren.push(childDiff.jsonDifference);
                    if (!childChangeFound && childDiff.changed) {
                        childChangeFound = true;
                    }
                }
            }, this);

            if (diff_level>0 && destChildren.length == 0) { // skip if during submission  & restoreFormState no children present
                if (this.jsonModel._class !== 'form') { // except for root subform LC-9317
                    dest = undefined; // must be careful while assigning to jsonDifference, ideally should let it be {}, but this costs bytes in final json
                }
            } else {
                dest.children = destChildren;
            }

            return {"changed": childChangeFound || attrChangeFound,
                jsonDifference: dest
            };
        },

        _getOneOfChild: function (bPeek) {
            try {
                bPeek = typeof bPeek === "undefined" ? false : true;
                if (!this._oneOfChild && bPeek === false) {
                    var children = this._xfa()._templateSchema._getOneOfChild(this.className);
                    this._oneOfChild = _.find(this.moChildNodes, function (child) {
                        return child.className in children;
                    });
                    if (this._oneOfChild)
                        this._oneOfChild = this._oneOfChild._getNakedThis();
                }
                return this._oneOfChild;
            } catch (exception) {
                this._xfa().Logger.error("xfa", xfalib.locale.LogMessages["ALC-FRM-901-017"], [exception, "oneOfChild", contextObj.somExpression])
            }
        },

        /**
         * Return the bind child of the current element. getElement API doesn't return the correct value in case of
         * unnamed element inside the current element
         * @returns {*}
         * @private
         */
        _getBinding: function () {
            return _.find(this.moChildNodes, function(child) {
                return child.className === "bind"
            })
        },

        /**
         * Checks whether binding is none or not. Returns false if binding is set to none, otherwise false.
         * @returns {boolean}
         */
        hasDataBinding: function () {
            var bind = this._getBinding();
            //bind = null means use name binding
            return bind == null || bind.match !== "none";
        },

        /**
         * returns dataSom for the current field
         * @returns {*}
         * @private
         */
        _getDataSom: function () {
            return this.getOrElse(this, "extras.FS_EXTRAS.FS_DATA_SOM.value", null);
        },

        /**
         * Returns true if the bindRef for the element points to an attribute otherwise false.
         * @returns {boolean}
         * @private
         */
        _isBindRefAttribute: function () {
            return 1 == this.getOrElse(this, "extras.FS_EXTRAS.IS_ATTRIBUTE.value", 0);
        },

        _convertRefToXPath: function (bindRef) {
            var $regex = /^\$\./,
                $recordRegex = /^\$record\./,
                relative,
                _bindRef,
                somArray;
            if(bindRef.match($recordRegex) != null) {
                relative = false;
                _bindRef = bindRef.replace($recordRegex, "");
            } else {
                relative = true;
                _bindRef = bindRef.replace($regex, "");
            }
            somArray = xfalib.script.SOMExpression.prototype.splitExpression(_bindRef);
            _bindRef = _.reduce(somArray, function (memo, som, indx) {
                var currentSom = xfalib.script.XfaModelRegistry.prototype.createSomExpression(som, 0),
                    index = currentSom.index;
                // index in SOM Expression starts from 0 whereas in xpath it starts from 1
                if(_.isNumber(index)) {
                    index += 1;
                }
                if(indx === somArray.length - 1 && this._isBindRefAttribute()) {
                    // only last part in the bindRef can be attribute
                    return memo + "@" + currentSom.name;
                }
                return memo + currentSom.name + "[" + index + "]/"
            }, "", this);
            //replace the last / if exists with empty string
            _bindRef = _bindRef.replace(/\/$/,"");
            return {
                relative: relative,
                bindRef: _bindRef
            };
        },

        /**
         * Returns the xpath from the bind.dataref property. removes the leading $. from the dataRef.
         * TODO: in some places the dataRef property has $record. Need to discuss that case
         * Moreover this might not be needed if XTG provides DATASOM for the subforms.
         * @returns {*}
         * @private
         */
        _getXpathFromBindRef: function () {
            var bind = this._getBinding(),
                bindRef = this.getAttribute("name"),
                $regex = /^\$\./,
                $recordRegex = /^\$record\./,
                relative = true,
                somArray;
            if(bind != null) {
                if(bind.match === "dataRef") {
                    if(bind.ref.match($recordRegex) != null) {
                        relative = false;
                        bindRef = bind.ref.replace($recordRegex, "");
                    } else {
                        relative = true;
                        bindRef = bind.ref.replace($regex, "");
                    }
                    somArray = xfalib.script.SOMExpression.prototype.splitExpression(bindRef);
                    bindRef = _.reduce(somArray, function (memo, som, indx) {
                        var currentSom = xfalib.script.XfaModelRegistry.prototype.createSomExpression(som, 0),
                            index = currentSom.index;
                        // index in SOM Expression starts from 0 whereas in xpath it starts from 1
                        if(_.isNumber(index)) {
                                index += 1;
                        }
                        if(indx === somArray.length - 1 && this._isBindRefAttribute()) {
                            // only last part in the bindRef can be attribute
                            return memo + "@" + currentSom.name;
                        }
                        return memo + currentSom.name + "[" + index + "]/"
                    }, "", this);
                    //replace the last / if exists with empty string
                    bindRef = bindRef.replace(/\/$/,"");
                    return {
                        relative: relative,
                        bindRef: bindRef
                    };
                } else if (bind.match === "global" && ["field", "exclGroup"].indexOf(this.className) !== -1) {
                    return {
                        relative: "global",
                        bindRef: this.getAttribute("name") + "[1]"
                    };
                } else if(bind.match === "once") { // for fields with patterns
                    return this._getXPathForUseNameBinding();
                }
                // bind.match === null
                return null;
            }
            //use name binding
            /** for unnamed elements, with data binding as use name, we are returning null */
            return this._getXPathForUseNameBinding();
        },

        _getXPathForUseNameBinding: function () {
            var name = this.getAttribute("name"),
                //SOM Index starts from 0 while in XPath it starts from 1
                index = this.index + 1;
            return name === "" ? null
                               : {
                                    relative: true,
                                    bindRef: name + "[" + index + "]"
                                 };
        },

        /**
         * Iterate over every child and add entry for them into the dataSOMMap. See @ Node._getDataSomMap for more details
         * @param map
         * @private
         * if map is not an object it behaves as an identity function
         */
        _getDataSomMap: function(map) {
            if(!_.isObject(map)) {
                return map;
            }
            _.each(this.moChildNodes, function (child) {
                map = child._getDataSomMap(map);
            });
            return map;
        },

        /**
         * Iterate over every child and update their values based on the entries in the map. See @ Node._getDataSomMap
         * for more details
         * @param map
         * @private
         */
        _restoreDataSomMap: function (map) {
            if(!_.isObject(map)) {
                return;
            }
            _.each(this.moChildNodes, function (child) {
                child._restoreDataSomMap(map);
            })
        },

        /**
         * Evaluates the given xpath relative to contextNode or RootNode depending upon the value of xpath.relative
         * In case it is true, xpath is evaluates relative to contextNode otherwise rootNode
         * @param xpath
         * @param contextNode
         * @param rootNode
         * @returns {*}
         * @private
         */
        _getElementsFromXpath: function(xpath, contextNode, rootNode) {
            var nodeIter,
                XMLUtils = xfalib.ut.XMLUtils,
                doc = rootNode instanceof Document ? rootNode : rootNode.ownerDocument;
            if(xpath.relative === false) {
                nodeIter = XMLUtils.evaluateXPath(xpath.bindRef, rootNode, null,
                                    XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
            }
            else if(contextNode != null) {
                nodeIter = XMLUtils.evaluateXPath(xpath.bindRef, contextNode, null,
                                    XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
            }
            return nodeIter;
        },

        _playDataXML : function (xmlDocument, contextNode, currentBindRef) {
            _.each(this.children, function(child) {
               child._playDataXML(xmlDocument, contextNode, currentBindRef);
            }, this);
        },

        /**
         * Generates the XML by appending the elements in the rootNode
         * @param rootNode The rootNode of the xml. Generally the element that maps to the root of the form
         * @param contextNode Current Node where to insert the elements in case of relative bindings
         */
        generateDataXML: function (rootNode, contextNode) {
            _.each(this.moChildNodes, function(child) {
                child.generateDataXML(rootNode, contextNode);
            });
        },

        /**
         * Returns bindRef relative to parentBindRef. If bindRef is not a child of parentBindRef, returns null
         * otherwise removes the parentBindRef string from the bindRef
         * @param parentBindRef
         * @param bindRef
         * @returns {*}
         * @private
         */
        _getRelativeXPath: function(parentBindRef, bindRef) {
           var regexp = new RegExp("^" + parentBindRef+"/");
           if(bindRef.match(regexp)) {
              return bindRef.replace(regexp,"");
           }
           return null;
        }
    });

    Element.defineProps({
        "children": {
            get: function () {
                var nodes = [];
                for (var i = 0; i < this.moChildNodes.length; i++) {
                    var child = this.moChildNodes[i];
                    if (child != null)
                        nodes.push(child);
                }
                return nodes;
            },
            set: function (moChildren) {
                moChildren = this.validateInput(moChildren, "object", null);
                this.moChildNodes = new Array(moChildren.length);
                this.jsonModel.children = [];
                for (var i = 0; i < moChildren.length; i++) {
                    this.moChildNodes[i] = moChildren[i];
                    this.moChildNodes[i].parent = this;
                    this.jsonModel.children[i] = moChildren[i].jsonModel;
                }
                this.normalizeChildren();
            }
        },

        "oneOfChild": {
            get: function () {
                return this._getOneOfChild();
            }
        },

        moChildNodes: {
            get: function () {
                return this._moChildNodes;
            },
            set: function (value) {
                this._moChildNodes = value;
            }
        }

        /*"borderWidth" : {
         get : function() {
         this._borderWidth = this._borderWidth || "0.6624 px" ;
         return (this._borderWidth);
         },

         set : function(width) {
         //TODO: Set border.edge.presence property to visible once Border is implemented
         this._borderWidth = width ;
         var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED,
         this,"borderWidth",null,width);
         this.trigger(evnt.name,evnt);
         }
         },      */

    });

})(_, xfalib);


(function (_, xfalib) {
    var GenericText = xfalib.script.GenericText = xfalib.script.Node.extend({
        _default: "value",
        initialize: function () {
            GenericText._super.initialize.call(this);
            this._modelChanged = false;
        },

        setAttribute: function (value, attrName) {
            GenericText._super.setAttribute.call(this, value, attrName);
            this._modelChanged = true;
        },

        _computeJsonDiff: function (diff_level) {
            /*
             * Since we do not maintain initialJson or templateJson for DOM elements, we use this approximate method to compute jsonDiff.
             * This assumes that all attr changes would happen through setAttribute API.
             * seeAlso: DOMElement and NodeValue
             */
            // must pass 'this' node as argument array to computeDomJsonDiff
            return xfalib.ut.XfaUtil.prototype.stripOrCall.call(this, diff_level>0, xfalib.ut.XfaUtil.prototype.computeDomJsonDiff, [this]);
        }

    });

    GenericText.defineProps({
        "value": {
            get: function () {
                return this.jsonModel._value;
            },
            set: function (value) {
                if (value !== this.jsonModel._value) {
                    this._modelChanged = true;
                    var oldVal = this.jsonModel._value
                    this.jsonModel._value = this.validateInput(value, "string", this.jsonModel._value);
                    var event = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.DOM_CHANGED, this, this.className, oldVal, this.jsonModel._value);
                    this.trigger(event.name, event);
                }
            }
        }
    });

})(_, xfalib);

(function (_, xfalib) {
    var DOMElement = xfalib.script.DOMElement = xfalib.script.Element.extend({
        _default: "value",
        initialize: function () {
            DOMElement._super.initialize.call(this);
            this._normalizePending = true;
            this._childrenInitializePending = true;
            this._childModified = false;
            this._modelChanged = false;
        },

        handleEvent: function (evnt) {
            if (evnt.name == xfalib.script.XfaModelEvent.DOM_CHANGED) {
                evnt._property = this.className + "." + evnt._property;
                this.trigger(evnt.name, evnt);
            }
        },

        _initChildren: function () {
        },

        _initialize: function () {
            //do nothing
        },

        _initChildrenInternal: function () {
            var children = new Array();
            var tempNameContainer = {};
            if (this.jsonModel.children) {
                var j = 0;
                for (var i = 0; i < this.jsonModel.children.length; i++) {
                    var child = this.jsonModel.children[i];
                    var childModel = xfalib.script.XfaModelRegistry.prototype.createModel(child);
                    children[j++] = childModel;
                    childModel.parent = this;
                    childModel.on(xfalib.script.XfaModelEvent.DOM_CHANGED, this);
                    childModel._initialize();
                    if (childModel.name) {
                        var nameIndex = tempNameContainer[childModel.name] || 0;
                        childModel.index = nameIndex;
                        nameIndex++;
                        tempNameContainer[childModel.name] = nameIndex;
                    }
                    if (childModel.className) {
                        var classIndex = tempNameContainer["#" + childModel.className] || 0;
                        childModel.mnClassIndex = classIndex;
                        classIndex++;
                        tempNameContainer["#" + childModel.className] = classIndex;
                    }
                }
                this._moChildNodes = children;
            }
        },

        _getNakedThis: function () {
            if (this._normalizePending) {
                this.normalizeChildren();
                this._normalizePending = false;
            }
            return DOMElement._super._getNakedThis.call(this);
        },

        setAttribute: function (value, attrName) {
            DOMElement._super.setAttribute.call(this, value, attrName);
            this._modelChanged = true;
        },

        _postAddChild: function (oNode) {
            DOMElement._super._postAddChild.call(this, oNode);
//            if(oNode instanceof xfalib.script.DOMElement)
            //        oNode.on(xfalib.script.XfaModelEvent.DOM_CHANGED,this) ;
            this._childModified = true;
            oNode._newChild = true;
        },

        _postRemoveChild: function (oChild) {
            DOMElement._super._postRemoveChild.call(this, oChild);
            this._childModified = true;
        },

        playJson: function (pJsonModel) {
            if (_.contains(["value", "items"], this.className)) {
                xfalib.script.Element.prototype.playJson.call(this, pJsonModel);
            }
        },

        _computeJsonDiff: function (diff_level) {
            if (diff_level && diff_level != 3) {
                return {
                    "changed": false,
                    "jsonDifference": {}
                };
            } else { // not called during submission
                if (this._newChild) {
                    return {
                        "changed": true,
                        'jsonDifference': this.jsonModel
                    };
                } else {
                    /*
                     * Since we do not maintain initialJson or templateJson for DOM elements, we use this approximate method to compute jsonDiff.
                     * This assumes that all attr changes would happen through setAttribute API.
                     * seeAlso: GenericText and NodeValue
                     */
                    var selfDiff = xfalib.ut.XfaUtil.prototype.computeDomJsonDiff.call(this, this, diff_level),
                        childrenDiff = [],
                        changed = selfDiff.changed || this._childModified,
                        childChanged = false,
                        jsonDifference = selfDiff.jsonDifference;

                    _.each(this.moChildNodes, function (mChild) {
                            var childDiff = mChild._computeJsonDiff(diff_level) || {};
                            childChanged = childChanged || childDiff.changed;
                            if (childDiff.changed && !_.isEmpty(childDiff.jsonDifference)) {
                                childrenDiff.push(childDiff.jsonDifference);
                            }
                        },
                        this);
                    if (this._childModified || childChanged) {
                        jsonDifference.children = childrenDiff;
                    }

                    return {
                        "changed": changed,
                        "jsonDifference": jsonDifference
                    };
                }
            }
        },

        /**
         * Return the DataSOMMap after adding an entry in the map for the node. The entry contains the value of the node
         * along with its Data SOM. If there is no Data SOM then return the unmodified map
         * @param map
         * @private
         */
        _getDataSomMap : function (map) {
            return map;
        },

        /**
         * Update the value of the node with the value provided in the input map. The map contains the values of the fields
         * mapped with their DataSOM. The function is empty for all the nodes, except for Field, Subform and Area.
         * @param map
         * @private
         */
        _restoreDataSomMap : function (map) {

        },

        _playDataXML: function (rootNode, contextNode) {

        },

        generateDataXML: function (xmlDocument, contextNode) {

        }

    });

    DOMElement.defineProps({
        moChildNodes: {
            get: function () {
                if (this._childrenInitializePending) {
                    this._initChildrenInternal();
                    this._childrenInitializePending = false;
                }
                return this._moChildNodes;
            },
            set: function (value) {
                this._moChildNodes = value;
            }
        }

    });

})(_, xfalib);



/**
 * @package xfalib.script.ContainerNode
 * @import xfalib.script.Element
 * @fileOverview The file creates the Container Element Class required for XFA
 *               library
 * @version 0.0.1
 */

(function(_, xfalib){
    /**
     * @class The class represents all the XFA Objects which can contain other XFA
     *        nodes inside them
     * @extends com.adobe.xfa.scripting.Element
     *
     * @property {Array} children children of the ContainerNode
     *
     * @constructor
     * @param {string}
        *            name the name of the node
     *
     */
    var ContainerNode = xfalib.script.ContainerNode = xfalib.script.Element.extend({
        _isXFAContainerNode : function() {
            return true;
        }

    });

})(_, xfalib);


(function(_,xfalib){
    var EventContainerNode = xfalib.script.EventContainerNode = xfalib.script.ContainerNode.extend({
        _defaults : {
            "access" : "open",
            "event" : {
                "type" : "click" //ideally, this should be activity
            },
            "validate" : {
                "disableAll" : "0",
                "formatTest" : "warning",
                "nullTest" : "disabled",
                "scriptTest" : "error",
                "message" : {
                    "defaultMessage" : {
                        value: xfalib.locale.Strings.validationIssue
                    }
                }
            }
        },

        initialize : function(){
            EventContainerNode._super.initialize.call(this);
            /**
             * @private
             * @type Object
             */
            this.moEvents = {};
            /**
             * marks the event that are fired in the current script execution as true.
             *
             * @private
             * @type Object
             */
            this.mActiveEvents = {};
            this._errorText = null;
            this._mFailedValTest = null;
            this._mFailedValLevel = null; //can be warning or error
            this.dependant = [];
            this.tests= null; //must be overridden by sub classes
            /**
             * @private
             * @type string
             */
            this.mEffectiveAccess = null;
            this.mEffectivePresence = null;
            //Initialize events array
            this._addEvents();
            this._eventListener();

            this._moContext = null;  // will cache the nakedReferences for each EventContainerNode
         },

        // visit this and all child nodes recursively
        _visitAllmoChildren: function (visitor) {
            if (_.isFunction(visitor)) {
                visitor(this);
            }

            _.each(this.moChildNodes, function (child) {
                if (_.isFunction(child._visitAllmoChildren)) {
                    child._visitAllmoChildren(visitor);
                }
            });
        },


        _eventListener :function() {
            for ( var i = 0; i < this.moChildNodes.length; ++i) {
               var oNode = this.moChildNodes[i];
               if(oNode instanceof xfalib.script.DOMElement)
                  oNode.on(xfalib.script.XfaModelEvent.DOM_CHANGED,this) ;
             }
        },

        /**
         * @private
         * @function
         * @param predicateTest : function containing predicate test.
         * @param execEvent : function containing events which needs to be executed.
         * executes events on child nodes provided as execEvent.
         */
        _execEventOnChildNodes : function (childNodesFilter, execEvent) {
            if(!this._isField()){ //Ideally isField check should not be here but a short cut for now since it's the only excption.
                _.each (this.moChildNodes, function(oNode) {
                    if (childNodesFilter(oNode)) {
                        execEvent(oNode);
                    }
                });
            }
        },

        _childNodesFilter : function (oNode) {
            return oNode._isEventNode() && oNode.className != "pageSet" && oNode.presence != "inactive";
        },

        execInitialize : function () {
            function execEvent (oNode) {
                oNode.execInitialize()
            };
            this._execEventOnChildNodes(this._childNodesFilter, execEvent);
            this.execEvent("initialize");
        },

        execFormReady : function() {
            function execEvent (oNode) {
                oNode.execFormReady()
            };
            this._execEventOnChildNodes(this._childNodesFilter, execEvent);
            this.execEvent("$formready");
        },

        execLayoutReady : function() {
            function execEvent (oNode) {
                oNode.execLayoutReady()
            };
            this._execEventOnChildNodes(this._childNodesFilter, execEvent);
            this.execEvent("$layoutready");
        },

        execCalculate : function() {
            function childNodesFilter (oNode) {
                return oNode._isEventNode() && oNode.presence != "inactive";
            };
            function execEvent (oNode) {
                oNode.execCalculate()
            };
            if (!this._xfa().host.calculationsEnabled)
                return true;
            else {
                this._execEventOnChildNodes(childNodesFilter, execEvent);
            }
           this.execEvent("calculate");
        },

        execValidate : function() {
            if (!this._xfa().host.validationsEnabled)
                return true;
            var valid = true;
            if(!this._isField()){
                for ( var i = 0; i < this.moChildNodes.length; ++i) {
                    var oNode = this.moChildNodes[i];
                    if (oNode._isEventNode()){
                        if(!oNode.execValidate())
                            valid = false;
                    }
                }
            }
            valid = valid && this._validate([]);
            return valid;
        },

        execPreSubmit : function () {
            var isSubmissionAllowed = true;  // to handle the cancelAction property, which if true will prevent submission
            if(!this._isField()) {
                _.each (this.moChildNodes, function(oNode) {
                    if (oNode._isEventNode() && oNode.presence != "inactive") {
                        isSubmissionAllowed = oNode.execPreSubmit() && isSubmissionAllowed;
                    }
                });
            }
            if (this.execEvent("$formpreSubmit") == false) {
                isSubmissionAllowed = false;
            }
            return isSubmissionAllowed;
        },

        /**
         *
         * creates a scope so that all the nodes accessible from this node
         * are available to the script event and returns the previous scope
         *
         * After executing the script the scope must be reset using _resetNakedReferencesScope
         * Not doing that will result in unstable state and cause serious issues
         *
         * @private
         * @function
         */
        _createNakedReferencesScope : function() {
            var startNode = this,
                currentIndex = this.index,
                oldContext = {};

            //store the old context in order to reset it.
            _.extend(oldContext,xfalib.runtime._private);

            //TODO: optimize to check with lastNakedSubform
            if (this._moContext == null) {
                xfalib.runtime._private = {};
                while (startNode) {
                    startNode.nakedFieldReferences(currentIndex, true, xfalib.runtime);
                    currentIndex = startNode.index;
                    startNode = startNode.parent;
                }
                this._moContext = xfalib.runtime._private;    // just copy ref as we are recreating xfalib.runtime._private
            } else {
                xfalib.runtime._private = this._moContext;
            }
            return oldContext;
        },

        /**
         *
         * The function should be called after executing the script to reset the scope
         * Not doing that will result in unstable state and cause serious issues
         *
         * @private
         * @function
         */
        _resetNakedReferencesScope : function(scope) {
            xfalib.runtime._private = {};
            _.extend(xfalib.runtime._private, scope);
        },

        /**
         * @private
         * @function
         * @param {string} eventName captures the event and sends it to the {@link _eventHandler}
         */
        execEvent : function(eventName, detail) {
            if(typeof this.moEvents[eventName] === "undefined") {
                if(this._xfa().moContextNodes.length == 0) {
                    this._xfa().runCalcAndValidate();
                }
                return true;
            }
            xfalib.runtime.xfa.Logger.debug("xfa", eventName+" fired for "+this.somExpression);
            //use standard event names instead of our home made names to match what pdf returns to user
            var stdEventName = this.xfaUtil()._xtgEventName[eventName] ? this.xfaUtil()._xtgEventName[eventName] : eventName;
            switch(eventName){
                case "change":
                    if (detail===undefined)
                        var $event = new xfalib.script.XfaModelEvent({"jsonModel":{"name":stdEventName,"target":this}});
                    else
                        var $event = new xfalib.script.XfaModelEvent({"jsonModel":{"name":stdEventName,"target":this,
                            "prevText":detail.prevText,"newText":detail.newText,"keyDown":detail.keyDown,
                            "modifier":detail.modifier,"shift":detail.shift,"change":detail.change,"fullText":detail.fullText}});
                    break;
                case "click":
                    if (detail===undefined)
                        var $event = new xfalib.script.XfaModelEvent({"jsonModel":{"name":stdEventName,"target":this}});
                    else
                        var $event = new xfalib.script.XfaModelEvent({"jsonModel":{"name":stdEventName,"target":this,"modifier":detail.modifier,"shift":detail.shift}});
                    break;
                default:
                    var $event = new xfalib.script.XfaModelEvent({"jsonModel":{"name":stdEventName,"target":this}});

            }
            xfalib.runtime.$event = $event;
            this._xfa().event = $event;
            xfalib.runtime.event = xfalib.acrobat.AcroEvent.cloneEvent($event);
            if(this.access == "protected" && eventName!=="calculate" && eventName!== "validate") {
                return;
            }
            // According to xfa spec : when a container is inactive any calculations, validations, or events it would normally generate are suppressed
            if (this.mEffectivePresence == "inactive") {
                return;
            }

            if (this.mActiveEvents[eventName]) {
                return;
            }
            this.mActiveEvents[eventName] = true;
            this._xfa()._pushContextNode(this);
            this._xfa().moContextScriptEvent = eventName;

            var oldScope = this._createNakedReferencesScope();

            var temp$ = $;
            $ = this;
            var rValue = this._eventHandler(eventName);
            $ = temp$;
            this.mActiveEvents[eventName] = false;
            this._xfa()._popContextNode();
            this._xfa().moContextScriptEvent = null;

            $event = null;
            if(this._xfa().moContextNodes.length == 0) {
                this._xfa().runCalcAndValidate();
            } else {
                this._resetNakedReferencesScope(oldScope);
            }
            return rValue;
        },

        handleDomEvent: function(evnt) {
            this.trigger(evnt.name,evnt);
        },

        handleEvent : function(event) {
            switch (event.name) {
                case xfalib.script.XfaModelEvent.OBJECT_DESTROYED:
                    return this.removeDependant(event.target);
                case xfalib.script.XfaModelEvent.DOM_CHANGED:
                      this.handleDomEvent(event)
                default:
                    //xfa.Logger.debug("event " + event.name + " not supported");
                    return false;
            }
        },

        addDependant: function(oNode) {
            if(!~this.dependant.indexOf(oNode) && oNode != this)
                this.dependant.push(oNode);
        },

        _addEvents : function() {
            var events = _.filter(this.moChildNodes, function(childModel){
               return childModel.className == "event";
            });
            if (events && events.length > 0) {
                for ( var i = 0; i < events.length; i++) {
                    var event = events[i];
                    // ref was added to support formReady and layoutReady where the event names are available as
                    //$formReady and $layoutReady (check - _xtgEventName in the class: XfaUtil.js).
                    // When we add a style to an element, designer adds a ref value of '$'
                    //which is also the default. In such a scenario the event names become $click, $change, etc. To
                    //handle this for now (without a full implementation of ref) we are removing the $ default value
                    //and setting it as $click -> click, etc. For details on ref:
                    //http://blogs.adobe.com/formfeed/2009/03/xfa_30_event_propagation.html
                    var ref = (event.ref || "");
                    if(ref == "$") ref = "";
                    var type = ref + event.activity;
                    this.moEvents[type] = this.moEvents[type] || [];
                    var eventChild = event.oneOfChild;
                    switch(eventChild.className) {
                        case "script":
                            if(eventChild.value!=null && (eventChild.runAt === "server" || eventChild.value.trim().length >0))
                                this.moEvents[type].push(new xfalib.script.ExecutableScript({"jsonModel" : eventChild.jsonModel}));
                            break;
                        case "submit":
                            this.moEvents[type].push(new xfalib.script.Submit({"jsonModel" : eventChild.jsonModel}));
                            this._xfa()._newSubmitButton(this);  //TODO: What is it
                            break;
                    }
                }
            }

            var calcChild =  _.find(this.moChildNodes, function(childModel){
                return childModel.className == "calculate";
            });
            if(calcChild) {
                var calcScr = _.find(calcChild.moChildNodes, function(childModel){
                    return childModel.className == "script";
                });
                if(calcScr) {
                    this.moEvents["calculate"] = [new xfalib.script.CalculateScript({"jsonModel" : calcScr.jsonModel})];
                }
            }

            var validChild =  _.find(this.moChildNodes, function(childModel){
                return childModel.className == "validate";
            });
            if(validChild) {
                var validScr = _.find(validChild.moChildNodes, function(childModel){
                    return childModel.className == "script";
                });
                if(validScr) {
                    this.moEvents["validate"] = [new xfalib.script.ValidateScript({"jsonModel" : validScr.jsonModel})];
                }
            }

            //is it a good idea to create behaviorConfig at the formbridge or xfalib.runtime level???
            var behaviorConfig = new xfalib.ut.Version(formBridge.userConfig["behaviorConfig"]);

            //To maintain backward compatibility
            if(behaviorConfig.isOn('dataDependentFloatingField') || behaviorConfig.isOn('mfDataDependentFloatingField')) {
                //this is inserted by server when a draw element contains floating fields.
                var resolveChild = _.find(this.moChildNodes, function(childModel){
                    return childModel.className == "resolve";
                });
                if (resolveChild) {
                    this.moEvents["calculate"] = [];
                    this.moEvents["calculate"].push(new xfalib.script.FloatingFieldScript());
                }
            }
        },

        /**
         * @private
         * @function
         * @param {string} eventName Event Handler function to handle events thrown
         */
        _eventHandler : function(eventName) {
            var rValue = undefined;
            switch (eventName) {
                case "validate":
                    rValue = true;
                    break;
            }
            return rValue;
        },
        /**
         * @private
         * @function
         * returns if the node is eligible for validation or not based on the presence
         */
        _isEligibleForValidation : function() {
            return this.mEffectivePresence != "inactive";
        },

        _handleDependants: function() {
            for(var i =0;i<this.dependant.length;i++) {
                this._xfa().queueCalcEvent(this.dependant[i]);
            }
        },

        _isEventNode : function(){
            return true;
        },

        removeDependant: function(oNode) {
            this.dependant = _.without(oNode);       //TODO: What is it, no second argument?
        },

        _checkTests: function(sMessages) {
            var valid = true;
            var tests = this.tests || [];
            for(var i = 0;i<tests.length;i++) {
                valid = tests[i].apply(this,arguments);
                if(!valid)
                    break;
            }
            return valid;
        },

        _scriptTest : function(sMessages) {
            var valid = true;
            var valid = this.execEvent("validate");
            if (valid === false) {
                this._mFailedValTest = "scriptTest";
                this._mFailedValLevel  = this.getOrElse(this.validate.scriptTest, this._defaults.validate.scriptTest) ;
                this._errorText = this.validationMessage;
                this._addMessage(sMessages, this._errorText, this._mFailedValLevel);
            }
            return valid;
        },

        _validate : function(sMessages) {
            var oldFailedTest = this._mFailedValTest;
            var oldValid = this._errorText ? false : true;
            this._mFailedValTest = null;
            this._mFailedValLevel = null;
            this._errorText = null;
            var childValid = true;
            if (!this._isEligibleForValidation()) {
                return true;
            }
            if (this._xfa().host.validationsEnabled) {
                for ( var i = 0; i < this.moChildNodes.length; i++) {
                    var childNode = this.moChildNodes[i];
                    if(childNode._isEventNode()) {
                        childValid = this.moChildNodes[i]._validate(sMessages) && childValid;
                    }
                }
                var valid = this._checkTests(sMessages) && childValid;
                if(valid==false) {
                    var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED, this,"ValidationState",
                        this._mFailedValLevel, this._errorText);
                    this.trigger(evnt.name,evnt);
                    // true indicating that previously this field is not having error
                    // false indicating that now this field is having an error
                } else {
                    var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED,
                        this,"ClearError",null, null);
                    this.trigger(evnt.name,evnt);
                    // false indicating that previously this field is  having error
                    // true indicating that now this field is having an error i.e. error Cleared
                }
                xfalib.ut.XfaUtil.prototype._triggerOnBridge("elementValidationStatusChanged", this, "validationStatus", !valid, valid);
                //TODO: show the error to user.
                if (this._mFailedValTest != oldFailedTest || valid != oldValid)
                    this.execEvent("validationState");
            }
            return valid;
        },

        _addMessage : function(sMessages, sMessage, sSeverity) {
            if (sMessage) {
                var oMessageObject = new Object();
                oMessageObject.message = sMessage;
                oMessageObject.severity = sSeverity;
                oMessageObject.ref = this.somExpression;
                sMessages.push(oMessageObject);
            }
        },

        _calculateEffectiveAccess : function() {
            var parentAccess = this.parent ? this.parent.mEffectiveAccess: "open"
            var newEffAccess = (this.access === "open" && parentAccess)?parentAccess :this.access;
            if(this.mEffectiveAccess != newEffAccess)
            {
                var oldVal = this.mEffectiveAccess;
                this.mEffectiveAccess = newEffAccess;
                this._updateChildrenEffectiveAccess();
                var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED,
                    this,"access",oldVal,this.mEffectiveAccess);
                this.trigger(evnt.name,evnt);
            }
        },

        _updateChildrenEffectiveAccess : function() {
            if(!this._isField()){ //Ideally isField check should not be here but a short cut for now since it's the only exception.
                _.each(this.moChildNodes, function(elem) {
                    if(elem._isEventNode())
                        elem._calculateEffectiveAccess();
                })
            }
        },

        /**
         * @private
         * @function
         * calculate effective presence which is used to identify whether current node have ancestor presence inactive
         * According to XFA SPEC : A new value, inactive, is defined for the ubiquitous presence property. When applied to containers
         * this prevents the container and its contents from processing calculations, validations, and events.
         * When an outer container contains inner containers, and the outer container has a presence value that restricts its behavior,
         * the inner containers inherit the outer container’s restricted behavior regardless of their presence value.
         */
        _calculateEffectivePresence : function() {
            if (this.presence) {     // only calculate effective presence if it contains presence property
                var parentPresence = this.getOrElse(this, "parent.mEffectivePresence", "visible"),
                    newEffPresence = null;
                if (parentPresence == "inactive" ) {
                    newEffPresence = "inactive";
                } else if (parentPresence == "hidden" && this.presence != "inactive") {
                    newEffPresence = "hidden";
                } else if (parentPresence == "invisible" && this.presence == "visible") {
                    newEffPresence = "invisible";
                } else {
                    newEffPresence = this.presence;
                }
                if(this.mEffectivePresence != newEffPresence) {
                    this.mEffectivePresence = newEffPresence;
                    this._updateChildrenEffectivePresence();
                }
            } else {
                this._updateChildrenEffectivePresence();
            }
        },

        /**
         * @private
         * @function
         * calculate effective presence for child node
         */
        _updateChildrenEffectivePresence : function() {
            if(!this._isField() && this.moChildNodes){
                _.each(this.moChildNodes, function(oNode) {
                    if(oNode._isEventNode())
                        oNode._calculateEffectivePresence();
                });
            }
        },

        playJson : function(pJsonModel) {
            //Only handle special properties which has private property in model. Need a review of access property
            if (this._xfa()._templateSchema.hasAttribute(this.className, 'access')) {
                this.access = pJsonModel.access;
            }
            if (this._xfa()._templateSchema.hasAttribute(this.className, 'presence')) {
                this.presence = pJsonModel.presence; //Watson bug 3787002 : presence property changed by server side scrip
            }
            EventContainerNode._super.playJson.call(this, pJsonModel);
        },

        scopeless : function() {
            // TODO: check isArea
            return this.getAttribute("name").length == 0;
        },

        _resetData : function() {
            for ( var i = 0; i < this.moChildNodes.length; i++) {
                var oNode = this.moChildNodes[i];
                oNode._resetData();
            }
        },

        nakedFieldReferences : function(nIndex, createGetterSetter,obj) {
            for ( var i = 0; i < this.moNormalizedChildren.length; i++) {
                var oNode = this.moNormalizedChildren[i];
                if(this._requireGetterSetter(oNode))
                    oNode.getNaked(nIndex, createGetterSetter, obj,this);
            }
        },

        // return the traversal object
        getTraversalObject : function () {
            var children = this.getOrElse(this, "jsonModel.children", null),
                traversalObj = null;
            if(children) {
                traversalObj = _.find(children, function(child){ return child._class == "traversal"; });
            }
            return traversalObj;
        },

        // return NEXT/FIRST traversal object based on the operation(first/next) provided
        getNextTraversalSom : function (operation) {
            var traverse = null,
                traversalRef = null,
                traversalObj = this.getTraversalObject();
            if (traversalObj && (traverse = traversalObj.children)) {
                if (operation == xfalib.template.Constants.firstTraversal) {
                    traversalRef = _.find(traverse, function(child){ return child.operation == xfalib.template.Constants.firstTraversal});
                } else { // only first and next are supported and if no operation is mentioned then it is treated as next
                    traversalRef = _.find(traverse, function(child){ return child.operation != xfalib.template.Constants.firstTraversal});
                }
            }
            // TO DO: add handling for script in reference
            return traversalRef && this.resolveNode(traversalRef.ref) ? this.resolveNode(traversalRef.ref).somExpression : null;
        }
    });

    EventContainerNode.defineProps({
        "validate" : {
            get : function() {
                return this.getElement("validate", 0);
            },
            set : function(val) {
                return this.setElement(val,"validate");
            }
        },

        "errorText" : {
            get : function(){
                return this._errorText || "";
            }
        },

        "validationMessage" : {
            get : function() {
                var m = this.getOrElse(this.validate.message.scriptTest, this._defaults.validate.message.defaultMessage);
                return m.value;
              },
            set : function(val) {
                var nodes = this.validate.message.nodes;
                if(nodes.namedItem("scriptTest") === null) {
                    var node = this._xfa().form.createNode("text","scriptTest");
                    nodes.append(node);
                }
                this.validate.message.scriptTest.value =val;
                this.execValidate() ;
            }

        },

        "access" : {
            get : function() {
                return this.getOrElse(this.jsonModel.access, this._defaults.access);
            },
            set : function(vAccess) {
                vAccess = this.validateInput(vAccess, this._getDataType("access"), this.jsonModel.access);
                if (this.jsonModel.access != vAccess) {
                    this.jsonModel.access = vAccess;
                    this._calculateEffectiveAccess();
                }
            }
        },

        "relevant" : {
            get : function() {
                return this.getAttribute("relevant");
            },
            set : function(val) {
                val = this.validateInput(val, this._getDataType("relevant"), this.jsonModel.relevant) ;
                if (this.getAttribute("relevant") != val) {
                    this.jsonModel.relevant = val;
                    var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED,
                        this,"relevant",null,val);
                    this.trigger(evnt.name,evnt);
                }
            }
        },

        "desc" : {
            get : function() {
                return this.getElement("desc",0)
            }
        }

    });

})(_,xfalib);
/**
 * @package xfalib.script.Content
 * @import xfalib.script.Node	
 * @fileOverview The file creates the Content Node Class required for XFA library
 * @version 0.0.1
 */

//goog.provide('com.adobe.xfa.scripting.Content');
//
//goog.require('com.adobe.xfa.scripting.Node');

(function(_, xfalib){
    var Content = xfalib.script.Content = xfalib.script.Node.extend({
        msClassName: "content",
        /**
         * @private
         * @function
         * @returns {boolean} returns whether the node is an instance of a content Node or not
         */
        _isContent : function() {
            return true;
        }
    });
})(_, xfalib);


/**
 * @package xfalib.script.NodeValue
 * @import xfalib.ut.Class
 */


(function (_, xfalib) {
    var NodeValue = xfalib.script.NodeValue = xfalib.script.Content.extend({

        _default: "value",
        initialize: function () {
            NodeValue._super.initialize.call(this);
            this.jsonModel._value = this.jsonModel._value || null;
            this._initialJsonString = JSON.stringify(this.jsonModel);
            this._modelChanged = false;
        },

        _initialize: function () {
            NodeValue._super._initialize.apply(this, arguments);
            if (this._isFieldDescendant()) {
                this._modelChanged = true;
            }

        },

        /*
         * converts a value into the designated type. null is a valid value
         * for all types. For invalid value it returns undefined
         */
        typedValue: function (val, contentType) {
            if (typeof val === "undefined")
                return undefined;
            if (val === null || val === "")
                return null;
            return val;
        },

        /*
         * returns the typed value. since we never store undefined values
         * it always returns valid value
         */
        getValue: function (contentType, skipTypeCheck) {
            if(skipTypeCheck === true) {
                return this.jsonModel._value;
            }
            return this.typedValue(this.jsonModel._value, contentType);
        },

        _storeValue: function (val, typeVal) {
            this.jsonModel._value = val;
        },

        /*
         * converts val to its typed version and if val is valid stores
         * it.
         * returns whether the new value is different from the old one.
         */
        setValue: function (val, skipTypeCheck) {
            var oldVal = this.jsonModel._value,
                typeVal = this.typedValue(val),
                retVal = false;

            if (skipTypeCheck === true || typeof typeVal !== "undefined") {
                this._storeValue(val, typeVal);
                retVal = this.typedValue(oldVal) !== typeVal;
                this._modelChanged = true;  // LC-5465 : all field's whose value is set is to be reflected in jsonDiff
            }
            return retVal;
        },

        equals: function (oVal) {
            return (this.getValue() === oVal.getValue());
        },

        _computeJsonDiff: function (diff_level) {
            /*
             * Since we do not maintain initialJson or templateJson for DOM elements, we use this approximate method to compute jsonDiff.
             * Since value API is not as simple as other DOM api, we simply compare old and new json string to check if anything has changed
             * seeAlso: DOMElement and GenericText
             */
            var jsonStr = JSON.stringify(this.jsonModel);
            var changed = (this._initialJsonString != jsonStr);
            if (this.name === "FS_DATA_SOM" && diff_level === 3) {
                changed = true;
                this._modelChanged = true;
            }
            var jsonDiff = changed ? this.jsonModel : {_class: this.className, name: this.jsonModel.name};
            if (!changed && this._modelChanged)
                jsonDiff._value = this.jsonModel._value;
            return {
                "changed": this._modelChanged,
                jsonDifference: jsonDiff
            };
        },

        _isFieldDescendant: function () {
            var grandParent = this.getOrElse(this, "parent.parent", null);
            if (grandParent && grandParent.className == "field") {
                return true;
            }
            else {
                return false;
            }

        },

        playJson: function (pJsonModel) {
            if (pJsonModel._value != this.jsonModel._value) {
                this._modelChanged = true;
            }
            NodeValue._super.playJson.apply(this, arguments);
            if (typeof pJsonModel._value == "undefined")
                this.jsonModel._value = null;
        }
    });

    NodeValue.defineProps({
        "presence": {
            get: function () { //i am not sure how to make this property undefined so just removed setters
                return undefined;
            }
        },

        "value": {
            get: function () {
                return this.getValue();
            },

            set: function (sValue) {
                this.setValue(sValue);
                var event = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.DOM_CHANGED, this, this.className, null, this.value);
                this.trigger(event.name, event);
            }
        }

    });

})(_, xfalib);

/**
 * @package xfalib.script.ImageValue
 * @import xfalib.script.NodeValue
 */

(function (_, xfalib) {
    var ImageValue = xfalib.script.ImageValue = xfalib.script.NodeValue.extend({
        msClassName: "image"
    });
    ImageValue.defineProps({
        "href": {
            get: function () {
                return this.getAttribute("href");
            }
        }
    });
}(_, xfalib));/**
 * @package xfalib.script.TextValue
 * @import xfalib.script.NodeValue
 */

(function(_, xfalib){
    var TextValue = xfalib.script.TextValue = xfalib.script.NodeValue.extend({
        msClassName: "text",
        typedValue : function(val) {
            var tValue = TextValue._super.typedValue.call(this, val);
            if (tValue != null)
                tValue = tValue.toString();
            return tValue;
        }

    });

    TextValue.defineProps({
        "maxChars" : {
            get : function() {
                return this.getOrElse(this.jsonModel.maxChars, "0") ;
            },
            set : function(value) {
                if(value < 0 && value == parseInt(value))
                    value = "0";
                if(value >= 0 && value == parseInt(value))   {
                    this.jsonModel.maxChars = value;
                    value = (value == "0")?"255":value;
                    var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.DOM_CHANGED,
                        this,"maxChars",value, null);
                    this.trigger(evnt.name,evnt);
                }
            }
        }
    })
})(_, xfalib);

/**
 * @package xfalib.script.ExDataValue
 * @import xfalib.script.NodeValue
 */

(function(_, xfalib, $){

    var ExDataValue = xfalib.script.ExDataValue = xfalib.script.NodeValue.extend({
        msClassName: "exData",
        initialize : function(){
            ExDataValue._super.initialize.call(this);
            this._transformToXFACompliantModel();
            this._$internalXMLDoc = null;
            this._origTmpltVal = null;
        },

        _transformToXFACompliantModel: function(){
            if(this.className === "exData" && this.jsonModel._value !== null && this.jsonModel._value.indexOf("<body xmlns=") === -1 && this.jsonModel._value.indexOf("<body") !== -1){
                var openingBodyTagIndex = this.jsonModel._value.indexOf('<');
                var endingBodyTagIndex = this.jsonModel._value.indexOf('>');
                var bodyTagString = this.jsonModel._value.substring(openingBodyTagIndex, endingBodyTagIndex+1);
                this.jsonModel._value = this.jsonModel._value.replace(bodyTagString, '<body xmlns="http://www.w3.org/1999/xhtml" xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/" xfa:APIVersion="2.7.0.0">');
                // this.jsonModel._value = '<body xmlns="http://www.w3.org/1999/xhtml" xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/" xfa:APIVersion="2.7.0.0">' + this.jsonModel._value + '</body>';
            }
        },

        _computeJsonDiff: function() {
            // richtext field value should not be empty string.
            if(this.jsonModel._class === "exData" && !this.jsonModel._value){
                this.jsonModel._value = JSON.parse(this._initialJsonString)._value;
                this._transformToXFACompliantModel();
            }
            return {"changed" : true,
                jsonDifference : this.jsonModel
            };
        },

        typedValue: function(val, contentType) {
            //if contentType is not passed -> derive it from contentType attribute
            if(!contentType)
                contentType = this.getAttribute("contentType");
            switch(contentType) {
                case "text/plain":
                    return ExDataValue._super.typedValue.apply(this,[val]);
                case "text/xml":
                    if(val == null || val.length == 0)
                         return null;
                    try {
                        this._$internalXMLDoc = $.parseXML(val);
                    } catch(e) {
                        this._xfa().Logger.error("Invalid XML for the field");
                        return undefined;
                    }
                    //IE 9 supports XMLSerializer
                    return XMLSerializer ? (new XMLSerializer()).serializeToString(this._$internalXMLDoc): val
                case "text/html":
                    if(!(val && xfalib.ut.XfaUtil.prototype.isHTML(val))) {
                        if(this._$internalHTML == null) {
                           this._$internalHTML = $("<body><p></p></body>");
                        }
                        this._$internalHTML.html(xfalib.ut.XfaUtil.prototype.encodeScriptableTags(val));
                    } else {
                        var $val = $(val);
                        this._$internalHTML = $val;
                    }
                    return this._$internalHTML.text();
                default:
                    return ExDataValue._super.typedValue.apply(this,[val]);
            }
        },

        saveXML: function() {
            var prefix = '<?xml version="1.0" encoding="UTF-8"?>' +
                         '<exData contentType="text/html" xmlns="http://www.xfa.org/schema/xfa-template/3.6/">' +
                         '<body xmlns="http://www.w3.org/1999/xhtml" xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">',
                suffix = '</body></exData>',
                strXML = this.jsonValue;

                // TODO : use jQuery or XMLparser to do this more reliably
                if(strXML.indexOf("<body") >=0)
                    strXML = strXML.slice(strXML.indexOf(">", strXML.indexOf("<body"))+1);
                if(strXML.lastIndexOf("</body>") >=0)
                    strXML = strXML.slice(0,strXML.lastIndexOf("</body>"));

           return prefix + strXML + suffix ;
        },

        loadXML: function(strXML) {
        //TODO : add support for other params to loadXML, as of now all calls are equivalent to loadXML(x,true,true)
            var dispValue;
            if(strXML.indexOf("<body") != -1 && strXML.lastIndexOf("</body>") != -1) { // assuming a well formed valid XML string
                dispValue = strXML.slice(strXML.indexOf(">", strXML.indexOf("<body"))+1,strXML.lastIndexOf("</body>")); // get contents within <body> tags
            }
            if(this.getAttribute("contentType") == 'text/html') {
                if(dispValue.indexOf('<span>') != 0) {
                    dispValue = '<span>' + dispValue + '</span>';  // in case of multiple html elements, wrap in a span, else they overlap !!
                }

                var $internalHTML = $('<span>'+ dispValue +'</span>');
                $internalHTML.find("p").eq(0).css('display','inline');
                dispValue = $internalHTML.html();   // get the inner html with all markups

                this.jsonValue = dispValue;
            } else {
                dispValue = '<body>' + dispValue + '</body>';
                this.value = dispValue;
            }
          }
    });

    ExDataValue.defineProps({
        "jsonValue": {  // should use it to circumvent 'typedValue', which strips html tags
            get: function () {
                return this.jsonModel._value;
            },

            set: function (sValue) {
                if(_.isNull(this._origTmpltVal)) {
                    this._origTmpltVal = this.jsonModel._value;
                }
                this._modelChanged = true;  // just to be consistent & safe with 'value'

                if(sValue !== this.jsonModel._value) {
                    this.jsonModel._value = sValue;
                    var event = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.DOM_CHANGED, this, this.className, null, sValue);
                    this.trigger(event.name, event);
                }
            }
        }
    });
})(_, xfalib, $);

/**
 * @package xfalib.script.IntegerValue
 * @import  xfalib.script.NodeValue
 */

(function(_, xfalib){
    var IntegerValue = xfalib.script.IntegerValue = xfalib.script.NodeValue.extend({
        msClassName: "integer",
        typedValue : function(val) {
            var tValue = IntegerValue._super.typedValue.call(this, val);
            if (tValue != null) {
                tValue = parseInt(tValue);
                if (isNaN(tValue))
                   tValue = undefined;
            }
            return tValue;
        }
    });
})(_, xfalib);
/**
 * @package xfalib.script.DecimalValue
 * @import xfalib.script.NodeValue
 */

(function(_, xfalib){
    var DecimalValue = xfalib.script.DecimalValue = xfalib.script.NodeValue.extend({
        msClassName: "decimal",

        typedValue : function(val) {
            var tValue = DecimalValue._super.typedValue.call(this, val);
            if (tValue) {
                tValue = parseFloat(tValue);
                if (isNaN(tValue))
                    return undefined;
                var str = tValue + '';
                var len = str.length;
                var leadD = str.indexOf(".");
                var fracD = len - leadD - 1;
                if(fracD > this.fracDigits && this.fracDigits != -1)
                    tValue = parseFloat(tValue.toFixed(this.fracDigits));
                if(leadD > this.leadDigits && this.leadDigits != -1)
                    tValue = null;
            }
            return tValue;
        }
    });

    DecimalValue.defineProps({
        "fracDigits" : {
            get : function(){
                return this.getAttribute("fracDigits")
            }
        },

        "leadDigits" : {
            get : function(){
                return this.getAttribute("leadDigits")
            }
        }
    });
})(_, xfalib);


/*
 * @package xfalib.script.FloatValue
 * @import xfalib.script.NodeValue
 */
  

(function(_, xfalib){
    var FloatValue = xfalib.script.FloatValue = xfalib.script.NodeValue.extend({

        msClassName: "float",
        typedValue : function(val) {
            var tValue = FloatValue._super.typedValue.call(this, val);
            if (tValue) {
                tValue = parseFloat(tValue);
                if (isNaN(tValue))
                    return undefined;
                
            }
            return tValue;
        }
    });
})(_, xfalib);/*
 * @package xfalib.script.DateValue
 * @import xfalib.script.NodeValue
 */


(function(_, xfalib){
    var DateValue = xfalib.script.DateValue = xfalib.script.NodeValue.extend({
        msClassName: "date",
        typedValue : function(val) {
            var tValue = DateValue._super.typedValue.call(this, val);
            if (tValue) {
                var tValueParsed = xfalib.ut.DateInfo.Parse(tValue);
                if (tValueParsed !== null) {
                    tValueParsed = tValueParsed.getISODate();
                }
                // if value is not correctly parsed then return the original value
                return tValueParsed ? tValueParsed : tValue;
            }
            return tValue;
        }
    });
})(_, xfalib);/**
 * @package xfalib.script.Form
 * @import xfalib.script.ContainerNode
 */

(function (_, xfalib) {
    /**
     * @class
     * <p>
     * The Form class is the implementation of the top level XFA form object.
     * </p>
     *
     * <p>
     * The form object is accessed from the xfa object as xfa.form
     * </p>
     *
     */
    var DataNode = xfalib.script.DataNode = xfalib.ut.Class.extend({
        initialize : function() {
            this.jsonModel.value = null;
            this.fields = [];
        },

        getId : function () {
            return this.jsonModel.id;
        },

        /**
         * will sync fields having same dataId (same bindref or use global)
         * @param model
         */
        addField : function (model) {
            if (this.fields.length === 0 && model.rawValue != null) { // loose check for null/undef
                this.jsonModel.value = model.rawValue; // initialize dataNode group's value to 1st hierarchically reached field
            } else {
                model.rawValue = this.jsonModel.value;
            }
            this.fields.push(model);
            model.on(xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED, this);
        },

        handleEvent : function (evnt) {
            switch (evnt.name) {
                case xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED:
                    this.handleModelChanged(evnt);
                    break;
                default:
                    xfalib.runtime.xfa.Logger.debug("xfa", 'Unexpected  Event  "{0}" thrown in dataNode with id : "{1}" ', [evnt.name, this.jsonModel.id]);
            }
        },

        handleModelChanged : function (event) {
            if (event._property === "rawValue") {
                this._handleValueChange(event);
            }
        },

        _handleValueChange : function (event) {
            this._updateLinkedFieldsValue(event.prevText, event.target);
        },

        /**
         * will update all linked fields to the new value passed in
         * @param newValue
         * @param target
         * @private
         * @memberof DataNode
         */
        _updateLinkedFieldsValue : function (newValue, target) {
            if (newValue !== undefined && newValue != this.jsonModel.value) { // loose type coercion here for int/str
                this.jsonModel.value = newValue;

                _.each(this.fields, function (field) {
                    if (field !== target) {
                        field.off(xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED, this); // remove listeners to prevent event throw storm
                        field.rawValue = newValue;
                        field.on(xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED, this); // re attach listeners
                    }
                }, this);
            }
        }
    });
})(_, xfalib);
/**
 * @package xfalib.script.ExecutableScript
 * @import xfalib.ut.Class
 */


(function(_, xfalib){
    var ExecutableScript = xfalib.script.ExecutableScript = xfalib.ut.Class.extend({
        _defaults : {
            "runAt" : "client"
        },

        initialize : function(){
            ExecutableScript._super.initialize.call(this);
            this._scriptFn = null;
        },

        execute : function(contextObj, eventName) {
            // According to XFA SPEC : If the presubmit script is marked to be run only at the server, the data is sent to the server with an
            // indication that it should run the associated script before performing the rest of the processing. Client side script for presubmit
            // are executed before running validation.
            if(this.runAt == "server" && eventName != "$formpreSubmit") {
                var options = {};
                options.activity = this.xfaUtil()._xtgEventName[eventName] ? this.xfaUtil()._xtgEventName[eventName] : eventName;
                options.contextSom = contextObj.somExpression;
                contextObj._xfa().host.runServerScript(options);
            }
            else {
                return this._executeLocal(contextObj, eventName);
            }
        },

        _executeLocal :  function(contextObj, eventName) {
            try {
                this.script.call(contextObj);      // TODO : The best way will be to use `with` so that eval can also be used without modifying anything
            } catch(exception) {
                contextObj._xfa().Logger.error("xfa", xfalib.locale.LogMessages["ALC-FRM-901-002"],[eventName, contextObj.somExpression,exception.message])
            }
            return undefined;
        }

    });

    ExecutableScript.defineProps({
        "runAt" : {
            get : function(){
                return this.getOrElse(this.jsonModel.runAt, this._defaults.runAt);
            }
        },

        "script" : {
            get : function() {
                if(this._scriptFn == null) {
                    var scriptContent = this.jsonModel._value;
                    try{
                        var content = "with(this) {\n\n with(xfalib.runtime) {\n\n" + scriptContent + "\n\n}\n\n }";
                        this._scriptFn = new Function(content);
                    }catch(exception) {
                        xfalib.runtime.xfa.Logger.error("xfa", xfalib.locale.LogMessages["ALC-FRM-901-005"],[exception.message,scriptContent]);
                        this._scriptFn = new Function("");
                    }
                }
                return this._scriptFn;
            }
        }


    });

})(_, xfalib);

/**
 * @package xfalib.script.ValidateScript
 * @import xfalib.script.ExecutableScript
 */

(function(_, xfalib){
    var ValidateScript = xfalib.script.ValidateScript = xfalib.script.ExecutableScript.extend({

        initialize : function() {
            ValidateScript._super.initialize.call(this);
        },

        evalScript: function () {
            with(this){
                with(xfalib.runtime) {
                    var __XFA_evalValidateScriptRetVal__ = eval(arguments[0]); // LC-7319 : variable names passed in 'eval' are overridden due to enclosing 'with'
                }
            }
            return __XFA_evalValidateScriptRetVal__;
        },

        _executeLocal :  function(contextObj, eventName) {
            var rValue = true;
            try {
                if(this.script)
                    rValue = this.evalScript.call(contextObj,this.script);
                if(!rValue)
                    contextObj._xfa().Logger.debug("xfa", xfalib.locale.LogMessages["ALC-FRM-901-014"],[contextObj.somExpression,this.script])
            } catch(exception) {
                contextObj._xfa().Logger.error("xfa", xfalib.locale.LogMessages["ALC-FRM-901-002"],[eventName, contextObj.somExpression,exception.message])
                rValue = true;
            }
            return rValue;
        }

    });

    ValidateScript.defineProps({
        "script" : {
            get : function() {
                return this.jsonModel._value;
            }
        }
    });

})(_, xfalib);
/**
 * @package xfalib.script.CalculateScript
 * @import xfalib.script.ValidateScript
 */
(function(_, xfalib){
    var CalculateScript = xfalib.script.CalculateScript = xfalib.script.ValidateScript.extend({

        _executeLocal :  function(contextObj, eventName) {
            var rValue ;
            if(this.script){
                // pre_process
                contextObj._xfa()._pushCalculateEventNode(contextObj);

                try {
                    contextObj.rawValue = this.evalScript.call(contextObj,this.script)
                } catch(exception) {
                    contextObj._xfa().Logger.error("xfa", xfalib.locale.LogMessages["ALC-FRM-901-002"],[eventName, contextObj.somExpression,exception.message])
                }

                // post_process
                contextObj._xfa()._popCalculateEventNode();
            }
            return rValue;
        }

    });
})(_, xfalib);
/**
 * Created with IntelliJ IDEA.
 * User: rpandey
 * Date: 11/27/13
 * Time: 10:26 AM
 */
/**
 * @package xfalib.script.FloatingFieldScript
 * @import xfalib.script.CalculateScript
 */
(function(_, xfalib){
    var FloatingFieldScript = xfalib.script.FloatingFieldScript = xfalib.script.CalculateScript.extend({
        //Do we really need new class for FloatingFieldScript just for a different error message and a different script

        _executeLocal :  function(contextObj, eventName) {
            if(contextObj._resolveFloatingField){
                // pre_process
                contextObj._xfa()._pushCalculateEventNode(contextObj);

                try {
                    //Call _resolveFloatingField in this context
                    //this hard-coding decouples the server from script function name...
                    //Now it is only at the client side we keep the name of floating fields resolver script
                    this.evalScript.call(contextObj, '_resolveFloatingField()');
                } catch(exception) {
                    contextObj._xfa().Logger.error("xfa", xfalib.locale.LogMessages["ALC-FRM-901-019"],[contextObj.somExpression])
                }

                // post_process
                contextObj._xfa()._popCalculateEventNode();

            }

            return undefined;
        }

    });
})(_, xfalib);
/**
 * @package xfalib.script.Submit
 * @import xfalib.ut.Class
 */

(function(_, xfalib){
    var Submit = xfalib.script.Submit = xfalib.ut.Class.extend({

        initialize : function() {
            Submit._super.initialize.call(this);
        },

        execute : function(obj, eventName) {
            var options = {};
            if(this.target)
                options.action = this.target;
            options.format = this.format;
            options.textEncoding = this.textEncoding;

            formBridge.submitForm(options); //TODO: remove direct dependency on FormBridge
        }

    });

    Submit.defineProps({
        format : {
            get : function(){
                return this.getOrElse(this.jsonModel.format, null);
            }
        },

        target : {
            get : function(){
                return this.getOrElse(this.jsonModel.target, null);
            }
        },

        textEncoding : {
            get : function(){
                return this.getOrElse(this.jsonModel.textEncoding, null);
            }
        }

    });
})(_, xfalib);
/**
 * @package xfalib.script.Field
 * @import xfalib.script.Node
 * @import xfalib.script.XfaModelEvent
 * @fileOverview The file creates the Field Class required for XFA library
 * @version 0.0.1
 */

(function (_, xfalib) {
    /**
     * Creates a new Field class
     *
     * @constructor
     * @param {string}
     *            name the name of the Field
     * @param {string}
     *            rawVal initial value of the Field
     * @property {string} rawVal represents the data value in the node
     * @extends xfalib.script.Node
     */
    var Field = xfalib.script.Field = xfalib.script.EventContainerNode.extend({
        _defaults: {
            "items": {
                "save": "0"
            }
        },

        "_default": "rawValue",
        initialize: function () {
            Field._super.initialize.call(this);
            this.jsonModel["{default}"] = this._getValue();
            this.tests = [this._nullTest, this._formatTest, this._scriptTest];
            if (this.jsonModel.extras && this.jsonModel.extras.dataId)
                this._xfa().createDataNode(this.jsonModel.extras.dataId, this);
            for (var i = 0; i < this.moChildNodes.length; ++i) {
                var oNode = this.moChildNodes[i];
                oNode.on(xfalib.script.XfaModelEvent.DOM_CHANGED, this);
            }
            if (this.jsonModel.id) {
                this._xfa().Logger.debug("xfa", "Added field with id :" + this.jsonModel.id)
                this._xfa()._xfaTemplateCache.idMap[this.jsonModel.id] = this;
            }

            this.editPattern = this.getOrElse(this.jsonModel, "extras.editPatternEx", null);
        },

        playJson: function (pJsonModel) {
            Field._super.playJson.call(this, pJsonModel);

            // update data node cached value
            var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED, this,
                'rawValue', this.rawValue, this.formattedValue);
            this.trigger(evnt.name, evnt);
        },

        _setPattern: function (type, patterns, callback) {
            if (patterns && patterns.length) {
                this.jsonModel.extras = this.jsonModel.extras || {};
                _.each(patterns, function (pattern, i) {
                    pattern.locale = pattern.locale || this.locale
                }, this);
                this.jsonModel.extras[type] = patterns;
                return true;
            }
            return false;
        },

        handleDomEvent: function (evnt) {
            switch (evnt._property) {
                case "format.picture":
                    var res = this._setPattern("displayPatternEx",
                        xfalib.ut.PictureUtils.parsePictureClause(evnt.newText));
                    if (res) {
                        this._showDisplayFormat();
                    }
                    break;
                case "validate.picture":
                    var res = this._setPattern("validatePatternEx",
                        xfalib.ut.PictureUtils.parsePictureClause(evnt.newText));
                    if (res) {
                        this._validate([]);
                    }
                default:
                    xfalib.script.EventContainerNode.prototype.handleDomEvent.apply(this,
                        arguments);
            }
        },

        saveXML: function () {
            return this.rawValue;
        },

        loadXML: function (val) {
            //this.rawValue = val;
        },


        addItem: function (sDisplayVal, sSaveVal) {
            //call _getDisplayItems before saving any SaveItems.
            var sItems = this._getSaveItems(true);
            var dItems = this._getDisplayItems(true);

            var saveItem = {
                "_class": "text",
                "_value": sSaveVal === undefined ? sDisplayVal : sSaveVal
            };

            sItems._addChild(xfalib.script.XfaModelRegistry.prototype.createModel(saveItem));

            var displayItem = {
                "_class": "text",
                "_value": sDisplayVal
            };

            dItems._addChild(xfalib.script.XfaModelRegistry.prototype.createModel(displayItem));

            var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED,
                this, "addItem", saveItem._value, displayItem._value);
            this.trigger(evnt.name, evnt);
        },

        setItems: function (string, pair) {
            pair = pair === undefined ? 1 : pair;
            var that = this;
            var val = null;
            this.clearItems();
            var array = string.split(',');
            if (pair == 2) {
                array.forEach(function (entry, index) {
                    if (index % 2 == 1) {
                        that.addItem(elem, entry);
                        val = entry;
                    }
                    else
                        elem = entry;
                });
                if (array.length % 2)
                    that.addItem(elem);
                return true;

            }
            else if (pair == 1) {
                array.forEach(function (entry) {
                    that.addItem(entry);
                });
                return true;
            }
            else if (pair > 2)
                return  false;
            return;
        },

        clearItems: function () {
            var sItems = this._getSaveItems(false);
            var dItems = this._getDisplayItems(false);
            if (sItems)
                sItems._removeAll();
            if (dItems)
                dItems._removeAll();
            var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED,
                this, "clearItems", null, null);
            this.trigger(evnt.name, evnt);
        },

        boundItem: function (sDisplayVal) {
            var dItems = this._getDisplayItems(false);
            var saveValue = null;
            _.find(dItems ? dItems.children : [],
                function (item, index) {
                    if (item.value == sDisplayVal) {
                        saveValue = this.getSaveItem(index); //This should always be present
                        return true;
                    }
                    else
                        return false;
                }, this
            );
            return saveValue;
        },

        getDisplayItem: function (nIndex) {
            var dItems = this._getDisplayItems(true);
            if (nIndex >= 0 && dItems && dItems.children.length > nIndex)
                return dItems.moChildNodes[nIndex].value;
            else
                return undefined; //Don't change
        },

        getSaveItem: function (nIndex) {
            var sItems = this._getSaveItems(true);
            if (nIndex >= 0 && sItems && sItems.children.length > nIndex)
                return sItems.moChildNodes[nIndex].value;
            else
                return undefined; //Don't change
        },

        getItemState: function (nIndex) {
            var itemValue = this.getOrElse(this.getSaveItem(nIndex), this.getDisplayItem(nIndex));
            if (itemValue !== null && itemValue !== undefined) {
                return this.rawValue == itemValue;
            }
            return null; // TODO: return null or false
        },

        setItemState: function (nIndex, bVal) {
            var itemValue = this.getOrElse(this.getSaveItem(nIndex), this.getDisplayItem(nIndex));
            if (itemValue !== null && itemValue !== undefined) {                      //TODO:Is it correct. What about Text and NumericInput?
                if (bVal)
                    this.rawValue = itemValue;
                else if (this.rawValue == itemValue)
                    this.rawValue = null;
            }
        },

        deleteItem: function (nIndex) {
            var sItems = this._getSaveItems(false);
            var dItems = this._getDisplayItems(false);
            if (nIndex >= 0 && sItems && sItems.moChildNodes.length > nIndex) //Check whether negative value of nIndex is a legal value??
                sItems._removeChild(sItems.moChildNodes[nIndex]);
            if (nIndex >= 0 && dItems && dItems.moChildNodes.length > nIndex) //Check whether negative value of nIndex is a legal value??
                dItems._removeChild(dItems.moChildNodes[nIndex]);
            var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED,
                this, "deleteItem", null, nIndex);
            this.trigger(evnt.name, evnt);
        },

        execValidate: function () {
            return(this._validate([]));
        },

        nakedFieldReferences: function (nIndex, createGetterSetter, obj) {
            return;
        },

        _resetData: function (nIndex, bForce) {
            this.rawValue = this.jsonModel["{default}"];
        },

        _nullTest: function (sMessages) {
            var valid = true;
            var value = this._getValue();
            if ((value == null || value.length == 0) && this.mandatory != "disabled") {
                this._mFailedValTest = "nullTest";
                this._mFailedValLevel = this.mandatory;
                this._errorText = this.mandatoryMessage;
                this._addMessage(sMessages, this._errorText, this._mFailedValLevel);
                valid = false;
            }
            return valid;
        },

        _formatTest: function (sMessages) {
            var valid = true;
            var value = this._getValue();
            if (value)
                value += "";
            var picture = this.getOrElse(this.jsonModel,"extras.validatePatternEx", undefined);
            if (value != null && picture) {
                var retVal = this._formatValue(value, picture, 0);
                if (!retVal) {
                    this._setErrorData("formatTest", this.getOrElse(this.validate.formatTest, this._defaults.validate.formatTest), this.formatMessage);
                    this._addMessage(sMessages, this._errorText, this._mFailedValLevel);
                    valid = false;
                }
            }
            return valid;
        },

        _setErrorData: function (failedTest, failedLevel, errorText) {
            this._mFailedValTest = failedTest;
            this._mFailedValLevel = failedLevel;
            this._errorText = errorText;
        },

        _getSaveItems: function (createIfReqd) {
            var itemsList = this.
                _findChildren(xfalib.script.XfaModelRegistry.prototype.createSomExpression("items[*]"),
                true)
            var saveItems = itemsList._find(function (item, index) {
                return item.save == 1;
            });
            if (!saveItems && createIfReqd) {
                saveItems = xfalib.script.XfaModelRegistry.prototype.createModel({
                    _class: "items",
                    save: "1",
                    name: "items"
                });
                this._addChild(saveItems);
                var displayItems = itemsList._find(function (item, index) {
                    return item.save == 0;
                });
                saveItems.children = displayItems ? displayItems.moChildNodes : [];
            }
            if (saveItems)
                return saveItems;
            else
                return null;
        },

        _getDisplayItems: function (createIfReqd) {
            var itemsList = this.
                _findChildren(xfalib.script.XfaModelRegistry.prototype.createSomExpression("items[*]"),
                true)
            var displayItems = itemsList._find(function (item, index) {
                return item.save == 0;
            });
            if (!displayItems && createIfReqd) {
                displayItems = xfalib.script.XfaModelRegistry.prototype.createModel({
                    _class: "items",
                    name: "items"
                });
                this._addChild(displayItems);
                var saveItems = itemsList._find(function (item, index) {
                    return item.save == 1;
                });
                displayItems.children = saveItems ? saveItems.moChildNodes : [];
            }
            if (displayItems)
                return displayItems;
            else
                return this._getSaveItems();
        },

        _getValue: function (contentType, skipTypeCheck) {
            return this.value.oneOfChild.getValue(contentType, skipTypeCheck);
        },

        _setValue: function (sVal, skipTypeCheck) {
            return this.value.oneOfChild.setValue(sVal, skipTypeCheck);
        },

        _setHTMLValue: function(htmlStr) {
            // api to set the html value for cm use-case
            this._setValue(htmlStr, true);
            var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED, this,
                'rawValue', null, htmlStr);
            this.trigger(evnt.name, evnt);
        },

        _eventHandler: function (eventName) {
            var rValue = undefined;
            switch (eventName) {
                case "calculate":
                    if (this.moEvents["calculate"] && this.moEvents["calculate"].length > 0) {
                        rValue = this.moEvents["calculate"][0].execute(this, "calculate");
                    }
                    break;
                case "validate":
                    if (this.moEvents["validate"] && this.moEvents["validate"].length > 0) {
                        rValue = this.moEvents["validate"][0].execute(this, "validate");
                    } else
                        rValue = true;
                    break;
                case "$formpreSubmit":
                    rValue = this._preSubmitEventHandler();
                    break;
                default:
                    if (this.moEvents[eventName]) {
                        for (var i = 0; i < this.moEvents[eventName].length; i++) {
                            this.moEvents[eventName][i].execute(this, eventName);
                        }
                    }
            }
            return rValue;
        },

        _isField: function () {
            return true;
        },

        _showDisplayFormat: function () {
            var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED, this,
                'rawValue', this.rawValue, this.formattedValue);
            this.trigger(evnt.name, evnt);
        },

        _getDefaultPictureClause: function () {
            return "";
        },

        _formatValue: function (value, picture, force) {
            //testing specifically for only null and zero length string
            if (typeof value == "undefined" || value === null || value === "")
                return null;

            //force is same as bRelaxed , which is true in case of Display and false in case of parsing.
            force = force || false;
            if (picture) {
                var i = 0;
                for (; i < picture.length; i++) {
                    try {
                        var pattern = picture[i].category + "{" + picture[i].mask + "}";
                        return xfalib.ut.PictureFmt.format(value + "", pattern, picture[i].locale, force ,false);
                    } catch (exception) {
                        //continue to next pc
                    }
                }
            }
            if (force) {
                pattern = this._getDefaultPictureClause();
                try {
                    return xfalib.ut.PictureFmt.format(value + "", pattern, this.locale,force,true);
                } catch (exception) {
                    return value;
                }
            }
            return null;
        },

        _parseValue: function (value, picture) {
            if (typeof value === undefined)
                return value;

            if (picture) {
                var i = 0;
                for (; i < picture.length; i++) {
                    try {
                        var pattern = picture[i].category + "{" + picture[i].mask + "}";
                        return xfalib.ut.PictureFmt.parse(value, pattern, picture[i].locale);
                    } catch (exception) {
                        //continue to next pc
                    }
                }
            }
            pattern = this._getDefaultPictureClause();
            try {
                return xfalib.ut.PictureFmt.parse(value, pattern, this.locale);
            } catch (exception) {
                return value;
            }
        },


        _getLocale: function () {
            var obj = this;
            var locale;
            while (!locale && obj) {
                locale = obj.jsonModel.locale;
                obj = obj.parent;
            }
            locale = locale || this._xfa().defaultLocale;
            return locale;
        },

        scopeless: function () {
            return false;
        },

        _computeJsonDiff: function (diff_level) {
            //check bindings -> if it is none then this field is not needed in xml
            if (diff_level>0) {
                var bindElement = this.getElement("bind", 0, true);
                if (bindElement) {
                    if (bindElement.getAttribute("match") === "none" && diff_level === 2) {
                        return {
                            "changed": false,
                            "jsonDifference": {}
                        };
                    }
                }
            }
            return Field._super._computeJsonDiff.call(this, diff_level);
        },

        /**
         * Return the DataSOMMap after adding an entry in the map for the node. The entry contains the value of the node
         * along with its Data SOM. If there is no Data SOM then return the unmodified map
         * @param map
         * @private
         */
        _getDataSomMap : function(map) {
            if(!_.isObject(map)) {
                return map;
            }
            var datasom = this._getDataSom();
            if(datasom !== null) {
                map[datasom] = this.rawValue;
            }
            return map;
        },

        /**
         * Update the value of the node with the value provided in the input map. The map contains the values of the fields
         * mapped with their DataSOM. The function is empty for all the nodes, except for Field, Subform and Area.
         * The function does nothing if the map is not an object
         * @param map {object}
         * @private
         */
        _restoreDataSomMap : function (map) {
            if(!_.isObject(map)) {
                return;
            }
            var datasom = this._getDataSom();
            if (datasom != null && map[datasom] !== undefined) {
                this.rawValue = map[datasom];
            }
        },

        /**
         * Evaluates the given xpath relative to contextNode or RootNode depending upon the value of xpath.relative
         * In case it is true, xpath is evaluates relative to contextNode otherwise rootNode
         * For Fields, the value of xpath.relative can be "global" in which case we need to search the descendants of
         * the rootNode
         * @param xpath
         * @param contextNode
         * @param rootNode
         * @returns {*}
         * @private
         */
        _getElementsFromXpath: function(xpath, contextNode, rootNode) {
            var nodeIter,
                XMLUtils = xfalib.ut.XMLUtils,
                doc = rootNode instanceof Document ? rootNode : rootNode.ownerDocument;
            if(xpath.relative === "global") {
                nodeIter = XMLUtils.evaluateXPath("//"+xpath.bindRef, rootNode, null,
                    XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
                return nodeIter;
            }
            return Field._super._getElementsFromXpath.apply(this, arguments);
        },

        _playDataXML: function(xmlDocument, contextNode, currentBindRef) {
            if(this.hasDataBinding()) {
                var xpath = this._getXpathFromBindRef(),
                    dataPattern = this.jsonModel.dataPattern,// TODO : ideally should read from bind.picture.value
                    result, node,
                    logger = this._xfa().Logger;
                if(xpath != null) {
                    result = this._getElementsFromXpath(xpath, contextNode, xmlDocument);
                    if(result != null) {
                        node = result.iterateNext();
                        if(node != null) {
                            var preFillValue = node.textContent;

                            if(_.isString(dataPattern)) {
                                var parsedPattern = xfalib.ut.PictureUtils.parsePictureClause(dataPattern);
                                if(_.isArray(parsedPattern) && parsedPattern.length === 1) {
                                    try {
                                        // CQ-4244983 : changing the formatTest condition. Cases where prefilled value
                                        // is properly formatted, value was not being parsed and the rawValue in model
                                        // was being stored in data pattern
                                        // Ex : data pattern is text{999-99-9999} and value is 123-45-6789
                                        // 1) for mobile forms rawValue being stored is 123456789
                                        // 2) for formset rawValue being stored was 123-45-6789
                                        // in case the parse is incorrect because of mismatch in data pattern and prefillValue
                                        // then there will be data loss
                                        // and if there is any exception while parsing then original value is stored.
                                         
                                        preFillValue = xfalib.ut.PictureFmt.parse(preFillValue, dataPattern);

                                        // note : numeric parse doesn't throw, but returns 0, need to take care of it later
                                    } catch (e) {
                                        // must set value to preserve prefill data on submit
                                        this._setValue(node.textContent, true);  // need to set value without type checking, for numeric field doesn't allow non numeric chars
                                        logger.warn("xfa",
                                            logger.resolveMessage(xfalib.locale.LogMessages["ALC-FRM-901-021"],
                                                [dataPattern, node.textContent, e]));
                                    }
                                } else {
                                    this._setValue(node.textContent, true);
                                    logger.warn("xfa",
                                        logger.resolveMessage(xfalib.locale.LogMessages["ALC-FRM-901-022"],
                                            [dataPattern, node.textContent]));
                                }
                            }
                            // bug in picturefmt numeric parse : cant parse patterns with ( or ), but doesnt throw, returns 0 instead
                            if (_.isString(dataPattern) &&
                                dataPattern.trim().indexOf("num") === 0 &&
                                (preFillValue == 0 && parseFloat(node.textContent.replace(/[^0-9]/g, "")) !== 0)) { // hack: if parser returns 0, and input has any non zero digit then parsing failed
                                this._setValue(node.textContent, true);
                                logger.warn("xfa",
                                    logger.resolveMessage(xfalib.locale.LogMessages["ALC-FRM-901-023"],
                                        [dataPattern, node.textContent]));
                            } else {
                                this._setValue(preFillValue);
                            }
                        }
                    } else {
                        this._resetData();
                    }
                }
            }
        },

        /**
         * Generates the XML by appending the elements in the rootNode
         * @param rootNode The rootNode of the xml. Generally the element that maps to the root of the form
         * @param contextNode Current Node where to insert the elements in case of relative bindings
         */
        generateDataXML: function (rootNode, contextNode) {
            if(this.hasDataBinding()) {
                var xpath = this._getXpathFromBindRef(),
                    relativeXPath, nodeIter, nodeList = [], result, node;
                if(xpath != null) {
                    var element = xpath.relative === false || xpath.relative === "global" ? rootNode : contextNode;
                    element = xfalib.ut.XMLUtils.createElementsFromXPath(xpath.bindRef, element, false);
                    this._appendValueInXMLElement(element);
                }
            }
        },

        _appendValueInXMLElement: function (element) {
            if(element != null) {
                element.textContent = this._getValue(null, true); // LC-3911180 : need to circumvent type check to preserve data
            }
        },

        /**
         * @private
         * @function
         * executes presubmit event scripts and check for cancelAction property
         * return false if the cancelAction property is set true
         */
        _preSubmitEventHandler : function () {
            if (this.moEvents["$formpreSubmit"] && this.moEvents["$formpreSubmit"].length > 0) {
                this.moEvents["$formpreSubmit"][0].execute(this, "$formpreSubmit");
                // If a script invoked by the pre-submit event sets $event.cancelAction, the submit action does not take place
                if (this._xfa().event.cancelAction) {
                    return false;
                }
            }
            return true;
        }

    });

    Field.defineProps({
        "locale": {
            get: function () {
                if (!this._locale)
                    this._locale = this._getLocale();
                return this._locale;
            }
        },

        "multiLine": {
            get: function () {
                return (this.ui.oneOfChild.multiLine == 1);
            }
        },

        "rawValue": {
            get: function () {
                var currentNode = this._xfa().moCalculateEventNode;
                if (currentNode != null) {
                    this.addDependant(currentNode);
                    currentNode.on(xfalib.script.XfaModelEvent.OBJECT_DESTROYED, this);
                }
                return this._getValue(null, this.value.oneOfChild.getAttribute("contentType") === "text/html");
            },
            set: function (oValue) {
                oValue = this.validateInput(oValue, "string");
                if (this.value.oneOfChild.maxChars && this.value.oneOfChild.maxChars !== "0" && oValue && this.value.oneOfChild.maxChars < oValue.length)
                    oValue = oValue.slice(0, this.value.oneOfChild.maxChars);
                var oldval = this._getValue();
                if (this._setValue(oValue, this.value.oneOfChild.getAttribute("contentType") === "text/html")) {
                    this._handleDependants();
                    this._xfa().queueValidateEvent(this);
                }
                if (oldval != oValue)
                    this._showDisplayFormat();
            }
        },

         "font": {
                    get : function() {
                        return  this.getElement("font",0);
                    } ,
                    set :function(value) {
                          this.setElement(value,"font");
                    }
                },

        "fontColor" : {
            get : function () {
                return this.getElement("font", 0).getElement("fill", 0).getElement("color", 0).value;
            },
            set : function (value) {
                this.getElement("font", 0).getElement("fill", 0).getElement("color", 0).value = value;
            }
        },

        "value" : {
            get : function() {
                return  this.getElement("value",0);
            },
            set: function () {}
        },

        //TODO: Note: Below handling should handle both multiSelect and single Selects. Need to verify this.
        "selectedIndex": {
            get: function () {
                var value = this.rawValue;
                var itemSize = this.length;
                if (itemSize >= 0) {
                    for (var i = 0; i < itemSize; i++) {
                        var selected = this.getItemState(i);
                        if (selected)
                            return i;
                    }
                }
                return -1;   //default -1
            },
            set: function (nIndex) {
                nIndex = this.validateInput(nIndex, "string");
                this._setValue(null);
                this.setItemState(nIndex, true);
            }
        },

        "length": {
            get: function () {
                var items = (this._getSaveItems(false) || this._getDisplayItems(false));
                return items ? items.moChildNodes.length : 0;
            }
        },

        "parentSubform": {
            get: function () {
                var temp = this.parent;
                while (temp && temp.className !== "subform")
                    temp = temp.parent;
                return temp;
            }
        },

        "mandatory": {
            get: function () {
                return this.getOrElse(this.validate.nullTest, this._defaults.validate.nullTest);
            },
            set: function (value) {
                if (this.validate) {
                    this.validate.nullTest = value;
                }
            }
        },

        "mandatoryMessage": {
            get: function () {
                return xfalib.ut.XfaUtil.prototype._getMandatoryMessage(this);
            },
            set: function (val) {
                var nodes = this.validate.message.nodes;
                if (nodes.namedItem("nullTest") === null) {
                    var node = this._xfa().form.createNode("text", "nullTest");
                    nodes.append(node);
                }
                this.validate.message.nullTest.value = val;
                this.execValidate();
            }
        },

        "formatMessage": {
            get: function () {
                var msg = this.getOrElse(this.validate, "message.formatTest", this._defaults.validate.message.defaultMessage);
                return msg.value;
            },
            set: function (val) {
                var nodes = this.validate.message.nodes;
                if (nodes.namedItem("formatTest") === null) {
                    var node = this._xfa().form.createNode("text", "formatTest");
                    nodes.append(node);
                }
                this.validate.message.formatTest.value = val;
                this.execValidate();
            }
        },

        "formattedValue": {
            get: function () {
                return this._formatValue(this._getValue(), this.jsonModel.extras.displayPatternEx, true);
            },
            set: function (val) {
                this.rawValue = this._parseValue(val, this.jsonModel.extras.displayPatternEx);
            }
        },

        "isNull": {
            get: function () {
                if (this._getValue() != null)
                    return false;
                else return true;
            }
        },

        "editValue": {
            get: function () {
                return this._formatValue(this._getValue(), this.jsonModel.extras.editPatternEx, true);
            }
        },

        ui: {
            get: function () {
                return this.getElement("ui", 0);
            },

            set: function (value) {
                this.setElement(value, "ui");
            }
        },

        "items": {
            get: function () {
                return this.getElement("items", 0);
            }
        },

        "calculate": {
            get: function () {
                return this.getElement("calculate", 0);
            }
        },

        "format": {
            get: function () {
                return this.getElement("format", 0);
            }
        }


    });

    Field.addMixins([
        xfalib.script.mixin.AddAssist,
        xfalib.script.mixin.AddCaption,
        xfalib.script.mixin.AddPresence,
        xfalib.script.mixin.AddXYWH,
        xfalib.script.mixin.AddFillColor,
        xfalib.script.mixin.AddBorder,
        xfalib.script.mixin.AddBorderColor,
        xfalib.script.mixin.AddBorderWidth,
        xfalib.script.mixin.AddPara,
        xfalib.script.mixin.AddMargin
    ]);

})(_, xfalib);








/**
 * @package xfalib.script.Draw
 * @import xfalib.script.Node
 * @fileOverview The file creates the Draw Class required for XFA library
 * @version 0.0.1
 */

(function (_, xfalib, $) {
    /**
     * Creates a new Draw class
     *
     * @constructor
     * @param {string}
     *            name the name of the Draw
     * @extends com.adobe.xfa.scripting.Node
     */
    var Draw = xfalib.script.Draw = xfalib.script.EventContainerNode.extend({

        _setValue: xfalib.script.Field.prototype._setValue,

        _getValue: xfalib.script.Field.prototype._getValue,

        _getFieldById: function (fieldId) {

            if (this._xfa()._xfaTemplateCache.idMap.hasOwnProperty(fieldId)) {
                //xtg uses just the name of the field to find the actual context node
                //this is a quick and dirty way to ensure index affinity
                //just to be in sync with XTG, I am using the same implementation as XFALayoutTextResolver class
                var field = this._xfa()._xfaTemplateCache.idMap[fieldId];
                var resolvedField = null;

                var bQuit = false;
                var index = 0;
                //TODO : Can we have problem in context object setting while doing index affine resolutions ?
                while (!bQuit)
                {
                    var som = field.name + '[' + index + ']';
                    //this will be done in the context of _resolveFloatingField
                    var probField = this.resolveNode(som);
                    if (!_.isEmpty(probField)) {
                        if (probField.jsonModel.id === field.jsonModel.id) {
                            bQuit = true;
                            resolvedField = probField;
                        }
                        else {
                            //keep looking
                        }
                    }
                    else { //this will not be used very often in fact I kept it just for completeness...
                        bQuit = true;
                        var nodeName = this;
                        //vdua suggests to use xfa.form..nodeName instead of _filterNodes.
                        //it takes care of index affinity also which is a bit unpredictable
                        //Let's try this in next iteration
                        var contextNodes = this._xfa().form._filterNodes(function (n) {
                            return n.name == nodeName;
                        });

                        var occurrenceToLookFor = 0;

                        for (var i = 0; i < contextNodes.length; i++) {
                            if (contextNodes.item(i) == this) {
                                occurrenceToLookFor = i;
                                break;
                            }
                        }

                        var floatingFieldNodes = this._xfa().form._filterNodes(function (n) {
                            return n.name == field.name;
                        });

                        var occurrence = 0;
                        var foundAtLeastOneMatch = false;
                        var indexOfFirstFound = 0;

                        for (var j = 0; j < floatingFieldNodes.length; j++) {
                            var probField = floatingFieldNodes.item(j);
                            if (probField.jsonModel.id == field.jsonModel.id) {
                                if (!foundAtLeastOneMatch)
                                    indexOfFirstFound = j;
                                foundAtLeastOneMatch = true;
                                if (occurrenceToLookFor == occurrence)
                                    return probField;
                                occurrence++;
                            }
                        }

                        if (foundAtLeastOneMatch)
                            return floatingFieldNodes.item(indexOfFirstFound);
                    }
                    index++;
                }
                return resolvedField;
            }
            else
                return null;
        },

        _computeJsonDiff: function (diff_level) {
            return xfalib.ut.XfaUtil.prototype.stripOrCall.call(this, diff_level === 2, xfalib.script.Node.prototype._computeJsonDiff, arguments);
        },

        playJson : function(pJsonModel) {
            //Do not do any playJson for draw children. It should not impact floating fields.
            xfalib.script.Node.prototype.playJson.apply(this, arguments);
        },

        _playDataXML: function () {

        },

        generateDataXML: function (rootNode, contextNode) {

        },

        _resolveFloatingField: function () {
            //Can we somehow store embeds and html text in Draw object and compute it over and over again
            //may we need another NodeValue type to handle it????

            if (this.value) {
                var content = this.value.oneOfChild;
                if (content.getAttribute('contentType') === 'text/html') {
                    if(_.isNull(content._origTmpltVal)){
                        content._origTmpltVal = content.jsonValue; // save original template info containing the embed tags
                    }
                    var isTextEmbeds = false,
                        that = this,
                        htmlText = content._origTmpltVal,
                        $internalHTML = $('<span>' + htmlText + '</span>');
                    //change the top level element to span to wrap up all the <p>, because it will cause unnecessary paragraph break

                    //no null check because jQuery is cool!
                    $internalHTML.find("p").eq(0).css('display', 'inline');

                    $internalHTML.find('[xfa\\:embed]').each(function (index, span) {
                        isTextEmbeds = true;
                        var $span = $(span);
                        var embed = $span.attr('xfa:embed');
                        var embedType = $span.attr('xfa:embedType');
                        var embedMode = $span.attr('xfa:embedMode');
                        if (embed && embed.length > 1 && embed[0] == '#') {
                            embed = embed.substr(1);
                            //resolve Node will take care of index affinity here
                            var field = (embedType == 'uri') ? that._getFieldById(embed) : that.resolveNode(embed);
                            if (field) {
                                if (embedMode === 'raw') {
                                    if (field.rawValue == null)
                                        $span.replaceWith(field.rawValue);
                                    else
                                        $span.replaceWith($.parseHTML(xfalib.ut.XfaUtil.prototype.encodeScriptableTags(field.rawValue.toString())));
                                }
                                else
                                    $span.replaceWith(xfalib.ut.XfaUtil.prototype.encodeScriptableTags(field.formattedValue.toString()));
                            }
                            else {
                                that._xfa().Logger.debug("xfa", "referred field with id " + embed + " doesn't exist.");
                                $span.remove();
                            }
                        }
                        else {
                            that._xfa().Logger.debug("xfa", "referred field with invalid id " + embed + " doesn't exist.");
                            $span.remove();
                        }
                    });

                    //isTextEmbeds is set to true if there is any embedded text field.
                    if (isTextEmbeds) {
                        content.jsonValue = "<span>" + $internalHTML.html() + "</span>";
                        // pages may not yet be rendered, but initialize called due to "initial count" of rpt. SF
                        // record updated value to be applied in _syncFormNodeToHtml during pg. render
                    }
                }
            }
        },

        scopeless: function () { //[LC-8801] DOM Properties of draw gets incorrectly attached
            return false;
        },

        _eventHandler: function (eventName) {
            //want to handle only calculate event that too in case of draw text
            if (this.ui && this.ui.oneOfChild && this.ui.oneOfChild.className == 'textEdit') {
                var rValue = undefined;
                switch (eventName) {
                    case "calculate":
                        if (this.moEvents["calculate"] && this.moEvents["calculate"].length > 0) {
                            this.moEvents["calculate"][0].execute(this, "calculate");
                        }
                        break;
                    default :
                        return Draw._super._eventHandler.call(this);
                }
                return rValue;
            }
            else
                return Draw._super._eventHandler.call(this);

        },

        /**
         * Return the DataSOMMap after adding an entry in the map for the node. The entry contains the value of the node
         * along with its Data SOM. If there is no Data SOM then return the unmodified map
         * @param map
         * @private
         */
        _getDataSomMap: function (map) {
            return map;
        },

        /**
         * Update the value of the node with the value provided in the input map. The map contains the values of the fields
         * mapped with their DataSOM. The function is empty for all the nodes, except for Field, Subform and Area.
         * @param map
         * @private
         */
        _restoreDataSomMap : function (map) {

        }
    });

    Draw.defineProps({
        "rawValue": {
            get: function () {
                return this._getValue();
            },
            set: function (sValue) {
                var oldval = this._getValue();
                sValue = this.validateInput(sValue, "string");
                this._setValue(sValue);
                var event = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED, this, 'rawValue', null, sValue);
                this.trigger(event.name, event);
            }
        },

        ui: {
            get: function () {
                return this.getElement("ui", 0);
            },

            set: function (value) {
                this.setElement(value, "ui");
            }
        },

        "font": {
            get: function () {
                return  this.getElement("font", 0);
            },
            set: function (value) {
                this.setElement(value, "font");
            }
        },

        "value": {
            get: function () {
                return  this.getElement("value", 0);
            },
            set: function (val) {
                this.setElement(val, "value");
            }
        },

        "desc": {
            get: function () {
                return this.getElement("desc", 0)
            }
        }
    });

    Draw.addMixins([
        xfalib.script.mixin.AddAssist,
        xfalib.script.mixin.AddCaption,
        xfalib.script.mixin.AddXYWH,
        xfalib.script.mixin.AddPresence,
        xfalib.script.mixin.AddBorder,
        xfalib.script.mixin.AddPara,
        xfalib.script.mixin.AddMargin
    ]);

})(_, xfalib, $);





/**
 * @package xfalib.script.DateTimeField
 * @import xfalib.script.Field
 * @fileOverview The file creates the Date Time Field Class required for XFA library
 * @version 0.0.1
 */

(function(_, xfalib){
    /**
     * Creates a new Date Time Field class
     *
     * @constructor
     * @param {string}
        *            name the name of the Field
     * @param {string}
        *            rawVal initial value of the Field
     * @property {string} rawVal represents the data value in the node
     * @extends com.adobe.xfa.scripting.Node
     */
    var DateTimeField = xfalib.script.DateTimeField = xfalib.script.Field.extend({
        _getDefaultPictureClause: function() {
            //watson bug#3672364 and 3672367.
            //Start reading calendar picture format from the localeset.
            if(this.value.oneOfChild.className === "date")
                return "date{"+this._xfa()._getLocaleSymbols(this.locale,"datePatterns").med+"}";
            else
                return "";
        },

        _setValue: function (sVal, skipTypeCheck) {
            return DateTimeField._super._setValue.call(this, sVal, skipTypeCheck);
        },

        _showDisplayFormat: function () {
            var formattedValue = this.formattedValue,
                rawValue = this.rawValue;
            // if formattedValue is null then show rawValue in widget along with error message
            if (!formattedValue) {
                formattedValue = rawValue;
            }
            var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED, this,
                'rawValue', rawValue, formattedValue);
            this.trigger(evnt.name, evnt);
        }
    });
})(_, xfalib);
/**
 * @package xfalib.script.NumericField
 * @import xfalib.script.Field
 * @fileOverview The file creates the Numeric Field Class required for XFA library
 * @version 0.0.1
 */

(function(_, xfalib){
    /**
     * Creates a new Numeric Field class
     *
     * @constructor
     * @param {string}
        *            name the name of the Field
     * @param {string}
        *            rawVal initial value of the Field
     * @property {string} rawVal represents the data value in the node
     * @extends com.adobe.xfa.scripting.Node
     */
    var NumericField = xfalib.script.NumericField = xfalib.script.Field.extend({
         _getDefaultPictureClause: function() {
            return "num{"+this._xfa()._getLocaleSymbols(this.locale,"numberPatterns").numeric+"}";
         }
    });
})(_, xfalib);
/**
 * @package xfalib.script.ButtonField
 * @import xfalib.script.Field
 * @fileOverview The file creates the Button Field Class required for XFA
 *               library
 * @version 0.0.1
 */

(function (_, xfalib) {
    var ButtonField = xfalib.script.ButtonField = xfalib.script.Field.extend({
        _computeJsonDiff: function (diff_level) {
            //we don't want button to appear in final submit, but for restoreFormState
            return xfalib.ut.XfaUtil.prototype.stripOrCall.call(this, diff_level === 2, ButtonField._super._computeJsonDiff, arguments);
        }
    });
})(_, xfalib);

/**
 * @package xfalib.script.CheckButtonField
 * @import xfalib.script.Field
 */
/**
 * @fileOverview The file creates the CheckButton Field Class required for XFA
 *               library
 * @version 0.0.1
 */

(function(_, xfalib){
    /**
     * Creates a new CheckButtonField Field class
     *
     * @constructor
     * @param {string}
        *            name the name of the Field
     * @param {string}
        *            rawVal initial value of the Field
     * @property {string} rawVal represents the data value in the node
     * @extends com.adobe.xfa.scripting.Node
     */
    var CheckButtonField = xfalib.script.CheckButtonField = xfalib.script.Field.extend({
        initialize : function(){
            CheckButtonField._super.initialize.call(this);
            this._on = 0;
            this._off = 1;
            this._neutral = 2;
        },

        addItem : function(sDisplayVal, sSaveVal) {
            if (this.length == this._getMaxItems())
                return;
            CheckButtonField._super.addItem.call(this, sDisplayVal, sSaveVal);
        },

        _getMaxItems : function(){
            return this._allowNeutral() ? 3 : 2;
        },

        _allowNeutral : function(){
            return this.ui.oneOfChild.allowNeutral == 1 ? true : false;
        },

        _handleDependants : function() {
            CheckButtonField._super._handleDependants.call(this);
            if (this.parent._isExclusionGroup()) {
                this.parent._handleSelectChild(this);
            }
        }

    });
})(_, xfalib);
/**
 * @package xfalib.script.ChoiceListField
 * @import xfalib.script.Field
 */
/**
 * @fileOverview The file creates the ChoiceList Field Class required for XFA
 *               library
 * @version 0.0.1
 */


(function(_, xfalib, $){
    /**
     * Creates a new ChoiceList Field class
     *
     * @constructor
     * @param {string}
        *            name the name of the Field
     * @param {string}
        *            rawVal initial value of the Field
     * @property {string} rawVal represents the data value in the node
     * @extends com.adobe.xfa.scripting.Node
     */
    var ChoiceListField = xfalib.script.ChoiceListField = xfalib.script.Field.extend({

        initialize : function () {
            ChoiceListField._super.initialize.call(this);
            // to handle the scenario where bindRef items were not getting populated on adding new instance
            if (this.getElement("#bindItems") && xfalib.runtime.renderContext.data) {
                var prefillXmlDoc = xfalib.ut.XMLUtils.getXFARootFormElementFromXML($.parseXML(xfalib.runtime.renderContext.data));
                this._playItems(prefillXmlDoc, null);
            }
        },

        _convertValueToXml: function(val) {
           if(val == null || val.length == 0)
                return null
           var xml = "<"+this.name+">"
           _.each((val+"").split("\n"),function(value) {
               if(value && value.length > 0)
                    xml +="<value>"+value+"</value>"
            })
            xml += "</"+this.name+">"
            return xml
        },

        _getText: function(xml,sep,$) {
            var recText = function(obj,arr) {
                if(obj.children().length) {
                    obj.children().map(function(indx,child) {
                        recText($(child),arr);
                    })
                } else {
                    arr.push(obj.text());
                }
            };
            var arr = [];
            recText($($.parseXML(xml)),arr);
            return arr.join(sep);
        },

        _convertXmlToValue: function($xml) {
            if($xml == null)
                return null;
            return this._getText($xml,"\n",$);
        },

        _getValue : function() {
            var value = ChoiceListField._super._getValue.apply(this, this._multiSelect() ? ["text/xml"] : []);
            if(this._multiSelect())
                return this._convertXmlToValue(value);
            else
                return value
        },

        _setValue : function(sVal) {
            if(this._multiSelect())
                sVal = this._convertValueToXml(sVal);
            return ChoiceListField._super._setValue.apply(this,[sVal]);
        },

        getItemState : function(nIndex) {
            if (this._multiSelect() !== false) {
                var saveValue = this.getSaveItem(nIndex);
                if(saveValue!== null && saveValue!== undefined){
                    saveValue = ""+saveValue;
                    var valueArray = (this.rawValue + "").split("\n");
                    var currentValIndex = this.xfaUtil().dIndexOf(valueArray,saveValue);
                    return currentValIndex >= 0;
                } else
                    return null; // TODO: return null or false
            } else {
                return ChoiceListField._super.getItemState.call(this, nIndex);
            }

        },

        // returns array of indices corresponding to selected value
        _selectedLastIndices : function() {
            var itemSize = this.length,
                lastSelectedIndices = [];

            for (var i=0; i< itemSize; i++) {
                if (this.getItemState(i)) {
                    lastSelectedIndices.push(i);
                }
            }
            return lastSelectedIndices;
        },

        // returns display value corresponding to selected value
        _formatValue: function () {
            var lastSelectedIndices = this._selectedLastIndices();
            return lastSelectedIndices.map( function (selIndex) {
                return this.getDisplayItem(selIndex);
            }, this).join("\n");
        },

        _multiSelect : function(){
            return this.ui.oneOfChild.open == "multiSelect" ? true : false;
        },



        setItemState : function(nIndex, bVal) {
            if (this._multiSelect() !== false) {
                var saveValue = this.getSaveItem(nIndex);
                if(saveValue !== null && saveValue !== undefined) {
                    saveValue = ""+saveValue;
                    var valueArray = (this.rawValue + "").split("\n");
                    var currentValIndex = this.xfaUtil().dIndexOf(valueArray,saveValue); /*item value is typed so converting it to string for matching */
                    if(bVal && currentValIndex < 0) {
                        var saveItems = this._getSaveItems().children
                        var newValArray = _.reduce(saveItems,function(memo,item) {
                                if(this.xfaUtil().dIndexOf(valueArray,item.value) >= 0 || item.value == saveValue)
                                    memo.push(item.value);
                                return memo
                        },[],this)
                        valueArray = newValArray;
                    }
                    else if(!bVal && currentValIndex >=0)
                        valueArray.splice(currentValIndex, 1)
                    this.rawValue = valueArray.join("\n");
                }
            } else {
                ChoiceListField._super.setItemState.call(this, nIndex, bVal);
            }
        },

        _playDataXML: function (xmlDocument, contextNode, currentBindRef) {
            var xpath = this._getXpathFromBindRef(),
                value, nodeIter, node;
            if(xpath != null) {
                if(this._multiSelect()) {
                    // in case of multiselect the value is xml and hence needs special processing
                    nodeIter = this._getElementsFromXpath(xpath, contextNode, xmlDocument);
                    var node = nodeIter.iterateNext();
                    if(node != null) {
                        value = new XMLSerializer().serializeToString(node);
                        ChoiceListField._super._setValue.apply(this,[value]);
                        //todo: If we move processing of data xml before view
                        //generation then showDisplayFormat call will not be needed.
                        this._showDisplayFormat();
                    }
                } else {
                    ChoiceListField._super._playDataXML.apply(this, [xmlDocument, contextNode, currentBindRef]);
                }
            }
            this._playItems(xmlDocument, contextNode);
        },

        _playItems: function (xmlDocument, contextNode) {
            var bindItems = this.getElement("#bindItems[0]");
            if (bindItems != null) {
                var connection = bindItems.connection;
                if (connection == null || connection.length == 0) {
                    var ref = bindItems.ref;
                    if (ref != null && ref.length > 0) {
                        var xpath = this._convertRefToXPath(ref);
                        if (xpath != null) {
                            var itemNodes = this._getElementsFromXpath(xpath, contextNode, xmlDocument);
                            if (itemNodes != null) {
                                this.clearItems();
                                var itemNode = itemNodes.iterateNext();
                                var xmlUtils = xfalib.ut.XMLUtils;
                                while (itemNode != null) {
                                    //TODO: support valueRef/labelRef with xPath having more than one element
                                    // and valueRef/labelRef pointing to an attribute
                                    var valueNodeResult = xmlUtils.evaluateXPath(bindItems.valueRef, itemNode, null,
                                        XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
                                    if (valueNodeResult != null) {
                                        var labelNodeResult = valueNodeResult;
                                        if (bindItems.labelRef) {
                                            labelNodeResult = xmlUtils.evaluateXPath(bindItems.labelRef, itemNode, null,
                                                XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
                                        }
                                        var valueNode = valueNodeResult.iterateNext();
                                        if(valueNode != null) {
                                            var labelNode = labelNodeResult ? labelNodeResult.iterateNext() : null;
                                            if(labelNode == null) {
                                                labelNode = valueNode;
                                                this._xfa().Logger.warn("xfa",
                                                        "labelRef doesn't exist for [" + this.somExpression + ","
                                                        + bindItems.ref + "," + bindItems.labelRef + "]");
                                            }
                                            this.addItem(labelNode.textContent,
                                                valueNode.textContent);
                                        } else {
                                            this._xfa().Logger.error("xfa",
                                                    "valueRef doesn't exist for [" + this.somExpression + ","
                                                        + bindItems.ref + "," + bindItems.labelRef + "]");
                                        }
                                    } else {
                                        this._xfa().Logger.error("xfa", "valueRef points to an invalid xml element "
                                            + bindItems.valueRef);
                                    }

                                    itemNode = itemNodes.iterateNext();
                                }
                            }
                        }
                    }
                } else {
                    this._xfa().Logger.warn("xfa", "connection in bindItems is not supported in Formset");
                }
            }
        },

        _appendValueInXMLElement: function (element) {
            if(!this._multiSelect()) {
                ChoiceListField._super._appendValueInXMLElement.apply(this,[element]);
            } else {
                // need to remove the old choices before appending the new ones
                while (element.firstChild) {
                    element.removeChild(element.firstChild);
                }
                var xmlValue = this.value.oneOfChild.getValue("text/xml"),
                    xmlDoc, nodeIter, node, importedNode, addedChild;
                if(xmlValue != null && xmlValue != "") {
                    xmlDoc = $.parseXML(xmlValue);
                    nodeIter = xfalib.ut.XMLUtils.evaluateXPath("*", xmlDoc.documentElement, null,
                                                                    XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
                    node = nodeIter.iterateNext();
                    while(node != null) {
                        importedNode = element.ownerDocument.importNode(node, false);
                        addedChild = element.appendChild(importedNode);
                        addedChild.textContent = node.textContent;
                        node = nodeIter.iterateNext();
                    }
                }
            }
        }
    });
})(_, xfalib, $);
/**
 * @package xfalib.script.Subform
 * @import xfalib.script.ContainerNode
 * @fileOverview The file creates the Subform Class required for XFA library
 * @class The class represents a subform in the XFA Dom
 * @version 0.0.1
 */
(function(_,xfalib){
    var Subform = xfalib.script.Subform = xfalib.script.EventContainerNode.extend({
        initialize: function() {
            Subform._super.initialize.call(this);
            this._instanceManager = null;
            this.mnInstanceIndex = 0;
            this.tests= [this._scriptTest];
        },

        _isSubform : function() {
            return true;
        },

        getInvalidObjects : function() {
            var list = new xfalib.script.XfaList();
            var sMessages = new Array();
            this._validate(sMessages);
            for ( var i = 0; i < sMessages.length; i++) {
                list._append(sMessages[i].ref);
            }
            return list;
        },

        _eventHandler : function(eventName) {
            var rValue = undefined;
            switch (eventName) {
                case "validate":
                    if(this.moEvents["validate"] && this.moEvents["validate"].length >0){
                        rValue = this.moEvents["validate"][0].execute(this, "validate");
                    }else
                        rValue = true;
                    break;
                case "$formpreSubmit":
                    rValue = this._preSubmitEventHandler();
                default:
                if (this.moEvents[eventName]) {
                    for ( var i = 0; i < this.moEvents[eventName].length; i++) {
                        this.moEvents[eventName][i].execute(this, eventName);
                    }
                }
            }
            return rValue;
        },

        _nullTest : function(value,sMessages) {
            return true;
        },

        _requireGetterSetter : function(oChild){
            if(oChild.className == "pageSet")
                return true;
            else
                return Subform._super._requireGetterSetter.call(this, oChild);
        },

        _postAddChild : function(oNode){
            if(oNode.instanceManager){
                // clear all cached contexts in EventContainerNode-s
                xfalib.runtime.xfa._clearAllMoContexts();

                this._xfa()._xfaTemplateCache.putModel(oNode, oNode.instanceManager._instanceTemplate());
                if(this.mEffectiveAccess){
                    oNode._calculateEffectiveAccess();
                }
                if(this.mEffectivePresence){
                    oNode._calculateEffectivePresence();
                }
                oNode._initialize();
                if (this.mbInitialized) {
                    // oNode.execEvent("initialize");
                    oNode.execCalculate();
                }

                // internalDispatchEvent(CollectionEventKind.ADD, oNode, index);

                // if (this.hasEventListener("change"))
                var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.CHILD_ADDED,this,"child",null,oNode);
                this.trigger(evnt.name,evnt);
            }
            else {
                //do nothing --- Let's face it You might call this function for other things besides subform e.x. items (see _getDisplayItems())
                Subform._super._postAddChild.call(this, oNode);
            }
        },

        _postRemoveChild : function(oChild){
            if(oChild.instanceManager){
                // clear all cached contexts in EventContainerNode-s
                xfalib.runtime.xfa._clearAllMoContexts();

                var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.CHILD_REMOVED,this,"child", oChild, null);
                this.trigger(evnt.name,evnt);
            }
            else {
                Subform._super._postRemoveChild.call(this, oChild);
            }
        },

        playJsonForElement : function(elName, pJsonModel){
            if(elName == "instanceManager"){
                var newJChildren = _.filter(_.compact(pJsonModel.children), function (jChild) {
                    return this.xfaUtil().isRepeatabeEl(jChild._class) || jChild._class == "instanceManager";
                }, this);
                var oldMChildren = _.filter(this.moChildNodes, function(mChild){
                    return  this.xfaUtil().isRepeatabeEl(mChild.className)  || mChild.className == "instanceManager" ;
                }, this);

                var lastIM = null;
                _.each(oldMChildren, function(oldMChild){
                    //If oldMChild has any remaining IM then newJChildren must have at least one IM left
                    if(oldMChild.className == "instanceManager" && newJChildren[0]._class == "instanceManager"){
                        newJChildren.shift();
                    }
                    else if(oldMChild.className == "instanceManager" && this.xfaUtil().isRepeatabeEl(newJChildren[0]._class)){
                        while(this.xfaUtil().isRepeatabeEl(newJChildren[0]._class)){
                            var addedSf =lastIM.addInstance();
                            addedSf.playJson(newJChildren.shift());
                        }
                        newJChildren.shift(); // This must be instanceManager for next subform
                    }
                    else if(this.xfaUtil().isRepeatabeEl(oldMChild.className ) && (newJChildren[0] == null || newJChildren[0]._class == "instanceManager")){
                        lastIM.removeInstance(oldMChild.instanceIndex);
                    }
                    else {
                        //oldMChild.className == "subform" && newJChildren[0]._class == "subform"
                        oldMChild.playJson(newJChildren.shift());
                    }

                    if(oldMChild.className == "instanceManager" )
                        lastIM = oldMChild;

                }, this);
                while(newJChildren.length > 0){
                    var newJSF = newJChildren.shift();
                    var addedSF = lastIM.addInstance();
                    if (addedSF) {
                        addedSF.playJson(newJSF);
                    }
                }
                return true;
            } else if (this.xfaUtil().isRepeatabeEl(elName)) {
                return true;
            } else if (elName === "variables") {
                return true;  // LC-9508: don't playJson for variables
            } else {
                return Subform._super.playJsonForElement.call(this, elName, pJsonModel);
            }
        },

        _getXPathForUseNameBinding: function () {
            if(this.instanceManager._isRepeatable()) {
                var name = this.getAttribute("name");
                return name === "" ? null
                                   : {
                                        relative: true,
                                        bindRef: name + "[*]"
                                     };
            } else {
                return Subform._super._getXPathForUseNameBinding.apply(this);
            }
        },

        _playDataXML: function(xmlDocument, contextNode, currentBindRef) {
            if(this.parent.className === "form") {
                return Subform._super._playDataXML.apply(this,[xmlDocument,contextNode, currentBindRef]);
            }
            var xpath = this._getXpathFromBindRef(),
                relativeXPath, nodeIter, nodeList = [], node, count, instance;
            if(xpath == null) {
               Subform._super._playDataXML.apply(this,[xmlDocument,contextNode, currentBindRef]);
            } else {
                // The first instance will take care of the rest of the instances.
                if(this.instanceIndex === 0) {
                    nodeIter = this._getElementsFromXpath(xpath, contextNode, xmlDocument);
                    if (nodeIter != null) {
                        node = nodeIter.iterateNext();
                        while (node) {
                            nodeList.push(node);
                            node = nodeIter.iterateNext();
                        }
                        node = nodeList.shift();
                        count = 0;
                        while (node != null) {
                            if (count > this.instanceManager.count - 1) {
                                instance = this.instanceManager.addInstance();
                            } else {
                                instance = this.instanceManager.instances[count];
                            }
                            Subform._super._playDataXML.apply(instance, [xmlDocument, node, xpath]);
                            node = nodeList.shift();
                            count++;
                        }
                        while (count < this.instanceManager.count) {
                            if (this.instanceManager.count === this.instanceManager.min) {
                                instance = this.instanceManager.instances[count];
                                Subform._super._playDataXML.apply(instance, [xmlDocument, null, xpath]);
                                count++;
                            } else {
                                this.instanceManager.removeInstance(count);
                            }
                        }
                    }
                }
            }
        },

        /**
         * Generates the XML by appending the elements in the rootNode
         * @param rootNode The rootNode of the xml. Generally the element that maps to the root of the form
         * @param contextNode Current Node where to insert the elements in case of relative bindings
         */
        generateDataXML: function(rootNode, contextNode) {
            if(this.parent.className === "form") {
                return Subform._super.generateDataXML.apply(this,[rootNode,contextNode]);
            }
            var xpath = this._getXpathFromBindRef(),
                xmlUtils = xfalib.ut.XMLUtils,
                parentElement, element, childElement, childXPath, childXPathParts,
                childElementName, childElementIndex;
            if(xpath == null) {
                Subform._super.generateDataXML.apply(this,[rootNode,contextNode]);
            } else {
                element = xpath.relative === false ? rootNode : contextNode;
                parentElement = xmlUtils.createElementsFromXPath(xpath.bindRef, element, true);
                childXPath = _.last(xpath.bindRef.split("/"));
                childXPathParts = xmlUtils._getElementNameAndIndexFromXPathPart(childXPath);
                childElementName = childXPathParts.name;
                childElementIndex = childXPathParts.index;
                //TODO: * doesn't gaurantees that the element can be repeated in schema. But we have no choice for now
                if(childElementIndex === "*") {
                    if(this.instanceIndex === 0) {
                        // For repeatable subforms the first child does the processing for all the siblings

                        // cache all existing children
                        var existingInstances = parentElement.hasChildNodes() ? parentElement.childNodes : null;

                        // filter out current repeatable ones
                        if (!_.isEmpty(existingInstances)) {
                            existingInstances = _.filter(existingInstances, function (child) { return child.nodeName === childElementName; });
                        }

                        _.each(this.instanceManager.instances, function (instance) {
                            var index = instance.instanceIndex + 1,
                                childElement = xmlUtils.findOrCreateElement(childElementName + "[" + index + "]",
                                    parentElement);
                            Subform._super.generateDataXML.apply(instance,[rootNode, childElement]);
                        }, this);

                        if(!_.isEmpty(existingInstances)) {
                            // remove the left over ones, caused if one deletes an instance.
                            // since we are regenerating xml, no need to worry about order, remaining SFs will update their data from the xml's top elems
                            for(var i = this.instanceManager.count; i < existingInstances.length; ++i) {
                                parentElement.removeChild(existingInstances[i]);
                            }
                        }
                        // But this will have a side effect in case of any other repeatable subform mapping to the same xpath LC-3911518
                    }
                } else {
                    childElement = xmlUtils.findOrCreateElement(childElementName +"[" + childElementIndex + "]",
                        parentElement);
                    Subform._super.generateDataXML.apply(this,[rootNode, childElement]);
                }
            }
        },

        _getDataSomMap : function (dataSomMap) {
            if(!this.instanceManager || !this.instanceManager._isRepeatable()) {
                return Subform._super._getDataSomMap.apply(this,arguments)
            }
            return dataSomMap;
        },

        _restoreDataSomMap: function(map) {
            if(!this.instanceManager || !this.instanceManager._isRepeatable()) {
                Subform._super._restoreDataSomMap.apply(this,arguments)
            }
        },

        _preSubmitEventHandler: xfalib.script.Field.prototype._preSubmitEventHandler
    });

    Subform.defineProps({
        "locale": {
            get: function() {
                var obj = this;
                var locale;
                while(!locale && obj) {
                    locale = obj.jsonModel.locale;
                    obj = obj.parent;
                }
                locale = locale || "en-US"; //TODO: read from jsp
                return locale;
            }
        },

        "instanceIndex":
        {
            get : function() {
                return this.mnInstanceIndex;
            }
        },

        "instanceManager": {
            get: function() {
                return this._instanceManager;
            },
            resolve:true
        },

        "occur": {
            get: function() {
                return this.instanceManager.occur;
            },
            resolve:true
        },

        "pageSet": {
            get: function(){
                return this.getElement("pageSet", 0, true);
            }
        },

        "variables": {
            get : function() {
                return  this.getElement("variables",0);
            } ,
            set :function(value) {
                this.setElement(value,"variables");
            }
        }
    });

    Subform.addMixins([
        xfalib.script.mixin.AddAssist,
        xfalib.script.mixin.AddPresence,
        xfalib.script.mixin.AddXYWH,
        xfalib.script.mixin.AddFillColor,
        xfalib.script.mixin.AddBorder,
        xfalib.script.mixin.AddBorderColor,
        xfalib.script.mixin.AddBorderWidth,
        xfalib.script.mixin.AddPara,
        xfalib.script.mixin.AddMargin
    ]);

})(_,xfalib);
/**
 * @package xfalib.script.ContentArea
 * @import xfalib.script.ContainerNode
 * @fileOverview The file creates the ContentArea Class required for XFA library
 * @version 0.0.1
 */

(function (_, xfalib) {
    /**
     * Creates a new ContentArea class
     *
     * @class The class represents a subform in the XFA Dom
     * @param {string}
     *            name the name of the node
     * @extends com.adobe.xfa.scripting.ContainerNode
     */
    var ContentArea = xfalib.script.ContentArea = xfalib.script.ContainerNode.extend({
        _computeJsonDiff: function (diff_level) {
            return xfalib.ut.XfaUtil.prototype.partialStripOrCall.call(this, diff_level, ContentArea._super._computeJsonDiff);
        }
    });

    ContentArea.addMixins([
        xfalib.script.mixin.AddXYWH
    ]);

})(_, xfalib);

/**
 * @package xfalib.script.PageArea
 * @import xfalib.script.ContainerNode
 * @fileOverview The file creates the PageArea Class required for XFA library
 * @version 0.0.1
 */

(function(_, xfalib){
    /**
     * Creates a new PageArea class
     *
     * @class The class represents a subform in the XFA Dom
     * @param {string}
        *            name the name of the node
     * @extends com.adobe.xfa.scripting.ContainerNode
     */
    var PageArea = xfalib.script.PageArea = xfalib.script.EventContainerNode.extend({
        execEvent : function(eventName) {
            return undefined;
        },

        playJsonForElement: xfalib.script.Subform.prototype.playJsonForElement,

        _computeJsonDiff: function (diff_level) {
            return xfalib.ut.XfaUtil.prototype.partialStripOrCall.call(this, diff_level, PageArea._super._computeJsonDiff);
        }
    });

    PageArea.defineProps({
        "access" : {
            get : function() {  //i am not sure how to make this property undefined so just removed setters
                return this.getOrElse(this.jsonModel.access, this._defaults.access);
            }
        },


        "presence" : {
            get : function() { //i am not sure how to make this property undefined so just removed setters
                return this.getOrElse(this.jsonModel.presence, this._defaults.presence);
            }
        }
    });
})(_, xfalib);




/**
 * @package xfalib.script.PageSet
 * @import xfalib.script.ContainerNode
 * @fileOverview The file creates the PageSet Class required for XFA library
 * @version 0.0.1
 */

(function(_, xfalib){
    /**
     * Creates a new PageSet class
     *
     * @class The class represents a subform in the XFA Dom
     * @param {string}
        *            name the name of the node
     * @extends com.adobe.xfa.scripting.ContainerNode
     */
    var PageSet = xfalib.script.PageSet = xfalib.script.EventContainerNode.extend({
        execEvent : function(eventName) {
            return undefined;
        },

        _computeJsonDiff: function (diff_level) {
            return xfalib.ut.XfaUtil.prototype.partialStripOrCall.call(this, diff_level, PageSet._super._computeJsonDiff);
        },

        playJsonForElement: function (elName, pJsonModel) {
            if(elName === "pageArea") { // LC-3642518 : allow data-merge on master page
                var newJChildren = _.filter(_.compact(pJsonModel.children), function (jChild) {
                    return jChild._class === "pageArea";
                }, this);
                var oldMChildren = _.filter(this.moChildNodes, function (mChild) {
                    return mChild.className === "pageArea";
                }, this);

                _.each(oldMChildren, function (oldMChild) {
                    var idPattern = new RegExp("^" + oldMChild.jsonModel.id + "(?:_ID)*$"); // look for an id value, followed by zero or more "_ID" suffixes
                    _.each(newJChildren, function (newJChild) {
                        if (oldMChild.name && oldMChild.name == newJChild.name && idPattern.test(newJChild.id)) { // match name as well as id, to account for mystery xtg master pg id gen logic
                            try {
                                oldMChild.playJson(newJChild); // may throw an exception, say for 0-instance fields on master pg. Say expected an inst.man but found null
                            } catch (exception) {
                                xfalib.runtime.xfa.Logger.error("xfa", "Exception during DataMerge on fields in master page. ",
                                                                [exception, oldMChild," PlayJSON on", newJChild]);
                            }
                        }
                    }, this);
                }, this);

                return true;
            } else {
                return PageSet._super.playJsonForElement.call(this, elName, pJsonModel);
            }
        }
    });

    PageSet.defineProps({
        "access" : {
            get : function() {  //i am not sure how to make this property undefined so just removed setters
                return this.getOrElse(this.jsonModel.access, this._defaults.access);
            }
        },

        "presence" : {
            get : function() { //i am not sure how to make this property undefined so just removed setters
                return this.getOrElse(this.jsonModel.presence, this._defaults.presence);
            }
        }

    });
})(_, xfalib);
/**
 * @fileOverview The file creates the SubformSet Class required for XFA library
 * @class The class represents a SubformSet in the XFA Dom
 * @version 0.0.1
 */
(function(_,xfalib){
    var SubformSet = xfalib.script.SubformSet = xfalib.script.Subform.extend({
        initialize: function() {
            SubformSet._super.initialize.call(this);
            this.tests = null;
        },

        execEvent : function(eventName) {
            return undefined;
        }

    });

    SubformSet.defineProps({
        "access": {
            get: function () {  //i am not sure how to make this property undefined so just removed setters for now
                return this.getOrElse(this.jsonModel.access, this._defaults.access);
            }

            //TODO : Add setter to delegate to children

        },

        "presence": {
            get: function () { //i am not sure how to make this property undefined so just removed setters for now
                return this.getOrElse(this.jsonModel.presence, this._defaults.presence);
            }

            //TODO : Add setter to delegate to children
        }

    });
})(_,xfalib);/**
 * @fileOverview The file creates the Area Class required for XFA library
 * @class The class represents a Area in the XFA Dom
 * @version 0.0.1
 */
(function(_,xfalib){
    var Area = xfalib.script.Area = xfalib.script.EventContainerNode.extend({
        execEvent : function(eventName) {
            return undefined;
        },

        playJsonForElement : xfalib.script.Subform.prototype.playJsonForElement

    });

    Area.defineProps({
        "access" : {
            get : function() {  //i am not sure how to make this property undefined so just removed setters
                return this.getOrElse(this.jsonModel.access, this._defaults.access);
            }
        },

        "presence" : {
            get : function() { //i am not sure how to make this property undefined so just removed setters
                return this.getOrElse(this.jsonModel.presence, this._defaults.presence);
            }
        }

    });

    Area.addMixins([
        xfalib.script.mixin.AddXYWH
    ]);

})(_,xfalib);/**
 * @fileOverview The file creates the Variables Class required for XFA library
 * @class The class represents a Variables in the XFA Dom
 * @version 0.0.1
 */
(function (_, xfalib) {
    var Variables = xfalib.script.Variables = xfalib.script.ContainerNode.extend({
        _initChildren: function () {
            var children = new Array();
            if (this.jsonModel.children) {
                var j = 0;
                for (var i = 0; i < this.jsonModel.children.length; i++) {
                    var child = this.jsonModel.children[i];
                    var childModel = xfalib.script.XfaModelRegistry.prototype.createNodeValue(child);
                    if (childModel) {
                        children[j++] = childModel;
                    }
                }
                this.children = children;
            }
        },

        _computeJsonDiff: function (diff_level) {
            // don't need variables for submission, but need them for replay on restoreFormState
            return xfalib.ut.XfaUtil.prototype.stripOrCall.call(this, diff_level === 2, Variables._super._computeJsonDiff, arguments);
        },

        scopeless: function () {
            return ((this.name || "").length == 0);
        },

        /**
         * Return the DataSOMMap after adding an entry in the map for the node. The entry contains the value of the node
         * along with its Data SOM. If there is no Data SOM then return the unmodified map
         * @param map
         * @private
         */
        _getDataSomMap: function (map) {
            return map;
        },

        /**
         * Update the value of the node with the value provided in the input map. The map contains the values of the fields
         * mapped with their DataSOM. The function is empty for all the nodes, except for Field, Subform and Area.
         * @param map
         * @private
         */
        _restoreDataSomMap : function (map) {

        }

    });

    Variables.defineProps({
        "presence": {
            get: function () { //i am not sure how to make this property undefined so just removed setters
                return undefined;
            },
            set: function () {
            }
        }

    });
})(_, xfalib);
/**
 * @package xfalib.script.Occur
 * @import xfalib.ut.Class
 * @fileOverview The file creates the Occur Class required by InstanceManager
 *               for XFA library
 * @version 0.0.1
 */


(function(_, xfalib){
    /**
     * Creates a new Occur object
     *
     * @class The class represents the Occur Object
     * @constructor
     * @param {number}
        *            initial Initial occurrence of the subform managed by parent
     *            InstanceManager
     * @param {number}
        *            max Maximum occurrence of the subform managed by parent
     *            InstanceManager
     * @param {number}
        *            min Minimum occurrence of the subform managed by parent
     *            InstanceManager
     * @property {number} initial Initial occurrence of the subform managed by
     *           parent InstanceManager
     * @property {number} max Maximum occurrence of the subform managed by parent
     *           InstanceManager
     * @property {number} min Minimum occurrence of the subform managed by parent
     *           InstanceManager
     */
    var Occur = xfalib.script.Occur = xfalib.ut.Class.extend({
        _defaults : {
            "min" : "1",
            "max" : "1",
            "initial" : "1"
        },
        msClassName: "occur"

    });

    Occur.defineProps({
        initial:{
            get: function() {
                return parseInt(this.getOrElse(this.jsonModel.initial, this._defaults.initial));
            }
        },

        min: {
            get: function() {
                return parseInt(this.getOrElse(this.jsonModel.min, this._defaults.min));
            },
            set: function(nMin) {
            	this.jsonModel.min = nMin + "";
            }
        },

        max: {
            get: function() {
                return parseInt(this.getOrElse(this.jsonModel.max, this.min));
            },
            set: function(nMax) {
            	this.jsonModel.max = nMax + "";
            }
        },

        playJson : function(pJsonModel) {

        }

    })
})(_, xfalib);
/**
 * @package xfalib.script.InstanceManager
 * @import xfalib.script.Node
 * @import xfalib.script.Occur
 * @fileOverview The file creates the InstanceManager Class required for XFA
 *               library
 * @class The class represents a Instance Manager to manage multiple instance of
 *        subforms
 * @version 0.0.1
 */

(function (_, xfalib) {

    var InstanceManager = xfalib.script.InstanceManager = xfalib.script.Node.extend(
        {
            msClassName: "instanceManager",
            initialize: function () {
                InstanceManager._super.initialize.call(this);
                this._occur = new xfalib.script.Occur({"jsonModel": this.jsonModel});
                this.moChildrenCreated = [];
                this.mnCurrent = 0;
                this.mbStandalone = false;
            },

            _instanceTemplate: function () {
                var parent = this.parent;
                if (this._templateRef() == null || parent == null || parent._templateRef() == null || parent._templateRef().children == null)
                    return null;
                var tmpltParent = parent._templateRef();
                var imIndex = tmpltParent.children.indexOf(this._templateRef());
                if (imIndex < 0 || tmpltParent.children.length < imIndex + 2)
                    return null;
                else {
                    var dataSom = tmpltParent.children[imIndex + 1].extras.dataSom;
                    if (dataSom) {
                        tmpltParent.children[imIndex + 1].extras.dataSom = this._setCharAt(dataSom, dataSom.length - 3, imIndex + 1);
                    }
                    return tmpltParent.children[imIndex + 1];
                }
            },

            _isRepeatable: function () {
                var max;
                return ((max = +this.max) < 0 || +this.min < max);
            },

            _isInstanceManager: function () {
                return true;
            },

            /**
             * @private
             *
             * Manage a child instance that was created.
             *
             * @param oCreatedChild
             *        the child to be managed.
             */


            _manageChild: function (oCreatedChild, nIndex) {
                oCreatedChild._instanceManager = this;
                if (nIndex === undefined) {
                    this.moChildrenCreated.splice(this.mnCurrent, 0, oCreatedChild);
                    oCreatedChild.mnInstanceIndex = this.mnCurrent++;
                }
                else {
                    this.moChildrenCreated.splice(nIndex, 0, oCreatedChild);
                    oCreatedChild.mnInstanceIndex = nIndex;
                    this.mnCurrent++;
                    for (var i = nIndex + 1; i < this.moChildrenCreated.length; i++)
                        this.moChildrenCreated[i].mnInstanceIndex = i;
                }
            },

            _computeJsonDiff: function (diff_level) {
                //we don't need InstanceManager for final submission if there is only one instance, and it's not a repeatable SF
                // but need it for maintaining hierarchy in restoreFormState
                return xfalib.ut.XfaUtil.prototype.stripOrCall.call(this, diff_level === 2 && (!this._isRepeatable() && this.moChildrenCreated.length <= 1), InstanceManager._super._computeJsonDiff, arguments);
            },

            /*
             * add an instance of the repeatable subform.
             */
            addInstance: function () {
                return this._insertInstance();
            },
            _setCharAt : function (str,index,chr) {
                if (index > str.length - 1) {
                    return str;
                }
                return str.substring(0,index) + chr + str.substring(index+1);
            },

            _insertInstance: function (nIndex, oChildAdded) {
                if ((+this.max >= 0) && (+this.max == this.count)) //TODO : discuss whether to use private variables or not
                    return null;
                if (nIndex !== undefined && nIndex > +this.count)
                    return null;

                if (oChildAdded === undefined) {
                    var sfTemplate = this._instanceTemplate();
                    //
                    // needs to add an instance to the model
                    //
                    if (sfTemplate == null)
                        return null;
                    var clonedJson = {};
                    var uniquePrefix = this.xfaUtil().generateUID();
                    this.copyObject(sfTemplate, clonedJson,
                        {
                            exceptions: ["htmlId"],
                            transformMaps: {
                                "dataId": function (srcValue, options) {
                                    return uniquePrefix + "_" + srcValue;
                                }
                            }
                        }
                    );
                    oChildAdded = xfalib.script.XfaModelRegistry.prototype.createModel(clonedJson);
                }
                if (oChildAdded != null) {
                    //
                    // first add the child to the list of managed children
                    //
                    oChildAdded._newChild = true
                    this._manageChild(oChildAdded, nIndex);
                    //
                    //TODO: If not standalone mode, add the new item to the parent container as well. Understanding standalone mode
                    //
                    if (this.mbStandalone == true) {
                        if (nIndex !== undefined)
                            oChildAdded.index = nIndex;
                        else
                            oChildAdded.index = this.mnCurrent;
                        oChildAdded.parent = this.parent;
                    } else {
                        var oParentContainer = this.parent;
                        if (oParentContainer != null) {
                            if (this.mnCurrent > 1 && nIndex!==0) {
                                //
                                // If we already had children get the index of first
                                // child in the parent container
                                //
                                nIndex = nIndex !== undefined ? nIndex : this.mnCurrent - 1;
                                var nInsertionIndex = oParentContainer
                                    ._getChildIndex(this.moChildrenCreated[nIndex - 1]);
                                nInsertionIndex++;
                                oParentContainer._addChildAt(oChildAdded,
                                    nInsertionIndex);
                            } else {
                                //
                                // If this is the first child, add it just after the
                                // instance manager
                                //
                                oParentContainer._addChildAt(oChildAdded,
                                        oParentContainer._getChildIndex(this) + 1);
                            }

                        }
                    }
                    if (_.contains(['INITIALIZED', 'INITIALIZING'], this._xfa()._modelInitialize)) {
                        try {
                            oChildAdded.execInitialize();
                            // if the instance being added is the first one, we need to run execCalculate on the form to get dependents
                            // for the instance being added.
                            if (this.count == 1) {
                                this._xfa().form.execCalculate();
                            } else {
                                var firstInstance = this.instances[0];
                                this._triggerCalculateForDependantFields(firstInstance);
                            }
                        } catch (ex) {
                            this._xfa().Logger.error("xfa", xfalib.locale.LogMessages["ALC-FRM-901-013"], ["addInstance"]);
                        }
                    }
                    return oChildAdded;
                }
                return null;
            },

            insertInstance: function (nIndex) {
                return this._insertInstance(nIndex);
            },


            moveInstance: function (sIndex, dIndex) {
                if ((+this.max >= 0) && dIndex >= +this.count || sIndex >= +this.count || sIndex == dIndex) //TODO : discuss whether to use private variables or not
                    return null;
                var tIndex,
                    oParentContainer = this.parent,
                    oChild = this.moChildrenCreated[sIndex],
                    tsIndex = dIndex < sIndex ? sIndex + 1 : sIndex,
                    tdIndex = dIndex > sIndex ? dIndex + 1 : dIndex;
                this.max++;
                var newChild = this._insertInstance(tdIndex);
                this.max--;
                newChild.playJson(oChild.jsonModel);
                if (oParentContainer != null) {
                    var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.CHILD_MOVED, oParentContainer, "child", null, null);
                    oParentContainer.trigger(evnt.name, evnt);
                }
                this.removeInstance(tsIndex);
            },


            /*
             * add an instance of the repeatable subform.
             */
            removeInstance: function (index) {
                //
                // don't remove any more than the minimum
                //
                if (this.count == 0 || this.min == this.count)
                    return;

                if (index >= +this.count)
                    return;
                //
                // needs to remove an instance to the model
                //
                var firstInstance = this.instances[0];
                var oChild = this.moChildrenCreated[index];
                this.moChildrenCreated.splice(index, 1);
                this.mnCurrent--;
                for (var i = index; i < this.moChildrenCreated.length; i++)
                    this.moChildrenCreated[i].mnInstanceIndex = i;
                var parent = oChild.parent;
                parent._removeChild(oChild);

                if (_.contains(['INITIALIZED', 'INITIALIZING'], this._xfa()._modelInitialize)) {
                    try {
                        this._triggerCalculateForDependantFields(firstInstance);
                    } catch (ex) {
                        this._xfa().Logger.error("xfa", xfalib.locale.LogMessages["ALC-FRM-901-013"], ["removeInstance"]);
                    }
                }
            },

            /*
             * empty function since there is no data associated with IM
             */
            resetData: function () {

            },

            setInstances: function (num) {
                this.count = num;
            },
            /*
             *
             */
            getNaked: function (nIndex, createGetterSetter, Obj, scope) {
                if (this.getAttribute("name").length > 0 && this.getAttribute("name") != "_")
                    InstanceManager._super.getNaked.apply(this, arguments);
            },

            playJson: function (pJsonModel) {

            },
            /*
             * Trigger calculate event for only the dependent fields in the repeatable subform
             */
            _triggerCalculateForDependantFields : function (model) {
                var modelChildren = model.moChildNodes;
                _.each(modelChildren, function(modelChild){
                    // trigger calculate for the dependents of the field and exclusion group
                    if (modelChild._isField() || modelChild._isExclusionGroup()) {
                        var dependantNodes = modelChild.dependant;
                        _.each(dependantNodes, function(dependantNode){
                            dependantNode.execEvent("calculate");
                        });
                    } else if (modelChild._isEventNode()) {
                        this._triggerCalculateForDependantFields(modelChild);
                    }
                },this);
            }
        }
    );
    InstanceManager.defineProps({
        "min": {
            get: function () {
                return this.occur.min + "";
            },
            set: function (nMin) {
                this.occur.min = nMin;
            }
        },
        "max": {
            get: function () {
                return this.occur.max + "";
            },
            set: function (nMax) {
                this.occur.max = nMax;
            }
        },

        "occur": {
            get: function () {
                return this._occur;
            }
        },
        // This API is used in adaptive form
        "instances": {
            get: function() {
                return _.extend([], this.moChildrenCreated);
            }
        },

        "count": {
            get: function () {
                return this.moChildrenCreated.length + "";
            },
            set: function (value) {
                if (value == parseInt(value))
                    value = parseInt(value);
                else return;
                var count = +this.count,
                    tvalue = Math.abs(value - count),
                    max = +this.max,
                    min = +this.min;
                //Bug#3544368 value > max condition will only hold if max is positive (if max == -1
                // there is no limit on the upper count )
                if ((max > 0 && value > max) || value < min || value == count)
                    return;
                if (value > count) {
                    for (var i = 0; i < tvalue; i++)
                        this._insertInstance();
                }
                if (value < count) {
                    for (var i = 0; i < tvalue; i++)
                        this.removeInstance(--count);
                }
            }
        }
    })
})(_, xfalib);

/**
 * @package xfalib.script.ExclusionGroup
 * @import xfalib.script.ContainerNode
 * @fileOverview The file creates the ExclusionGroup Class required for XFA
 *               library
 * @version 0.0.1
 */

(function(_, xfalib){
    /**
     * Creates a new ExclusionGroup class
     *
     * @class The class represents a ExclusionGroup in the XFA Dom
     * @param {string}
        *            name the name of the node
     * @extends com.adobe.xfa.scripting.ContainerNode
     */
    var ExclusionGroup = xfalib.script.ExclusionGroup = xfalib.script.EventContainerNode.extend({

        initialize : function(){
            ExclusionGroup._super.initialize.call(this);
            this.tests= [this._nullTest,this._scriptTest];
            var dataId = this.getOrElse(this, "jsonModel.extras.dataId", null);
            if (dataId) {
                this._xfa().createDataNode(dataId, this);
            }
        },

        _getOnChild: function(otherChild) {
            return _.find(this.moChildNodes, function(child) {
                 return child.className == "field" && child.selectedIndex == 0 && child != otherChild
            })
        },

        _eventHandler : function(eventName) {
            var rValue = undefined;
            switch(eventName) {
                case "calculate":
                    if(this.moEvents["calculate"] && this.moEvents["calculate"].length >0){
                        rValue = this.moEvents["calculate"][0].execute(this, "calculate");
                    }
                    break;
                case "validate":
                    if(this.moEvents["validate"] && this.moEvents["validate"].length >0){
                        rValue = this.moEvents["validate"][0].execute(this, "validate");
                    }else
                        rValue = true;
                    break;
                case "$formpreSubmit":
                    rValue = this._preSubmitEventHandler();
                    break;
                default:
                    if (this.moEvents[eventName]) {
                        for ( var i = 0; i < this.moEvents[eventName].length; i++) {
                            this.moEvents[eventName][i].execute(this, eventName);
                        }
                    }
//                    ExclusionGroup._super._eventHandler.call(this, eventName);  //TODO: Why this is required?
            }
            return rValue
        },

        _handleSelectChild : function(child) {
            var oldVal = this.rawValue,
                evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED,
                                                                this,"ClearError",null, null),
                onChild = this._getOnChild(child);

            this.trigger(evnt.name,evnt);

            if (child.selectedIndex == 0) {
                if(onChild)
                    onChild.setItemState(0,false);
                this._handleDependants();
                // trigger model change event for rawValue, so that value can be propogated to rest of the fields with same dataId
                var evntRawValue = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED,
                                                                    this,"rawValue",this.rawValue, this.rawValue);
                this.trigger(evntRawValue.name,evntRawValue);
            } else if (child._matches(onChild)) {
                 this._handleDependants();
            }
        },

        selectedMember : function() {
            var currentNode = this._xfa().moCalculateEventNode;
            if (currentNode != null) {
                this.addDependant(currentNode);
            }
            return this._getOnChild();
        },

        _isExclusionGroup : function() {
            return true;
        },

        _getValue : function() {
            var onChild = this._getOnChild()
            return onChild ? onChild._getValue() : null;
        },

        _nullTest : function(sMessages) {
            var valid = true;
            var value = this._getValue();
            if (value == null && this.mandatory != "disabled") {
                this._mFailedValTest = "nullTest";
                this._mFailedValLevel = this.mandatory;
                this._errorText = this.mandatoryMessage;
                this._addMessage(sMessages, this._errorText, this._mFailedValLevel);
                valid = false;
            }
            return valid;
        },

        _getElementsFromXpath: xfalib.script.Field.prototype._getElementsFromXpath,

        _preSubmitEventHandler: xfalib.script.Field.prototype._preSubmitEventHandler,

        /**
         * Exclusion Group can have two types of prefill xml. Long format and short format . In case of Long format,
         * the value of each of  the children of exclusion group is present and hence we need to iterate the children to
         * prefill the value. For short format the textContent is the value of the Exclusion Group
         *
         * The difference between the short and Long format is that in short Format, there are no children of Exclusion
         * Group in xml.
         * @param xmlDocument
         * @param contextNode
         * @param currentBindRef
         * @private
         */
        _playDataXML: function(xmlDocument, contextNode, currentBindRef) {
            var xpath = this._getXpathFromBindRef(),
                nodeIter;
            if(xpath != null) {
                nodeIter = this._getElementsFromXpath(xpath, contextNode, xmlDocument);
                if(nodeIter != null) {
                    var node = nodeIter.iterateNext();
                    if(node != null) {
                        // node has further element childs then iterate over them otherwise set the content as its rawValue
                        if(node.childElementCount > 0) {
                            ExclusionGroup._super._playDataXML.apply(this, [xmlDocument, node, currentBindRef]);
                        } else {
                            this.rawValue = node.textContent;
                        }
                    }
                } else {
                    this._resetData();
                }
            }
        },

        generateDataXML: xfalib.script.Field.prototype.generateDataXML,

        _appendValueInXMLElement: xfalib.script.Field.prototype._appendValueInXMLElement
    });

    ExclusionGroup.defineProps({
        "rawValue" : {
            get : function() {
                var currentNode = this._xfa().moCalculateEventNode;
                if (currentNode != null) {
                    this.addDependant(currentNode);
                    // The children should not register the
                    // calculateNode as dependent on them, else the
                    // calculate event for calculateNode will be called
                    // multiple times.
                    this._xfa()._popCalculateEventNode();
                }

                var val = this._getValue();

                if (currentNode != null)
                    this._xfa()._pushCalculateEventNode(currentNode);

                return val;
            },
            set : function(oValue) {
            	var sMessages = new Array(),
                    onChild = this._getOnChild(),
                    oldVal = onChild ? onChild._getValue() : null

                oValue = this.validateInput(oValue, "string");
                if (oldVal === oValue)
                    return;
                if (onChild) {
                    onChild.setItemState(0, false);
                }
                onChild = _.find(this.moChildNodes, function(child) {
                                    return child.className == "field" &&
                                           child.getOrElse(child.getSaveItem(0), child.getDisplayItem(0)) == oValue
                                })
                if (onChild)
                    onChild.rawValue = oValue;
                this._handleDependants();
                this._xfa().queueValidateEvent(this);
            }
        },

        "mandatory" : {
            get : function() {
                return this.getOrElse(this.validate.nullTest, this._defaults.validate.nullTest);
            },
            set: function (value) {
                if(this.validate){
                    this.validate.nullTest = value;
                }
            }
        },

        "members" : {
            get : function() {
                var list = new xfalib.script.XfaList();
                this.moChildNodes.filter(function(elem) {
                    return elem._isField();
                }).map(function(elem1){
                    list._append(elem1);
                });
                return list;
            }
        },

        "isNull":{
            get : function() {
               if(this._getValue() != null)return false;
               else return true;
            }
        },

        "mandatoryMessage" : {
            get : function() {
                return xfalib.ut.XfaUtil.prototype._getMandatoryMessage(this);
            }
        }
    });

    ExclusionGroup.addMixins([
        xfalib.script.mixin.AddAssist,
        xfalib.script.mixin.AddCaption,
        xfalib.script.mixin.AddPresence,
        xfalib.script.mixin.AddXYWH,
        xfalib.script.mixin.AddFillColor,
        xfalib.script.mixin.AddBorder,
        xfalib.script.mixin.AddBorderColor,
        xfalib.script.mixin.AddPara,
        xfalib.script.mixin.AddMargin
    ]);

})(_, xfalib);
/**
 * @package xfalib.script.Model
 * @import xfalib.script.Node
 */

(function(_, xfalib){
    var Model = xfalib.script.Model = xfalib.script.Element.extend({
        msClassName: "model",

        createNode : function(sClassName,sName,sNamespace) {    //TODO: looks incomplete
            sName = (typeof sName != 'undefined')?sName:"";
            sNamespace = (typeof sNamespace != 'undefined')?sNamespace:"";
            var jsonModel = {};
            jsonModel._class = sClassName;
            jsonModel.name = sName;
            var node = xfalib.script.XfaModelRegistry.prototype.createModel(jsonModel);
            return node;
        }
    });
})(_, xfalib);

/**
 * @package xfalib.script.Form
 * @import xfalib.script.ContainerNode
 */

(function (_, xfalib) {
    /**
     * @class
     * <p>
     * The Form class is the implementation of the top level XFA form object.
     * </p>
     *
     * <p>
     * The form object is accessed from the xfa object as xfa.form
     * </p>
     *
     */
    var Form = xfalib.script.Form = xfalib.script.EventContainerNode.extend({
        _getRootSubform: function () {
            return this.children[0];
        },

        _initialize: function () {
            this._xfa()._modelInitialize = 'INITIALIZING';
            var rootSubform = this._getRootSubform();
            rootSubform._initialize();
            //
            // Call all initialization then
            // calculations
            // scripts to execute
            //
            var pgSets = rootSubform.resolveNodes("#pageSet[*]");
            function execOnPgSets (execFuncname) {
                for(var i=0; i < pgSets.length; ++i) {
                    pgSets.item(i)[execFuncname]();
                }
            }

            rootSubform.execFormReady();
            execOnPgSets("execFormReady");
            rootSubform.execInitialize();
            execOnPgSets("execInitialize");
            rootSubform.execLayoutReady();
            execOnPgSets("execLayoutReady");
            rootSubform.execCalculate();
            this._xfa()._modelInitialize = 'INITIALIZED';
        },

        playJson: function (pJsonModel) {
            this._getRootSubform().playJson(pJsonModel.children[0]);
        },

        /**
         * @private
         * @function indicate that this is a Form node (~~).
         */
        _isForm: function () {
            return true;
        },

        execCalculate: function () {
            return this._getRootSubform().execCalculate();
        },

        execInitialize: function () {
            this._getRootSubform().execInitialize();
        },

        execFormReady: function () {
            this._getRootSubform().execFormReady();
        },

        execLayoutReady: function () {
            this._getRootSubform().execLayoutReady();
        },

        execValidate: function () {
            return this._getRootSubform().execValidate();
        },

        execPreSubmit: function () {
            return this._getRootSubform().execPreSubmit();
        },
        /**
         * remerge the data with the form model
         */
        remerge: function () {
            this._getRootSubform()._bind();
        },

        /**
         * recalculate this form model
         */
        recalculate: function (bool) {
            var xf = this._xfa();
            if (xf.host.calculationsEnabled) {
                if (xf.calculateRunning)
                    return;
                if (bool) {
                    this.execCalculate();
                    this.execFormReady();
                } else {
                    xf.runCalcs()
                }
            }
        },

        _computeJsonDiff: function (diff_level) {
            var diff = Form._super._computeJsonDiff.call(this, diff_level);
            diff.jsonDifference["versionNS"] = this.jsonModel["versionNS"];
            return { "changed": true,
                "jsonDifference": diff.jsonDifference
            };
        },

        createNode: xfalib.script.Model.prototype.createNode

    });
})(_, xfalib);
/**
 * @package xfalib.script.Host
 * @import xfalib.script.Node
 * @fileOverview The file creates the Host Class required for XFA library
 * @version 0.0.1
 */

(function(_, xfalib, $){
    /**
     * @class The class represents the Host Object
     * @extends com.adobe.xfa.scripting.Node
     * @property {string} appType the application type of the host
     * @property {number} currentPage Page number of the form that is being
     *           displayed
     * @property {number} numPages total number of pages in the form
     * @property {name} name name of the application
     * @property {number} platform OS platform on which the application is running
     * @property {number} title title of the document
     * @property {number} version version number of the current application
     */
    var Host = xfalib.script.Host = xfalib.script.Node.extend({
        msClassName: "hostPseudoModel",
        initialize : function(){
            Host._super.initialize.call(this);
            this.jsonModel.name = "";
            this.mPageNumber = 0;
            this.pagingManager = null ;
            this.mCalculationsEnabled = true;
            this.mValidataionsEnabled = true;
            this.mNumPages = "";
            this.dataBrowser = [
                {
                    string: navigator.userAgent,
                    subString: "Chrome",
                    identity: "Chrome"
                },
                {
                    string: navigator.vendor,
                    subString: "Apple",
                    identity: "Safari",
                    versionSearch: "Version"
                },
                {
                    prop: window.opera,
                    identity: "Opera",
                    versionSearch: "Version"
                },
                {
                    string: navigator.userAgent,
                    subString: "Firefox",
                    identity: "Firefox"
                },
                {		// for newer Netscapes (6+)
                    string: navigator.userAgent,
                    subString: "Netscape",
                    identity: "Netscape"
                },
                {
                    string: navigator.userAgent,
                    subString: "MSIE",
                    identity: "Internet Explorer",
                    versionSearch: "MSIE"
                },
                {
                    string: navigator.userAgent,
                    subString: "Gecko",
                    identity: "Mozilla",
                    versionSearch: "rv"
                },
                { 		// for older Netscapes (4-)
                    string: navigator.userAgent,
                    subString: "Mozilla",
                    identity: "Netscape",
                    versionSearch: "Mozilla"
                }
            ];
        },

        _searchVersion : function(data,srch) {
            var index = data.indexOf(srch);
            if (index == -1) return;
            var spcIndex = data.indexOf(" ",index);
            if(spcIndex == -1)
                return data.substring(index+srch.length+1);
            return data.substring(index+srch.length+1,spcIndex);
        },

        _browserDetect : function() {
            var data = this.dataBrowser;
            for (var i=0;i<data.length;i++)	{
                var dataString = data[i].string;
                var dataProp = data[i].prop;
                var versionSearchString = data[i].versionSearch || data[i].identity;
                var version = this._searchVersion(navigator.userAgent,versionSearchString) || this._searchVersion(navigator.appVersion,versionSearchString) || "an unknown version";
                if (dataString) {
                    if (dataString.indexOf(data[i].subString) != -1)
                        return data[i].identity+" "+version;
                }
                else if (dataProp)
                    return data[i].identity+" "+version;
            }
        },

        /**
         * The function displays a dialog box on the screen. <br />
         * <b>TO DO</b><br />
         * <ul>
         * <li> The function doesn't supports icons as of now. Needs adding support for
         * that.</li>
         * <li> The dialog uses the default styling (provided by google). Need to change
         * that too. </li>
         * </ul>
         *
         * @function
         * @param {string}
            *            message The message to display
         * @param {string}
            *            title The title to appear in the dialog's window title
         * @param {number}
            *            type The icon to display: '0' (Error (default)), '1' (Warning),
         *            '2' (Question), and '3' (Status).
         * @param {number}
            *            buttons The buttons to display: '0' (OK (default)), '1' (OK,
         *            Cancel), '2' (Yes, No), and '3' (Yes, No, Cancel).
         */
        messageBox : function(message, title, type, buttons) {
            return (this._messageBox(message,title,type,buttons,null));
        },

        _messageBox : function(message, title, type, buttons,callback) {
            title = title || "";
            buttons = buttons || 0;
            var img =["Error","Warning","Question","Status"];
            var imgType = "";
            if(type!=undefined)
                imgType =  "[ " + img[type] + " ]  ";
            message = imgType  +  title + "\n\r" + message ;

            switch (buttons) {
                case 0:
                    alert(message);
                    return 1 ;
                case 1:
                    var a = confirm(message);
                    if(a==true)
                        return 1;
                    else return 2;
                case 2:
                    var a = confirm(message);
                    this._xfa().Logger.error("xfa", xfalib.locale.LogMessages["ALC-FRM-901-009"]) ;
                    if(a==true)
                        return 4;
                    else return 3;

                case 3:
                    this._xfa().Logger.error("xfa", xfalib.locale.LogMessages["ALC-FRM-901-010"]);
                    return 0;
            }
        },

        /**
         * The function displays the next page of the document (if one exists)
         *
         * @function
         */
        pageDown : function() {
            if (this.currentPage != this.numPages -1 ) {
                if(this.pagingManager)
                    this.pagingManager.pageDown();
            }
        },

        /**
         * The function displays the previous page of the document (if one exists)
         *
         * @function
         */
        pageUp : function() {
            if (this.currentPage != 0)  {
                var prevPage = this.currentPage - 1;
                var a = $($(".page")[prevPage])  ;
                window.scrollTo(0,a.offset().top) ;
            }
        },

        gotoURL: function(url, bNewFrame) {
            /*if(!$("a#gotourl").length)
                $("<a id='gotourl'></a>").appendTo('body');
            $("a#gotourl").attr("href",url)[0].click();
            //$("a").click();     */
            if(url.search("http") == -1)
                url = "http://" + url ;
            if(bNewFrame != true) {
                window.open(url) ;
            }
            else
                window.location = url;
        },

        resetData : function() {
            if(arguments.length)
                _.each(arguments,function(som) {
                    var node = this._xfa().resolveNode(som);
                    if(node)
                        node._resetData();
                },this)
            else {
                this._xfa().form._resetData();
            }
        },

        setFocus : function(som) {
            if(navigator.userAgent.match(/iPad/i) != null && this._xfa().moContextScriptEvent == 'change') {
            // LC-4663 : setFocus was shifting focus, before keypress was visible in browser.
            // Currently iPad doesnt support calling focus() from within setTimeout, so disabling the functionality.
                this._setFocus(som); // don't queue focus events, fire it immediately
            } else {
                this._xfa().queueFocusEvent(this, som);
            }
        },

         _setFocus : function(som) {
                    var node = som;
                    if(typeof som == "string")
                        node = this._xfa().resolveNode(som);
                    if(node != null){
                       if(this.pagingManager){
                            if(navigator.userAgent.match(/iPad/i) != null && this._xfa().moContextScriptEvent == 'change') {
                                this.pagingManager._makePageForHtmlId(node.htmlId); // LC-4663 : just render, not setFocus
                            } else {
                                this.pagingManager._makePageForHtmlId(node.htmlId,node._setFocus,node);  // for all other events set the focus
                            }
                        }
                    }
                    return node;
        },

         getFocus : function() {
                          if(xfalib.view.FieldView.prototype.currentFocus)
                            return(xfalib.view.FieldView.prototype.currentFocus.model);
                          else
                            return null;
                        } ,

        playDataXml: function (xmlDocument) {
            var rootElement;
            if(_.isUndefined(document.evaluate)) {
                // need to do it here since XPathResult is also undefined in IE
                wgxpath.install();
            }
            if(_.isString(xmlDocument)) {
                this._xfa().Logger.info("xfa", "xmlDocument is of type string. converting it to document");
                xmlDocument = $.parseXML(xmlDocument);
            }
            rootElement = xfalib.ut.XMLUtils.getXFARootFormElementFromXML(xmlDocument);
            this._xfa().form._playDataXML(rootElement, rootElement, "");
        },

        playJson : function(xfaJsonModel) {
            var formDom =  _.find(xfaJsonModel.children,
                function(child){
                    return child._class == "form";
                }
            );
            this._xfa().form.playJson(formDom);
            var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.FORM_MODEL_REFRESH,
                this,"jsonModel",null,this._xfa().form.jsonModel);
            this.trigger(evnt.name,evnt);
        },

        runServerScript : function(options) {
            options = options|| {};
            var xfaDiff = this._xfa()._computeJsonDiff(0).jsonDifference;
            var xfaDomString = JSON.stringify(xfaDiff);
           //clone the object to avoid polluting the context
            var params = _.extend({
                    formDom: xfaDomString,
                    packet: 'form'
                },
                options,
                xfalib.runtime.renderContext);

            var serverScriptSuccessHandler = function(result){
                this.playJson(result); //result will be a JSON object so just play it.
            };

            if(options.contextSom && options.activity)
            {
                var that = this;
                window.formBridge._invokeAtServer({
                    data: params,
                    success:_.bind(serverScriptSuccessHandler,this),
                    error: function(xhr,txtStatus,errorThrown) {
                        var msg
                        switch(xhr.status) {
                            case 0:
                                msg = xfalib.locale.LogMessages["ALC-FRM-901-008"];
                                that._xfa().Logger.error("xfa", msg + " " + xhr.statusText);
                                break;
                            default:
                                msg = xfalib.locale.LogMessages["ALC-FRM-901-001"];
                                that._xfa().Logger.error("xfa", msg + " " + xhr.statusText);
                                break;
                        }
                        that.messageBox(msg);
                    }
                });
            }
        },

        _validate : function(options) {
            var _options = options || {},
                valMessages = _options.valMessages || [];
            var valid = this._xfa().form._validate(valMessages);
            if(valid)
                return true;

            var errors = "";
            var warnings = "";

            for(var i=0; i < valMessages.length; i++)
            {
                var msg = null;
                if(msg = valMessages[i])
                {
                    if(msg.severity == "error") {
                        errors = errors + msg.message + "\r\n";
                    }
                    if(msg.severity == "warning"){
                        warnings = warnings + msg.message + "\r\n";
                    }
                }
            }
            if(errors)
            {
                var that = this;
                var msg = "  The form could not be submitted because "+valMessages.length +" errors were found"
                if($("#wb-main-in").length){
                    if(!$("#xfa-errorMessages").length){
                        $("#wb-main-in").prepend("<div id ='xfa-errorMessages'></div>");
                    }
                    $("#xfa-errorMessages").empty().text(msg).append("<ul id='xfa-errorList'></ul>");
                    _.each(valMessages,function(elem) {
                        $("<a></a>").appendTo($("<li></li>").appendTo('#xfa-errorList'))
                                         .text(elem.message)
                                          .click(
                                                function() {
                                                    return that.setFocus(elem.ref);
                                                });
                    })
                    if(valMessages.length ==0)
                        $("#xfa-errorMessages").hide();
                    else
                        $("#xfa-errorMessages").show();
                }
                this.setFocus(valMessages[0].ref);
                return false;
            }
            else if(warnings)
            {
                this.messageBox(warnings, xfalib.locale.Strings.warning, 1, 0);   //TODO :Should  be ok/cancel
                return true;
            }
        },

        /**
         * Helper function for currentDateTime
         *
         * @function
         */
        _padzero : function(n) {
            return n < 10 ? '0' + n : n;
        },

        /**
         * Helper function for currentDateTime
         *
         * @function
         */
        _pad2zeros : function(n) {
            if (n < 100) {
                n = '0' + n;
            }
            if (n < 10) {
                n = '0' + n;
            }
            return n;
        },

        /**
        * The function Returns current date and time in [m]m/[d]d/yy [H]H:[M]M (A|P)M format
        *
        * @function
        */
        currentDateTime : function() {
            var now = new Date(),
                    curYear = now.getFullYear() +'',
                    curMonth = now.getMonth()+1 +'',
                    curDate = now.getDate() +'',
                    curHour = now.getHours() +'',
                    curMin = now.getMinutes() +'',
                    curSec = now.getSeconds() +'';

            return (curYear + this._padzero(curMonth) + this._padzero(curDate) + 'T' +
                    this._padzero(curHour) + this._padzero(curMin) + this._padzero(curSec));
        },

        /**
         * Helper function for currentDateTime
         *
         * @function
         */
        _toISOString : function(d) {
            return d.getUTCFullYear() + '-' +  this._padzero(d.getUTCMonth() + 1) + '-' +
                this._padzero(d.getUTCDate()) + 'T' + this._padzero(d.getUTCHours()) + ':' +
                this._padzero(d.getUTCMinutes()) + ':' + this._padzero(d.getUTCSeconds()) + '.' + this._pad2zeros(d.getUTCMilliseconds()) + 'Z';
        },

        /**
         * The function Returns current date and time in ISO 8601 format
         *
         * @function
         */
        _currentDateTime : function() {
            var now = new Date();
            return(this._toISOString(now));
        }

    });

    Host.platforms = [["Win","Windows"],["Mac"],["iPhone","iPhone/iPod"],["iPad"],["Linux"],["Unknown"]];

    Host.defineProps({
        "appType" : {
            get : function() {
                return "HTML 5";
            }
        },

        "currentPage" : {
            get : function() {
                if(this.pagingManager)
                    return(this.pagingManager.currentPage());
            },
            set : function(page) {
                var currentPage = 0,
                    lastPage = 0;
                page = parseInt(page);
                if(this.pagingManager) {
                    currentPage = this.pagingManager.currentPage();
                    lastPage = this.pagingManager.pageCount();
                }

                if(page < 0)
                    page = 0;
                else if(page >= lastPage)
                    page =  (lastPage > 0) ? lastPage -1 : 0;

                var $pages = $(".page");

                if( page > $pages.length-1 ) {  // not all pages rendered yet
                    if(this.pagingManager) {
                        while(this.pagingManager.hasMorePages() && currentPage <= page){
                            this.pagingManager.renderNextPage();
                            currentPage++;
                        }
                    }
                    $pages = $(".page");   // select newly rendered pages
                }

                var a = $($pages[page]);
                window.scrollTo(0,a.offset().top) ;
            }
        },

        "name" : {
            get : function() {
                return this._browserDetect();
            }
        },

        "variation" : {
            get : function() {

            }
        },

        "numPages" : {
            get : function() {
                if(this.pagingManager)
                    return(this.pagingManager.pageCount());
            }
        },

        "platform" : {
            get : function() {
                var arr = Host.platforms;
                if (!this.mPlatform) {
                    for(var i = 0;i<arr.length;i++)
                          if(~navigator.platform.indexOf(arr[i][0]))
                                break;
                    i = i == arr.length ? i - 1 :i;
                    this.mPlatform =  arr[i][arr[i].length-1];
                }
                return this.mPlatform
            }
        },

        "title" : {
            get : function() {
                return document.title;
            },
            set : function(title) {
            	title = this.validateInput(title, "string");
                document.title = title;
            },
            enumerable : true
        },

        "version" : {
            get : function() {
                return "1.0";
            }
        },


        "calculationsEnabled" : {
            get : function() {
                return this.mCalculationsEnabled;
            },
            set : function(sCalculationsEnabled) {
            	//sCalculationsEnabled = this.validateInput(sCalculationsEnabled, "string");
                var sOriginalValue = this.mCalculationsEnabled;
                this.mCalculationsEnabled = sCalculationsEnabled;
                if (!sCalculationsEnabled) {
                    //this.xfa._rootSubform._clearMessages(); TODO: Clear Calculation messages
                } else if (sCalculationsEnabled && (sOriginalValue == false)) {
                    this._xfa().form.execCalculate();
                }
            }
        },

        "validationsEnabled" : {
            get : function() {
                return this.mValidataionsEnabled;
            },
            set : function(sValidationsEnabled) {
            	//sValidationsEnabled = this.validateInput(sValidationsEnabled, "string");
                var sOriginalValue = this.mValidataionsEnabled;
                this.mValidataionsEnabled = sValidationsEnabled;
                if (!sValidationsEnabled) {
                    //this.xfa._rootSubform._clearMessages(); TODO: Clear Validation messages
                } else if (sValidationsEnabled && (sOriginalValue == false)) {
                    this._xfa().form._validate();
                }
            }
        }

    });
})(_, xfalib, $);







(function (_, $, xfalib) {
    var XfaTemplateCache = xfalib.script.XfaTemplateCache = xfalib.ut.Class.extend({

        initialize: function () {
            XfaTemplateCache._super.initialize.call(this);
            this._lastID = (new Date()).getTime(); //TODO: Get a better scheme
            this._nodeCache = {};        // live cache
            this._t0JsonNodeCache = {}; // initial cache
            this.idMap = {};           //--map to get the field instance of the corresponding field-id

            var jsonString = JSON.stringify(this.options.initialFormDom), //We create copy of initial form dom via JSON api instead of this.copyObject since that is fast
                initialFormDomCopy = JSON.parse(jsonString),    //Create copy of initial form dom to guard against future modifications
                formDomTemplate = {};   //Copy holding formDomTemplate

            this.copyObject(initialFormDomCopy, formDomTemplate, {"exceptions": ["children"]});
            //Generate template
            this._processTemplate(formDomTemplate, initialFormDomCopy, false);
            var behaviorConfig = new xfalib.ut.Version(formBridge.userConfig["behaviorConfig"]);
            //To maintain backward compatibility
            if (behaviorConfig.isOn('stripInitialFormDom') || behaviorConfig.isOn('mfStripInitialFormDom')) {
                xfalib.ut.XfaUtil.prototype.stripObject(this._t0JsonNodeCache[initialFormDomCopy.extras.htmlId].initialRef,
                                                        ['_class', 'name', 'htmlId', 'presence', 'min', 'max']);
            }
        },

        getTemplateRef: function (htmlId) {
            if (this._nodeCache.hasOwnProperty(htmlId))
                return this._nodeCache[htmlId].templateRef;
            else if (this._t0JsonNodeCache.hasOwnProperty(htmlId))
                return this._t0JsonNodeCache[htmlId].templateRef;
            else
                return null;
        },

        getInitialFormDomRef: function (htmlId) {
            if (this._t0JsonNodeCache.hasOwnProperty(htmlId))
                return this._t0JsonNodeCache[htmlId].initialRef;
            else
                return null;
        },

        getModel: function (htmlId) {
            if (this._nodeCache.hasOwnProperty(htmlId))
                return this._nodeCache[htmlId].model;
            else
                return null;
        },

        putModel: function (model, jsonTemplate) {
            this._processModel(jsonTemplate, model);
        },

        removeModel: function (htmlId) {
            if (this._nodeCache.hasOwnProperty(htmlId))
                delete this._nodeCache[htmlId];
        },

        _processTemplate: function (jsonTemplate, jsonModel, canRepeat) {
            var templateId = null;
            if (this.getOrElse(jsonTemplate, "extras.htmlId", null) == null) {
                jsonTemplate.extras = jsonTemplate.extras || {};
                jsonTemplate.extras.htmlId = "CL_" + (++this._lastID);
                templateId = jsonTemplate.extras.htmlId;
            }
            if (this.getOrElse(jsonModel, "extras.htmlId", null) == null) {
                jsonModel.extras = jsonModel.extras || {};
                if (templateId != null)
                    jsonModel.extras.htmlId = templateId;
                else
                    jsonModel.extras.htmlId = "CL_" + (++this._lastID);
            }
            this._t0JsonNodeCache[jsonModel.extras.htmlId] = {templateRef: jsonTemplate, initialRef: jsonModel};

            if (!canRepeat && !_.contains(["area", "pageSet", "pageArea", "subform", "subformSet", "contentArea", "exclGroup", "form"], jsonModel._class)) {
                //Process it's child only if that can repeat or it can have paintable children. This is badly written check. Need to re-code this.
                return;
            }

            var lastIM = null;
            var lastChildSF = false;
            var childTemplateIndex = -1;
            _.each(jsonModel.children,
                function (childNode, i) {
                    if (this.matchJsonType(childNode, "instanceManager")) {
                        lastIM = childNode;
                    }

                    if (!lastChildSF) {   //If last child was not subform then increase template index
                        childTemplateIndex = childTemplateIndex + 1;
                    } else if (!this.xfaUtil().isRepeatabeEl(childNode._class)) { //Else increase template index only for non-subform
                        childTemplateIndex = childTemplateIndex + 1;
                    }

                    var childRepeat = canRepeat;
                    if (this.xfaUtil().isRepeatabeEl(childNode._class)) {
                        childRepeat = childRepeat || parseInt(this.getOrElse(lastIM, "max", xfalib.script.Occur.prototype._defaults.max)) < 0 ||
                            (parseInt(this.getOrElse(lastIM, "min", xfalib.script.Occur.prototype._defaults.min)) < parseInt(this.getOrElse(lastIM, "max", xfalib.script.Occur.prototype._defaults.max)));
                        lastChildSF = true;
                    }
                    else
                        lastChildSF = false;

                    jsonTemplate.children = jsonTemplate.children || [];
                    var childTemplate = jsonTemplate.children[childTemplateIndex];
                    if (!childTemplate) {
                        childTemplate = {
                            _class: childNode._class,
                            name: childNode.name,
                            extras: childNode.extras || {}
                        };
                        if (childRepeat) { //For repeatable child copy all properties
                            this.copyObject(childNode, childTemplate, {exceptions: ["children"], keepReference: false});
                        }
                        jsonTemplate.children.push(childTemplate);
                    }
                    this._processTemplate(childTemplate, childNode, childRepeat);
                }, this);
        },

        _processModel: function (jsonTemplate, model) {
            if (model.htmlId == null) {
                model.htmlId = "CL_" + (++this._lastID);
            }
            this._nodeCache[model.htmlId] = {templateRef: jsonTemplate, model: model};
            var childTemplateIndex = -1;
            var lastChildSF = false;
            _.each(model.children,
                function (childNode, i) {
                    if (!lastChildSF) {   //If last child was not subform then increase template index
                        childTemplateIndex = childTemplateIndex + 1;
                    } else if (!(childNode instanceof xfalib.script.Subform)) { //Else increase template index only for non-subform
                        childTemplateIndex = childTemplateIndex + 1;
                    }

                    lastChildSF = childNode instanceof xfalib.script.Subform;

                    var childTemplate = jsonTemplate.children ? jsonTemplate.children[childTemplateIndex] : undefined
                    if (childTemplate)
                        this._processModel(childTemplate, childNode);
                }, this);
        },

        matchJsonType: xfalib.ut.XfaUtil.prototype.matchJsonType

    });

})(_, $, xfalib);
/**
 * @package xfalib.script.Xfa
 * @import xfalib.script.Model
 * @import xfalib.ut.Logger
 * @import xfalib.script.Host
 * @import xfalib.script.XfaModelEvent
 * @fileOverview The file creates the XFA Class required for XFA library
 * @version 0.0.1
 */

(function (_, xfalib) {
    /**
     * @class The class represents the XFA Object
     * @extends com.adobe.xfa.scripting.Model
     * @property {com.adobe.xfa.scripting.Host} host Object of the host class
     */
    var Xfa = xfalib.script.Xfa = xfalib.script.Model.extend({
        msClassName: "xfa",
        initialize: function () {
            xfalib.runtime.xfa = this;                           //TODO: Handle anithing being used before super
            xfalib.runtime["$xfa"] = this;
            this.$layout = this.layout = new xfalib.script.Layout({"jsonModel": {}});
            var logConf = window.formBridge.registerConfig("LoggerConfig").data || {};
            var renderContextCopy = {};
            this.copyObject(xfalib.runtime.renderContext, renderContextCopy, {"exceptions": ["data"]})
            xfalib.runtime.xfa.Logger = new xfalib.ut.Logger({
                "jsonModel": logConf,
                logServiceProxy: this.getOrElse(window.formBridge.userConfig["submitServiceProxyConfig"], "logServiceProxy", ""),
                renderContext: renderContextCopy,
                contextPath: window.formBridge.userConfig["contextPath"]
            });
            xfalib.runtime.xfa.ErrorManager = this.getOrElse(window.formBridge.userConfig["errorConfig"],new xfalib.view.util.ErrorManager)
            xfalib.script.Xfa.Instance = this;          //TODO: Singleton reqd?
            this._submitButtons = [];
            this._modelInitialize = 'UNINITIALIZED'; // can be set to 'INITIALIZED' or ''INITIALIZING'
            this.moContextNodes = [];
            this.moCalculateEventStack = [];
            this.moCalculateEventNode = null;
            this.host = new xfalib.script.Host();
            xfalib.runtime["$host"] = this.host;
            this.countError = 0;
            this.dataNodes = {};
            this._templateSchema = new xfalib.template.TemplateSchema();
            this.moContextScriptEvent = null; // will hold current event for which script is executing
            this.Queue = {"calc": [], "calcindex": 0, "validate": [], "validateindex": 0, calcCount: {},
                "setfocus": [], "setfocusindex": 0};

            // to clear all _moContext-s cached in eventContainerNode-s, after subform.addInstance or subform.removeInstance
            xfalib.runtime.xfa._clearAllMoContexts = function () {
                function clearMoContextVisitor(target) {
                    if (target instanceof xfalib.script.EventContainerNode) {
                        target._moContext = null;
                    }
                }
                xfalib.runtime.xfa.form._getRootSubform()._visitAllmoChildren(clearMoContextVisitor);
            };

            //Create Form Child
            var formJson = _.find(this.jsonModel.children, function (child) {
                return child._class == "form";
            });
            this._xfaTemplateCache = new xfalib.script.XfaTemplateCache({initialFormDom: formJson});

            //We call Super later at this stage since we need to initialize few variables which are required while initializing children
            Xfa._super.initialize.call(this);

            //get the child from children models that are already created.
            this.form = _.find(this.children, function (child) {
                return child._isForm();
            });
            this._xfaTemplateCache.putModel(this.form,
                this._xfaTemplateCache.getTemplateRef(this.getOrElse(formJson, "extras.htmlId", {}))
            );

            //Note: since we do not support template currently, we workarond by pointing template node to form node which would have similar structure in most cases.
            xfalib.runtime['$template'] = this.template = xfalib.runtime['$form'] = this.form;
            xfalib.runtime['template'] = xfalib.runtime['form'] = this.form;

            //Create Config Child. Notice that it is not XFA Node model, just a json child for now.
            this.config = _.find(this.jsonModel.children, function (child) {
                return child._class == "config";
            });
            xfalib.runtime['$config'] = this.config;

            //Create localeSet Child. Notice that it is not XFA Node model, just a json child for now.
            this.localeSet = this.jsonModel.localeSet;
            this.defaultLocale = "en_US"; //TODO: read from jsp

            //Once everything is set up, now is the time to set parent access
            this.form._calculateEffectiveAccess();
            this.form._calculateEffectivePresence();
            this.calculateRunning = false;
            this.validateRunning = false;
            this.versionConfig = new xfalib.ut.Version(formBridge.userConfig["behaviorConfig"]);
        },

        /**
         * Evaluates the specified SOM expression, beginning with the current XML form
         * object model object, and returns the value of the object specified in the SOM
         * expression
         * @Overrides
         * @function
         */
        resolveNode: function () {
            if (arguments.length == 1)
                return Xfa._super.resolveNode.call(this, this._contextNode() || this, arguments[0]);
            else
                return Xfa._super.resolveNode.call(this, arguments[0], arguments[1]);
        },

        /**
         * Evaluates the specified SOM expression, beginning with the current XML form
         * object model object, and returns the value of the object specified in the SOM
         * expression
         * @Overrides
         * @function
         */
        resolveNodes: function () {
            if (arguments.length == 1)
                return Xfa._super.resolveNodes.call(this, this._contextNode(), arguments[0]);
            else
                return Xfa._super.resolveNodes.call(this, arguments[0], arguments[1]);
        },

        _newSubmitButton: function (elem) {
            if (!~this._submitButtons.indexOf(elem))     //TODO: What is this. Add a comment
                this._submitButtons.push(elem);
        },

        _hideSubmitButtons: function (elem) {
            for (var i = 0; i < this._submitButtons.length; i++) {
                this._submitButtons[i].presence = "hidden";
            }
        },

        /**
         * The function pushes a new Calculate Event Node into the Calculate Stack
         * @function
         * @param {com.adobe.xfa.scripting.Node} node current context node
         * @private
         */
        _pushCalculateEventNode: function (node) {
            this.moCalculateEventStack.push(node);
            this.moCalculateEventNode = node;
        },

        /**
         * The function pushes a new XFA Node in the current context
         * @function
         * @param {com.adobe.xfa.scripting.Node} node current context node
         * @private
         */
        _pushContextNode: function (node) {
            this.moContextNodes.push(node);
        },

        /**
         * The function pops Calculate Event Node from the stack of context nodes
         * @function
         * @private
         */
        _popCalculateEventNode: function () {
            this.moCalculateEventStack.pop();
            this.moCalculateEventNode = null;
        },

        /**
         * The function pops a XFA Node from the stack of context nodes
         * @function
         * @private
         */
        _popContextNode: function () {
            this.moContextNodes.pop();
        },

        _contextNode: function () {
            var len = this.moContextNodes.length;
            if (len > 0)
                return this.moContextNodes[len - 1]
            return null;
        },

        _isXFAContainerNode: function () {
            return true;
        },

        _getSomExpression: function () {
            return this.getAttribute("name") + "[" + this.index + "]";
        },

        _getLocaleSymbols: function (locale, symbol) {
            var ret = null;
            var newSymbol = "locales." + locale + "." + symbol;
            ret = this.getOrElse(this.localeSet, newSymbol, xfalib.ut.XfaUtil.prototype.getDefaultLocaleProperty(symbol));
            if (!ret) {
                xfalib.runtime.xfa.Logger.error("xfa", "unable to find " + symbol + " for locale " + locale + "in localeSet");
            }
            return ret;
        },

        setSubformFocus: function (subform) {
            var oldSubform = this.currentSubform;
            this.currentSubform = subform;
            var views = [];
            if (oldSubform) {
                var pSubform = subform;
                while (pSubform) {
                    views.push(pSubform);
                    pSubform = pSubform.parent;
                }
                while (oldSubform && views.indexOf(oldSubform) == -1) {
                    oldSubform.execEvent("exit");
                    oldSubform = oldSubform.parent;
                }
            }
        },

        createDataNode: function (id, model) {
            if (id) {
                var dn = this.dataNodes[id] || xfalib.script.XfaModelRegistry.prototype.createDataNode(id);
                dn.addField(model);
                this.dataNodes[id] = dn;
            }
        },

        queueCalcEvent: function (oListener) {
            if (!this.host.calculationsEnabled)
                return;
            var q = this.Queue["calc"];
            var som = oListener.somExpression;
            for (var i = 0; i < q.length; i++) {
                var item = q[i];
                if (oListener == item) {
                    if (i < this.Queue.calcindex) {
                        if (this.Queue.calcCount[som] === 10)
                            return;
                    }
                    else
                        return;
                }
            }
            this.Queue.calcCount[som] = this.Queue.calcCount[som] || 0;
            this.Queue.calcCount[som]++;
            q.push(oListener);
        },

        queueValidateEvent: function (oNode) {
            if (!this.host.validationsEnabled)
                return;
            if (!~this.Queue["validate"].indexOf(oNode))
                this.Queue["validate"].push(oNode);
        },

        queueFocusEvent: function (context, som) {
            this.Queue["setfocus"].push({'context': context, 'som': som});
        },

        runQueue: function (queue, evnt) {
            if (queue !== "calc" && queue !== "validate")
                return;
            if (queue == "calc" && !this.host.calculationsEnabled)
                return;
            if (queue == "validate" && !this.host.validationsEnabled)
                return;
            var Q = this.Queue[queue];
            var ind = this.Queue[queue + "index"];
            for (var i = ind; i < Q.length; i++) {
                this.Queue[queue + "index"]++;
                if (evnt === "validate") {
                    Q[i]._validate([]);
                }
                else {
                    Q[i].execEvent(evnt);
                }
            }
        },

        runCalcAndValidate: function () {
            this._pushContextNode(this.form);
            this.runCalcs();
            this.runValidates();
            this.runSetFocuses();
            this.Queue["calc"] = [];
            this.Queue.calcindex = 0;
            this.Queue.calcCount = {};
            this.Queue["validate"] = [];
            this.Queue.validateindex = 0;
            this.Queue["setfocus"] = [];
            this.Queue.setfocusindex = 0;
            this._popContextNode();
        },

        runCalcs: function (start) {
            if (typeof start != "undefined" && start === "true")
                this.Queue.calcindex = 0;
            this.calculateRunning = true;
            this.runQueue("calc", "calculate");
            this.calculateRunning = false;
        },

        runValidates: function () {
            this.validateRunning = true;
            this.runQueue("validate", "validate")
            this.validateRunning = false;
        },

        runSetFocuses: function () {
            var Q = this.Queue["setfocus"],
                index = this.Queue["setfocusindex"];
            for (var i = index; i < Q.length; i++) {
                this.Queue["setfocusindex"]++;
                var som = Q[i]['som'],
                    node = som,
                    context = Q[i]['context'];
                if (typeof som == "string")
                    node = context._xfa().resolveNode(som);
                if (node != null) {
                    if (context.pagingManager) {
                        if (navigator.userAgent.match(/iPad/i) == null) {
                            xfalib.ut.XfaUtil.prototype.clearTimeoutOnDestroy(
                                setTimeout(function () {
                                    context.pagingManager._makePageForHtmlId(node.htmlId, node._setFocus, node);
                                })
                            );  // just give browser enough time to register the keypress
                        } else {
                            context.pagingManager._makePageForHtmlId(node.htmlId, node._setFocus, node); // $.focus() doesn't work inside setTimeout in iPad
                        }
                    }
                }
            }
        },

        _computeJsonDiff: function (diff_level) {
            var formDiff = this.form._computeJsonDiff(diff_level);
            var dest = {
                _class: this.className,
                name: "xfa",
                versionNS: this.jsonModel.versionNS,
                children: [formDiff.jsonDifference]
            };

            return { "changed": true,
                "jsonDifference": dest
            };
        }
    });

    Xfa._defaultLocale = {
        "calendarSymbols": {
            "monthNames": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            "abbrmonthNames": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            "dayNames": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            "abbrdayNames": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            "meridiemNames": ["AM", "PM"],
            "eraNames": ["BC", "AD"]
        },
        "datePatterns": {
            "full": "EEEE D MMMM YYYY",
            "long": "D MMMM YYYY",
            "med": "DD-MMM-YY",
            "short": "DD/MM/YY"
        },
        "timePatterns": {
            "full": "h:MM:SS A Z",
            "long": "h:MM:SS A Z",
            "med": "h:MM:SS A",
            "short": "h:MM A"
        },
        "dateTimeSymbols": "GyMdkHmsSEDFwWahKzZ",
        "numberPatterns": {
            "numeric": "z,zz,zz9.zzz",
            "currency": "$ z,zz,zz9.99",
            "percent": "z,zz,zz9%"
        },
        "numberSymbols": {
            "decimal": ".",
            "grouping": ",",
            "percent": "%",
            "minus": "-",
            "zero": "0"
        },
        "currencySymbols": {
            "symbol": "$",
            "isoname": "USD",
            "decimal": "."
        },
        "typefaces": {}
    }
})(_, xfalib);
/**
 * @package xfalib.script.XfaModelRegistry
 * @import xfalib.ut.Class
 */
(function(_, xfalib){
    var XfaModelRegistry = xfalib.script.XfaModelRegistry = xfalib.ut.Class.extend({

        _classToFactoryMap : {
            "script" : "createScript",
            "exclGroup" : "createExclusionGroup",

            "arc" : "createNodeValue",
            "boolean": "createNodeValue",
            "date": "createNodeValue",
            "dateTime": "createNodeValue",
            "decimal": "createNodeValue",
            "exData": "createNodeValue",
            "float": "createNodeValue",
            "image": "createNodeValue",
            "integer": "createNodeValue",
            "line": "createNodeValue",
            "rectangle": "createNodeValue",
            "text": "createNodeValue",
            "time": "createNodeValue"

        },

        createModel : function(jsonModel){
            var model = null;
            var elClass = jsonModel._class.charAt(0).toUpperCase() + jsonModel._class.substr(1);
            var factoryFnName = "create" + elClass ;
            if(this._classToFactoryMap[jsonModel._class]){
                factoryFnName = this._classToFactoryMap[jsonModel._class];
            }
            if(this[factoryFnName])
                model = this[factoryFnName].call(this, jsonModel);


            if(!model && xfalib.script.dom[elClass]){
                model = new xfalib.script.dom[elClass]({"jsonModel" : jsonModel});
            }

            if(!model) {
                model = new xfalib.script.Node({"jsonModel" : jsonModel});
            }
            return model;
        },

        createXfa : function(json){
            return new xfalib.script.Xfa({"jsonModel" : json});
        },

        createForm : function(json){
            return new xfalib.script.Form({"jsonModel" : json});
        },

        createConfig : function(json){
            return json;      //No seperate model API for config for now
        },

        createTextField : function(field) {
            return new xfalib.script.Field({"jsonModel" : field});
        },

        createImageField : function(field) {
            return new xfalib.script.Field({"jsonModel" : field});
        },

        createDateTimeField : function(field) {
            return new xfalib.script.DateTimeField({"jsonModel" : field});
        },

        createNumericField : function(field) {
            return new xfalib.script.NumericField({"jsonModel" : field});
        },

        createChoiceListField : function(field) {
            return new xfalib.script.ChoiceListField({"jsonModel" : field});
        },

        createButtonField : function(field) {
            return new xfalib.script.ButtonField({"jsonModel" : field});
        },

        createCheckButtonField : function(field) {
            return new xfalib.script.CheckButtonField({"jsonModel" : field});
        },

        createTextDraw : function(draw) {
            return new xfalib.script.Draw({"jsonModel" : draw});
        },

        createInstanceManager : function(oInstanceManager) {
            return new xfalib.script.InstanceManager({"jsonModel" : oInstanceManager});
        },

        createPageSet: function(vPageSet) {
            return new xfalib.script.PageSet({"jsonModel" : vPageSet});
        },

        createPageArea: function(vPageArea) {
            return new xfalib.script.PageArea({"jsonModel" : vPageArea});
        },

        createContentArea: function(vContentArea) {
            return new xfalib.script.ContentArea({"jsonModel" : vContentArea});
        },

        createExclusionGroup : function(exclGroup) {
            return new xfalib.script.ExclusionGroup({"jsonModel" : exclGroup});
        },

        createSubform: function(vSubform) {
            return new xfalib.script.Subform({"jsonModel" : vSubform});
        },

        createArea: function(vArea) {
            return new xfalib.script.Area({"jsonModel" : vArea});
        },

        createSubformSet: function(vSubformSet) {
            return new xfalib.script.SubformSet({"jsonModel" : vSubformSet});
        },

        createVariables: function(vVariables) {
            return new xfalib.script.Variables({"jsonModel" : vVariables});
        },

        createScript: function(vScript) {
            if(vScript._parentClass && vScript._parentClass == "variables"){
                return new xfalib.script.dom.ScriptObject({"jsonModel" : vScript});
            }
            else {
                return new xfalib.script.dom.Script({"jsonModel" : vScript});
            }
        },

        createField : function(field) {
            var t = null;
            var childType = this.getOrElse(this.xfaUtil().getUiOneOfChildTag(field), "").toLowerCase();
            switch (childType) {
                case "datetimeedit":
                    t =this.createDateTimeField(field)
                    break;
                case "textedit":
                    t = this.createTextField(field);
                    break;
                case "imageedit":
                    t = this.createImageField(field);
                    break;
                case "numericedit":
                    t = this.createNumericField(field);
                    break;
                case "choicelist":
                    t = this.createChoiceListField(field);
                    break;
                case "button":
                    t = this.createButtonField(field);
                    break;
                case "checkbutton":
                    t = this.createCheckButtonField(field);
                    break;
                default:
                    //xfa.Logger.warn("unknown uiType for the field " + field.ui.type + " <"
                    //    + field.name + "> Creating a TextField instead");
                    t = this.createTextField(field);
                    break;
            }
            return t;
        },

        createDraw : function(draw) {
            var t = null;
            var childType = this.getOrElse(this.xfaUtil().getUiOneOfChildTag(draw), "").toLowerCase();
            switch (childType) {
                case "textedit":
                    t = this.createTextDraw(draw);
                    break;
                default:
                    //xfa.Logger.warn("unknown uiType for the draw " + draw.ui.type + " <"
                    //    + draw.name + "> Creating a Static Text instead");
                    t = this.createTextDraw(draw);
                    break;
            }
            return t;
        },

        createSomExpression : function(sExpression, nDefaultOccurrence, bIgnorePredicate) {
            var options = {
                expression : sExpression,
                defaultOccurrence : nDefaultOccurrence,
                ignorePredicate : bIgnorePredicate
            }
            return new xfalib.script.SOMExpression(options);
        },

        createValue: function(valueJson) {
            return new xfalib.script.dom.Value({"jsonModel" : valueJson});
        },

        createNodeValue : function(valueJson) {
            //ToDo : this is a stop grap measure till we find a way to handle default valueJson
            valueJson = valueJson || {_class: "", rawValue: ""};
            var valType = valueJson._class.toLowerCase();
            switch (valType) {
                case "text":
                    return new xfalib.script.TextValue({"jsonModel" : valueJson});
                case "integer":
                    return new xfalib.script.IntegerValue({"jsonModel" : valueJson});
                case "decimal":
                	return new xfalib.script.DecimalValue({"jsonModel" : valueJson});
                case "float":
                    return new xfalib.script.FloatValue({"jsonModel" : valueJson}); 
                case "exdata":
                    return new xfalib.script.ExDataValue({"jsonModel" : valueJson});
                case "date":
                    return new xfalib.script.DateValue({"jsonModel" : valueJson});
                case "image":
                    return new xfalib.script.ImageValue({"jsonModel" : valueJson});
                case "script":
                    return this.createScript(valueJson);
                default:
                    //xfa.Logger.warn("unknown value type " + valueJson.type + " for element <"
                    //    + this.name + ">");
                    return new xfalib.script.NodeValue({"jsonModel" : valueJson});
            }
        },

        createDataNode: function(id) {
            return new xfalib.script.DataNode({"jsonModel" : {"id":id}});
        }

    });

})(_, xfalib);
(function(_, xfalib){
    var App = xfalib.acrobat.App =  xfalib.ut.Class.extend({
        initialize : function() {
            App._super.initialize.call(this);
            xfalib.runtime.app = this;
            this._version = window.formBridge.getBridgeVersion();

        },

        alert: function(cMsg) {
            return window.alert(cMsg);
        },

        beep: function(nType) {

        },


        execDialog: function(dialog) {

        },

        launchURL: function(url, bNewFrame) {
            if(url.search("http") == -1)
                url = "http://" + url ;
            if(bNewFrame != true) {
                window.open(url) ;
            }
            else
                window.location = url;
        },

        setTimeOut: function(cExpr, nMilliseconds) {
            try {
                var fn = new Function(this._within(cExpr));
                return window.setTimeout(function() {
                     fn.call(xfalib.runtime.Document);
                }, nMilliseconds);
            } catch(ex) {
                console.log(ex);
            }
        },

        setInterval: function(cExpr, nMilliseconds) {
            try {
                var fn = new Function(this._within(cExpr));
                return window.setInterval(function() {
                    fn.call(xfalib.runtime.Document);
                }, nMilliseconds);
            } catch(ex) {
                console.log(ex);
            }
        },

        clearTimeOut: function(oTime) {
            window.clearTimeout(oTime);
        },

        clearInterval: function(oInterval) {
            window.clearInterval(oInterval);
        },

        eval: function(script) {
            window.eval(this._within(script));
        },

        _within: function(script){
            var string  =   "try {\n" +
                                "with(xfalib.runtime.Document) {\n" +
                                    "with(xfalib.runtime) {\n" +
                                        script +"\n" +
                                    "}\n" +
                                "}\n" +
                            "} catch(ex) {\n" +
                                "console.log(ex)\n" +
                            "}";
            return string;
        }

    });

    App.defineProps({
        "activeDocs" : {
            get : function() {
                return ([]);
            }
        },

        "calculate" : {
            get : function() {
                return (true);
            }
        },

        "constants" : {
            get : function() {
                return ({align:{}});
            }
        },

        "focusRect" : {
            get : function() {
                return (true);
            }
        },

        "formsVersion" : {
            get : function() {
                return (this._version);
            }
        },

        "fromPDFConverters" : {
            get : function() {
                return ([]);
            }
        },

        "fs" : {
            get : function() {
                return ({isFullScreen: false});
            }
        },

        "fullscreen" : {
            get : function() {
                return (false);
            }
        },

        "language" : {
            get : function() {
                if(navigator.language.substr(0,2) === "en")
                    return ("ENU");
                return ("ENU");
            }
        },

        "platform" : {
            get : function() {
                if(navigator.appVersion.indexOf("Win") != -1)
                    return ("WIN");
                if(navigator.appVersion.indexOf("Mac") != -1)
                    return ("MAC");
                return ("UNIX");
            }
        },

        "viewerType" : {
            get : function() {
                return ("Exchange-Pro");
            }
        },

        "viewerVariation" : {
            get : function() {
                return ("Full");
            }
        },

        "viewerVersion" : {
            get : function() {
                return (this._version);
            }
        }
    })

})(_, xfalib);

(function(_, xfalib){
    var Console = xfalib.acrobat.Console =  xfalib.ut.Class.extend({
        initialize : function(bRegister) {
            Console._super.initialize.call(this);
            if(bRegister)
                xfalib.runtime.console = this;
        },

        println: function() {
            //add this method to insert console where 'console' is not supported
        }
    });

})(_, xfalib);

(function(_, xfalib){
    var Acrobat = xfalib.acrobat.Acrobat =  xfalib.ut.Class.extend({
        initialize : function() {
            Acrobat._super.initialize.call(this);
            //initialize App object
            new xfalib.acrobat.App();
            //insert println inside console object
            if(typeof(console) != "undefined") {
                if(console.log)
                    console.println = console.log;
                else {
                    //register empty method
                    var con = new xfalib.acrobat.Console();
                    console.println = con.println;
                }
            }
            else {
                new xfalib.acrobat.Console(true);
            }
        }
    });

})(_, xfalib);

/**
 * Created with IntelliJ IDEA.
 * User: vdua
 * Date: 21/5/13
 * Time: 5:56 PM
 * To change this template use File | Settings | File Templates.

 /**
 * @package xfalib.script.XfaModelEvent
 * @import xfalib.script.Object
 * @fileOverview The file creates the XfaModelEvent Class required for XFA library
 * @version 0.0.1
 */
(function(_,xfalib) {

    var Field = xfalib.acrobat.Field = xfalib.ut.Class.extend({
        initialize : function() {
            Field._super.initialize.call(this);
            this._xfaField = xfalib.script.Xfa.Instance.resolveNode("xfa.form."+this.jsonModel.somExpression);
        },

        signatureInfo : function() {
            throw {message:"signatureInfo is not supported"}
        },

        setFocus: function() {
            xfalib.script.Xfa.Instance.host.setFocus(this.jsonModel.somExpression);
        }
    });

    Field.defineProps({

    })
})(_,xfalib);
/**
 * @package xfalib.script.XfaModelEvent
 * @import xfalib.script.Object
 * @fileOverview The file creates the XfaModelEvent Class required for XFA library
 * @version 0.0.1
 */
(function(_,xfalib) {

    var Doc = xfalib.acrobat.Doc = xfalib.ut.Class.extend({

        getURL: function() {
            return window.location.href;
        },

        resetForm: function(fieldArray) {
            if(!(fieldArray instanceof Array)) {
                fieldArray = [fieldArray];
            }
            this.xfa.host.resetData.apply(this.xfa.host,fieldArray);
        },

        submitForm: function() {
            this.xfa.Logger.error("xfa",xfalib.locale.LogMessages["ALC-FRM-901-006"],["submitForm"]);
        },

        getField: function(som) {
            return new xfalib.acrobat.Field({"jsonModel" : {"somExpression": som}});
        },

        importDataObject: function() {
            throw {message:"importDataObject is not supported"}
        }

    });

    Doc.defineProps({
        "xfa" : {
            get: function() {
                return xfalib.script.Xfa.Instance;
            }
        }

    })

    xfalib.runtime.Document = new xfalib.acrobat.Doc({jsonModel:{}});

})(_,xfalib);
/**
 * @package xfalib.script.XfaModelEvent
 * @import xfalib.script.Object
 * @fileOverview The file creates the XfaModelEvent Class required for XFA library
 * @version 0.0.1
 */
(function(_,xfalib) {

    var AcroEvent = xfalib.acrobat.AcroEvent = xfalib.script.XfaModelEvent.extend({
        msClassName: "acroEvent",
        initialize : function() {
            xfalib.script.XfaModelEvent._super.initialize.call(this);
            this.jsonModel.target = xfalib.runtime.Document;
        }
    });

    AcroEvent.cloneEvent = function(xfaModelEvent) {
        var copy = xfaModelEvent.copyObject(xfaModelEvent.jsonModel, {},{"exceptions":["target"]});
        return new AcroEvent({"jsonModel" : copy});
    };

})(_,xfalib);
(function (_, xfalib) {
    var AppearanceFilter = xfalib.script.dom.AppearanceFilter = xfalib.script.GenericText.extend({
        msClassName:"appearanceFilter"
    });

    AppearanceFilter.defineProps({
        type:{
            get:function () {
                return this.getAttribute("type");
            },
            set:function (value) {
                this.setAttribute(value, "type");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Assist = xfalib.script.dom.Assist = xfalib.script.DOMElement.extend({
        msClassName:"assist"
    });

    Assist.defineProps({
        role:{
            get:function () {
                return this.getAttribute("role");
            },
            set:function (value) {
                this.setAttribute(value, "role");
            }
        },
        speak:{
            get:function () {
                return this.getElement("speak", 0);
            },
            set:function (value) {
                this.setElement(value, "speak");
            }
        },
        toolTip:{
            get:function () {
                return this.getElement("toolTip", 0);
            },
            set:function (value) {
                this.setElement(value, "toolTip");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Barcode = xfalib.script.dom.Barcode = xfalib.script.DOMElement.extend({
        msClassName:"barcode"
    });

    Barcode.defineProps({
        charEncoding:{
            get:function () {
                return this.getAttribute("charEncoding");
            },
            set:function (value) {
                this.setAttribute(value, "charEncoding");
            }
        },
        checksum:{
            get:function () {
                return this.getAttribute("checksum");
            },
            set:function (value) {
                this.setAttribute(value, "checksum");
            }
        },
        dataColumnCount:{
            get:function () {
                return this.getAttribute("dataColumnCount");
            },
            set:function (value) {
                this.setAttribute(value, "dataColumnCount");
            }
        },
        dataLength:{
            get:function () {
                return this.getAttribute("dataLength");
            },
            set:function (value) {
                this.setAttribute(value, "dataLength");
            }
        },
        dataPrep:{
            get:function () {
                return this.getAttribute("dataPrep");
            },
            set:function (value) {
                this.setAttribute(value, "dataPrep");
            }
        },
        dataRowCount:{
            get:function () {
                return this.getAttribute("dataRowCount");
            },
            set:function (value) {
                this.setAttribute(value, "dataRowCount");
            }
        },
        endChar:{
            get:function () {
                return this.getAttribute("endChar");
            },
            set:function (value) {
                this.setAttribute(value, "endChar");
            }
        },
        errorCorrectionLevel:{
            get:function () {
                return this.getAttribute("errorCorrectionLevel");
            },
            set:function (value) {
                this.setAttribute(value, "errorCorrectionLevel");
            }
        },
        moduleHeight:{
            get:function () {
                return this.getAttribute("moduleHeight");
            },
            set:function (value) {
                this.setAttribute(value, "moduleHeight");
            }
        },
        moduleWidth:{
            get:function () {
                return this.getAttribute("moduleWidth");
            },
            set:function (value) {
                this.setAttribute(value, "moduleWidth");
            }
        },
        printCheckDigit:{
            get:function () {
                return this.getAttribute("printCheckDigit");
            },
            set:function (value) {
                this.setAttribute(value, "printCheckDigit");
            }
        },
        rowColumnRatio:{
            get:function () {
                return this.getAttribute("rowColumnRatio");
            },
            set:function (value) {
                this.setAttribute(value, "rowColumnRatio");
            }
        },
        startChar:{
            get:function () {
                return this.getAttribute("startChar");
            },
            set:function (value) {
                this.setAttribute(value, "startChar");
            }
        },
        textLocation:{
            get:function () {
                return this.getAttribute("textLocation");
            },
            set:function (value) {
                this.setAttribute(value, "textLocation");
            }
        },
        truncate:{
            get:function () {
                return this.getAttribute("truncate");
            },
            set:function (value) {
                this.setAttribute(value, "truncate");
            }
        },
        type:{
            get:function () {
                return this.getAttribute("type");
            },
            set:function (value) {
                this.setAttribute(value, "type");
            }
        },
        upsMode:{
            get:function () {
                return this.getAttribute("upsMode");
            },
            set:function (value) {
                this.setAttribute(value, "upsMode");
            }
        },
        wideNarrowRatio:{
            get:function () {
                return this.getAttribute("wideNarrowRatio");
            },
            set:function (value) {
                this.setAttribute(value, "wideNarrowRatio");
            }
        },
        encrypt:{
            get:function () {
                return this.getElement("encrypt", 0);
            },
            set:function (value) {
                this.setElement(value, "encrypt");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Bind = xfalib.script.dom.Bind = xfalib.script.DOMElement.extend({
        msClassName:"bind"
    });

    Bind.defineProps({
        match:{
            get:function () {
                return this.getAttribute("match");
            },
            set:function (value) {
                this.setAttribute(value, "match");
            }
        },
        ref:{
            get:function () {
                return this.getAttribute("ref");
            },
            set:function (value) {
                this.setAttribute(value, "ref");
            }
        },
        picture:{
            get:function () {
                return this.getElement("picture", 0);
            },
            set:function (value) {
                this.setElement(value, "picture");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var BindItems = xfalib.script.dom.BindItems = xfalib.script.GenericText.extend({
        msClassName:"bindItems"
    });

    BindItems.defineProps({
        connection:{
            get:function () {
                return this.getAttribute("connection");
            },
            set:function (value) {
                this.setAttribute(value, "connection");
            }
        },
        labelRef:{
            get:function () {
                return this.getAttribute("labelRef");
            },
            set:function (value) {
                this.setAttribute(value, "labelRef");
            }
        },
        ref:{
            get:function () {
                return this.getAttribute("ref");
            },
            set:function (value) {
                this.setAttribute(value, "ref");
            }
        },
        valueRef:{
            get:function () {
                return this.getAttribute("valueRef");
            },
            set:function (value) {
                this.setAttribute(value, "valueRef");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Bookend = xfalib.script.dom.Bookend = xfalib.script.GenericText.extend({
        msClassName:"bookend"
    });

    Bookend.defineProps({
        leader:{
            get:function () {
                return this.getAttribute("leader");
            },
            set:function (value) {
                this.setAttribute(value, "leader");
            }
        },
        trailer:{
            get:function () {
                return this.getAttribute("trailer");
            },
            set:function (value) {
                this.setAttribute(value, "trailer");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Border = xfalib.script.dom.Border = xfalib.script.DOMElement.extend({
        msClassName:"border",

        handleEvent: function (evnt) {
            if(evnt._property == 'edge.color.value') {
                //If the color is being set for first border edge, and the corner are rounded - set for all the edges
                //reason: In case of rounded corner, we divide the single edge into 4 edges, and thus when trying to set
                //the color for all of them together, only first is set - NPR-15444
                var isFirstIndex = evnt.target.parent.mnClassIndex == 0,
                    isRoundedBorder = !!(parseInt(this.corner.radius));
                if(isFirstIndex && isRoundedBorder) {
                    var index = 1,
                        edge;
                    while (edge = this.getElement('edge', index, true)) {
                        //set the value in case a different color has not been set for a different edge explicitly
                        edge.color.setAttribute(evnt.target.value,'value');
                        index++;
                    }
                }
            }
            Border._super.handleEvent.call(this, evnt);
        }
    });

    Border.defineProps({
        "break":{
            get:function () {
                return this.getAttribute("break");
            },
            set:function (value) {
                this.setAttribute(value, "break");
            }
        },
        hand:{
            get:function () {
                return this.getAttribute("hand");
            },
            set:function (value) {
                this.setAttribute(value, "hand");
            }
        },
        presence:{
            get:function () {
                return this.getAttribute("presence");
            },
            set:function (value) {
                this.setAttribute(value, "presence");
            }
        },
        relevant:{
            get:function () {
                return this.getAttribute("relevant");
            },
            set:function (value) {
                this.setAttribute(value, "relevant");
            }
        },
        corner:{
            get:function () {
                return this.getElement("corner", 0);
            },
            set:function (value) {
                this.setElement(value, "corner");
            }
        },
        edge:{
            get:function () {
                return this.getElement("edge", 0);
            },
            set:function (value) {
                this.setElement(value, "edge");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        },
        fill:{
            get:function () {
                return this.getElement("fill", 0);
            },
            set:function (value) {
                this.setElement(value, "fill");
            }
        },
        margin:{
            get:function () {
                return this.getElement("margin", 0);
            },
            set:function (value) {
                this.setElement(value, "margin");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Break = xfalib.script.dom.Break = xfalib.script.DOMElement.extend({
        msClassName:"break"
    });

    Break.defineProps({
        after:{
            get:function () {
                return this.getAttribute("after");
            },
            set:function (value) {
                this.setAttribute(value, "after");
            }
        },
        afterTarget:{
            get:function () {
                return this.getAttribute("afterTarget");
            },
            set:function (value) {
                this.setAttribute(value, "afterTarget");
            }
        },
        before:{
            get:function () {
                return this.getAttribute("before");
            },
            set:function (value) {
                this.setAttribute(value, "before");
            }
        },
        beforeTarget:{
            get:function () {
                return this.getAttribute("beforeTarget");
            },
            set:function (value) {
                this.setAttribute(value, "beforeTarget");
            }
        },
        bookendLeader:{
            get:function () {
                return this.getAttribute("bookendLeader");
            },
            set:function (value) {
                this.setAttribute(value, "bookendLeader");
            }
        },
        bookendTrailer:{
            get:function () {
                return this.getAttribute("bookendTrailer");
            },
            set:function (value) {
                this.setAttribute(value, "bookendTrailer");
            }
        },
        overflowLeader:{
            get:function () {
                return this.getAttribute("overflowLeader");
            },
            set:function (value) {
                this.setAttribute(value, "overflowLeader");
            }
        },
        overflowTarget:{
            get:function () {
                return this.getAttribute("overflowTarget");
            },
            set:function (value) {
                this.setAttribute(value, "overflowTarget");
            }
        },
        overflowTrailer:{
            get:function () {
                return this.getAttribute("overflowTrailer");
            },
            set:function (value) {
                this.setAttribute(value, "overflowTrailer");
            }
        },
        startNew:{
            get:function () {
                return this.getAttribute("startNew");
            },
            set:function (value) {
                this.setAttribute(value, "startNew");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var BreakAfter = xfalib.script.dom.BreakAfter = xfalib.script.DOMElement.extend({
        msClassName:"breakAfter"
    });

    BreakAfter.defineProps({
        leader:{
            get:function () {
                return this.getAttribute("leader");
            },
            set:function (value) {
                this.setAttribute(value, "leader");
            }
        },
        startNew:{
            get:function () {
                return this.getAttribute("startNew");
            },
            set:function (value) {
                this.setAttribute(value, "startNew");
            }
        },
        target:{
            get:function () {
                return this.getAttribute("target");
            },
            set:function (value) {
                this.setAttribute(value, "target");
            }
        },
        targetType:{
            get:function () {
                return this.getAttribute("targetType");
            },
            set:function (value) {
                this.setAttribute(value, "targetType");
            }
        },
        trailer:{
            get:function () {
                return this.getAttribute("trailer");
            },
            set:function (value) {
                this.setAttribute(value, "trailer");
            }
        },
        script:{
            get:function () {
                return this.getElement("script", 0);
            },
            set:function (value) {
                this.setElement(value, "script");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var BreakBefore = xfalib.script.dom.BreakBefore = xfalib.script.DOMElement.extend({
        msClassName:"breakBefore"
    });

    BreakBefore.defineProps({
        leader:{
            get:function () {
                return this.getAttribute("leader");
            },
            set:function (value) {
                this.setAttribute(value, "leader");
            }
        },
        startNew:{
            get:function () {
                return this.getAttribute("startNew");
            },
            set:function (value) {
                this.setAttribute(value, "startNew");
            }
        },
        target:{
            get:function () {
                return this.getAttribute("target");
            },
            set:function (value) {
                this.setAttribute(value, "target");
            }
        },
        targetType:{
            get:function () {
                return this.getAttribute("targetType");
            },
            set:function (value) {
                this.setAttribute(value, "targetType");
            }
        },
        trailer:{
            get:function () {
                return this.getAttribute("trailer");
            },
            set:function (value) {
                this.setAttribute(value, "trailer");
            }
        },
        script:{
            get:function () {
                return this.getElement("script", 0);
            },
            set:function (value) {
                this.setElement(value, "script");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Button = xfalib.script.dom.Button = xfalib.script.DOMElement.extend({
        msClassName:"button"
    });

    Button.defineProps({
        highlight:{
            get:function () {
                return this.getAttribute("highlight");
            },
            set:function (value) {
                this.setAttribute(value, "highlight");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Calculate = xfalib.script.dom.Calculate = xfalib.script.DOMElement.extend({
        msClassName:"calculate"
    });

    Calculate.defineProps({
        override:{
            get:function () {
                return this.getAttribute("override");
            },
            set:function (value) {
                this.setAttribute(value, "override");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        },
        message:{
            get:function () {
                return this.getElement("message", 0);
            },
            set:function (value) {
                this.setElement(value, "message");
            }
        },
        script:{
            get:function () {
                return this.getElement("script", 0);
            },
            set:function (value) {
                this.setElement(value, "script");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Caption = xfalib.script.dom.Caption = xfalib.script.DOMElement.extend({
        msClassName:"caption"
    });

    Caption.defineProps({
        placement:{
            get:function () {
                return this.getAttribute("placement");
            },
            set:function (value) {
                this.setAttribute(value, "placement");
            }
        },
        presence:{
            get:function () {
                return this.getAttribute("presence");
            },
            set:function (value) {
                this.setAttribute(value, "presence");
            }
        },
        reserve:{
            get:function () {
                return this.getAttribute("reserve");
            },
            set:function (value) {
                this.setAttribute(value, "reserve");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        },
        font:{
            get:function () {
                return this.getElement("font", 0);
            },
            set:function (value) {
                this.setElement(value, "font");
            }
        },
        margin:{
            get:function () {
                return this.getElement("margin", 0);
            },
            set:function (value) {
                this.setElement(value, "margin");
            }
        },
        para:{
            get:function () {
                return this.getElement("para", 0);
            },
            set:function (value) {
                this.setElement(value, "para");
            }
        },
        value:{
            get:function () {
                return this.getElement("value", 0);
            },
            set:function (value) {
                this.setElement(value, "value");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Certificate = xfalib.script.dom.Certificate = xfalib.script.GenericText.extend({
        msClassName:"certificate"
    });

    Certificate.defineProps({
    });

})(_, xfalib);
(function (_, xfalib) {
    var Certificates = xfalib.script.dom.Certificates = xfalib.script.DOMElement.extend({
        msClassName:"certificates"
    });

    Certificates.defineProps({
        credentialServerPolicy:{
            get:function () {
                return this.getAttribute("credentialServerPolicy");
            },
            set:function (value) {
                this.setAttribute(value, "credentialServerPolicy");
            }
        },
        url:{
            get:function () {
                return this.getAttribute("url");
            },
            set:function (value) {
                this.setAttribute(value, "url");
            }
        },
        urlPolicy:{
            get:function () {
                return this.getAttribute("urlPolicy");
            },
            set:function (value) {
                this.setAttribute(value, "urlPolicy");
            }
        },
        encryption:{
            get:function () {
                return this.getElement("encryption", 0);
            },
            set:function (value) {
                this.setElement(value, "encryption");
            }
        },
        issuers:{
            get:function () {
                return this.getElement("issuers", 0);
            },
            set:function (value) {
                this.setElement(value, "issuers");
            }
        },
        keyUsage:{
            get:function () {
                return this.getElement("keyUsage", 0);
            },
            set:function (value) {
                this.setElement(value, "keyUsage");
            }
        },
        oids:{
            get:function () {
                return this.getElement("oids", 0);
            },
            set:function (value) {
                this.setElement(value, "oids");
            }
        },
        signing:{
            get:function () {
                return this.getElement("signing", 0);
            },
            set:function (value) {
                this.setElement(value, "signing");
            }
        },
        subjectDNs:{
            get:function () {
                return this.getElement("subjectDNs", 0);
            },
            set:function (value) {
                this.setElement(value, "subjectDNs");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var CheckButton = xfalib.script.dom.CheckButton = xfalib.script.DOMElement.extend({
        msClassName:"checkButton"
    });

    CheckButton.defineProps({
        allowNeutral:{
            get:function () {
                return this.getAttribute("allowNeutral");
            },
            set:function (value) {
                this.setAttribute(value, "allowNeutral");
                var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.DOM_CHANGED,this,"allowNeutral",value, null);
                this.trigger(evnt.name,evnt);
            }
        },
        mark:{
            get:function () {
                return this.getAttribute("mark");
            },
            set:function (value) {
                this.setAttribute(value, "mark");
            }
        },
        shape:{
            get:function () {
                return this.getAttribute("shape");
            },
            set:function (value) {
                this.setAttribute(value, "shape");
            }
        },
        size:{
            get:function () {
                return this.getAttribute("size");
            },
            set:function (value) {
                this.setAttribute(value, "size");
            }
        },
        border:{
            get:function () {
                return this.getElement("border", 0);
            },
            set:function (value) {
                this.setElement(value, "border");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        },
        margin:{
            get:function () {
                return this.getElement("margin", 0);
            },
            set:function (value) {
                this.setElement(value, "margin");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var ChoiceList = xfalib.script.dom.ChoiceList = xfalib.script.DOMElement.extend({
        msClassName:"choiceList"
    });

    ChoiceList.defineProps({
        commitOn:{
            get:function () {
                return this.getAttribute("commitOn");
            },
            set:function (value) {
                this.setAttribute(value, "commitOn");
            }
        },
        open:{
            get:function () {
                return this.getAttribute("open");
            },
            set:function (value) {
                this.setAttribute(value, "open");
            }
        },
        textEntry:{
            get:function () {
                return this.getAttribute("textEntry");
            },
            set:function (value) {
                this.setAttribute(value, "textEntry");
            }
        },
        border:{
            get:function () {
                return this.getElement("border", 0);
            },
            set:function (value) {
                this.setElement(value, "border");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        },
        margin:{
            get:function () {
                return this.getElement("margin", 0);
            },
            set:function (value) {
                this.setElement(value, "margin");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Color = xfalib.script.dom.Color = xfalib.script.DOMElement.extend({
        msClassName:"color"
    });

    Color.defineProps({
        cSpace:{
            get:function () {
                return this.getAttribute("cSpace");
            },
            set:function (value) {
                this.setAttribute(value, "cSpace");
            }
        },
        value:{
            get:function () {
                return this.getAttribute("value");
            },
            set:function (value) {
                this.setAttribute(value, "value");
                var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.DOM_CHANGED,
                    this,"color.value",value, null);
                this.trigger(evnt.name,evnt);
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Comb = xfalib.script.dom.Comb = xfalib.script.GenericText.extend({
        msClassName:"comb"
    });

    Comb.defineProps({
        numberOfCells:{
            get:function () {
                return this.getAttribute("numberOfCells");
            },
            set:function (value) {
                this.setAttribute(value, "numberOfCells");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Connect = xfalib.script.dom.Connect = xfalib.script.DOMElement.extend({
        msClassName:"connect"
    });

    Connect.defineProps({
        connection:{
            get:function () {
                return this.getAttribute("connection");
            },
            set:function (value) {
                this.setAttribute(value, "connection");
            }
        },
        ref:{
            get:function () {
                return this.getAttribute("ref");
            },
            set:function (value) {
                this.setAttribute(value, "ref");
            }
        },
        usage:{
            get:function () {
                return this.getAttribute("usage");
            },
            set:function (value) {
                this.setAttribute(value, "usage");
            }
        },
        picture:{
            get:function () {
                return this.getElement("picture", 0);
            },
            set:function (value) {
                this.setElement(value, "picture");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Corner = xfalib.script.dom.Corner = xfalib.script.DOMElement.extend({
        msClassName:"corner"
    });

    Corner.defineProps({
        inverted:{
            get:function () {
                return this.getAttribute("inverted");
            },
            set:function (value) {
                this.setAttribute(value, "inverted");
            }
        },
        join:{
            get:function () {
                return this.getAttribute("join");
            },
            set:function (value) {
                this.setAttribute(value, "join");
            }
        },
        presence:{
            get:function () {
                return this.getAttribute("presence");
            },
            set:function (value) {
                this.setAttribute(value, "presence");
            }
        },
        radius:{
            get:function () {
                return this.getAttribute("radius");
            },
            set:function (value) {
                this.setAttribute(value, "radius");
            }
        },
        stroke:{
            get:function () {
                return this.getAttribute("stroke");
            },
            set:function (value) {
                this.setAttribute(value, "stroke");
            }
        },
        thickness:{
            get:function () {
                return this.getAttribute("thickness");
            },
            set:function (value) {
                this.setAttribute(value, "thickness");
            }
        },
        color:{
            get:function () {
                return this.getElement("color", 0);
            },
            set:function (value) {
                this.setElement(value, "color");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var DateTimeEdit = xfalib.script.dom.DateTimeEdit = xfalib.script.DOMElement.extend({
        msClassName:"dateTimeEdit"
    });

    DateTimeEdit.defineProps({
        hScrollPolicy:{
            get:function () {
                return this.getAttribute("hScrollPolicy");
            },
            set:function (value) {
                this.setAttribute(value, "hScrollPolicy");
            }
        },
        picker:{
            get:function () {
                return this.getAttribute("picker");
            },
            set:function (value) {
                this.setAttribute(value, "picker");
            }
        },
        border:{
            get:function () {
                return this.getElement("border", 0);
            },
            set:function (value) {
                this.setElement(value, "border");
            }
        },
        comb:{
            get:function () {
                return this.getElement("comb", 0);
            },
            set:function (value) {
                this.setElement(value, "comb");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        },
        margin:{
            get:function () {
                return this.getElement("margin", 0);
            },
            set:function (value) {
                this.setElement(value, "margin");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var DefaultUi = xfalib.script.dom.DefaultUi = xfalib.script.DOMElement.extend({
        msClassName:"defaultUi"
    });

    DefaultUi.defineProps({
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        }
    });

})(_, xfalib);
(function(_,xfalib){
    var Desc = xfalib.script.dom.Desc = xfalib.script.DOMElement.extend({
        msClassName: "desc"
    });

})(_,xfalib);
(function (_, xfalib) {
    var DigestMethod = xfalib.script.dom.DigestMethod = xfalib.script.GenericText.extend({
        msClassName:"digestMethod"
    });

    DigestMethod.defineProps({
    });

})(_, xfalib);
(function (_, xfalib) {
    var DigestMethods = xfalib.script.dom.DigestMethods = xfalib.script.DOMElement.extend({
        msClassName:"digestMethods"
    });

    DigestMethods.defineProps({
        "type":{
            get:function () {
                return this.getAttribute("type");
            },
            set:function (value) {
                this.setAttribute(value, "type");
            }
        }

    });

})(_, xfalib);
(function (_, xfalib) {
    var Edge = xfalib.script.dom.Edge = xfalib.script.DOMElement.extend({
        msClassName:"edge"
    });

    Edge.defineProps({
        cap:{
            get:function () {
                return this.getAttribute("cap");
            },
            set:function (value) {
                this.setAttribute(value, "cap");
            }
        },
        presence:{
            get:function () {
                return this.getAttribute("presence");
            },
            set:function (value) {
                this.setAttribute(value, "presence");
                var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.DOM_CHANGED,
                    this,"edge.presence",value, null);
                this.trigger(evnt.name,evnt);
            }
        },
        stroke:{
            get:function () {
                return this.getAttribute("stroke");
            },
            set:function (value) {
                this.setAttribute(value, "stroke");
            }
        },
        thickness:{
            get:function () {
                return this.getAttribute("thickness");
            },
            set:function (value) {
                this.setAttribute(value, "thickness");
                var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.DOM_CHANGED,
                    this,"edge.thickness",value, null);
                this.trigger(evnt.name,evnt);
            }
        },
        color:{
            get:function () {
                return this.getElement("color", 0);
            },
            set:function (value) {
                this.setElement(value, "color");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Encoding = xfalib.script.dom.Encoding = xfalib.script.GenericText.extend({
        msClassName:"encoding"
    });

    Encoding.defineProps({
    });

})(_, xfalib);
(function (_, xfalib) {
    var Encodings = xfalib.script.dom.Encodings = xfalib.script.DOMElement.extend({
        msClassName:"encodings"
    });

    Encodings.defineProps({
        "type":{
            get:function () {
                return this.getAttribute("type");
            },
            set:function (value) {
                this.setAttribute(value, "type");
            }
        }

    });

})(_, xfalib);
(function (_, xfalib) {
    var Encrypt = xfalib.script.dom.Encrypt = xfalib.script.DOMElement.extend({
        msClassName:"encrypt"
    });

    Encrypt.defineProps({
        certificate:{
            get:function () {
                return this.getElement("certificate", 0);
            },
            set:function (value) {
                this.setElement(value, "certificate");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var EncryptData = xfalib.script.dom.EncryptData = xfalib.script.DOMElement.extend({
        msClassName:"encryptData"
    });

    EncryptData.defineProps({
        operation:{
            get:function () {
                return this.getAttribute("operation");
            },
            set:function (value) {
                this.setAttribute(value, "operation");
            }
        },
        target:{
            get:function () {
                return this.getAttribute("target");
            },
            set:function (value) {
                this.setAttribute(value, "target");
            }
        },
        filter:{
            get:function () {
                return this.getElement("filter", 0);
            },
            set:function (value) {
                this.setElement(value, "filter");
            }
        },
        manifest:{
            get:function () {
                return this.getElement("manifest", 0);
            },
            set:function (value) {
                this.setElement(value, "manifest");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Encryption = xfalib.script.dom.Encryption = xfalib.script.DOMElement.extend({
        msClassName:"encryption"
    });

    Encryption.defineProps({
        type:{
            get:function () {
                return this.getAttribute("type");
            },
            set:function (value) {
                this.setAttribute(value, "type");
            }
        }

    });

})(_, xfalib);
(function (_, xfalib) {
    var EncryptionMethod = xfalib.script.dom.EncryptionMethod = xfalib.script.GenericText.extend({
        msClassName:"encryptionMethod"
    });

})(_, xfalib);
(function (_, xfalib) {
    var EncryptionMethods = xfalib.script.dom.EncryptionMethods = xfalib.script.DOMElement.extend({
        msClassName:"encryptionMethods"
    });

    EncryptionMethods.defineProps({
        "type":{
            get:function () {
                return this.getAttribute("type");
            },
            set:function (value) {
                this.setAttribute(value, "type");
            }
        }

    });

})(_, xfalib);
(function (_, xfalib) {
    var Event = xfalib.script.dom.Event = xfalib.script.DOMElement.extend({
        msClassName:"event"
    });

    Event.defineProps({
        activity:{
            get:function () {
                return this.getAttribute("activity");
            },
            set:function (value) {
                this.setAttribute(value, "activity");
            }
        },
        listen:{
            get:function () {
                return this.getAttribute("listen");
            },
            set:function (value) {
                this.setAttribute(value, "listen");
            }
        },
        ref:{
            get:function () {
                return this.getAttribute("ref");
            },
            set:function (value) {
                this.setAttribute(value, "ref");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        },
        encryptData:{
            get:function () {
                return this.getElement("encryptData", 0);
            },
            set:function (value) {
                this.setElement(value, "encryptData");
            }
        },
        execute:{
            get:function () {
                return this.getElement("execute", 0);
            },
            set:function (value) {
                this.setElement(value, "execute");
            }
        },
        script:{
            get:function () {
                return this.getElement("script", 0);
            },
            set:function (value) {
                this.setElement(value, "script");
            }
        },
        signData:{
            get:function () {
                return this.getElement("signData", 0);
            },
            set:function (value) {
                this.setElement(value, "signData");
            }
        },
        submit:{
            get:function () {
                return this.getElement("submit", 0);
            },
            set:function (value) {
                this.setElement(value, "submit");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Execute = xfalib.script.dom.Execute = xfalib.script.GenericText.extend({
        msClassName:"execute"
    });

    Execute.defineProps({
        connection:{
            get:function () {
                return this.getAttribute("connection");
            },
            set:function (value) {
                this.setAttribute(value, "connection");
            }
        },
        executeType:{
            get:function () {
                return this.getAttribute("executeType");
            },
            set:function (value) {
                this.setAttribute(value, "executeType");
            }
        },
        runAt:{
            get:function () {
                return this.getAttribute("runAt");
            },
            set:function (value) {
                this.setAttribute(value, "runAt");
            }
        }
    });

})(_, xfalib);
(function(_,xfalib){
    var Extras = xfalib.script.dom.Extras = xfalib.script.DOMElement.extend({
        msClassName: "extras"
    });

})(_,xfalib);
(function (_, xfalib) {
    var Fill = xfalib.script.dom.Fill = xfalib.script.DOMElement.extend({
        msClassName:"fill"
    });

    Fill.defineProps({
        presence:{
            get:function () {
                return this.getAttribute("presence");
            },
            set:function (value) {
                this.setAttribute(value, "presence");
                var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.DOM_CHANGED,
                    this,"fill.presence",value, null);
                this.trigger(evnt.name,evnt);
            }
        },
        color:{
            get:function () {
                return this.getElement("color", 0);
            },
            set:function (value) {
                this.setElement(value, "color");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        },
        linear:{
            get:function () {
                return this.getElement("linear", 0);
            },
            set:function (value) {
                this.setElement(value, "linear");
            }
        },
        pattern:{
            get:function () {
                return this.getElement("pattern", 0);
            },
            set:function (value) {
                this.setElement(value, "pattern");
            }
        },
        radial:{
            get:function () {
                return this.getElement("radial", 0);
            },
            set:function (value) {
                this.setElement(value, "radial");
            }
        },
        solid:{
            get:function () {
                return this.getElement("solid", 0);
            },
            set:function (value) {
                this.setElement(value, "solid");
            }
        },
        stipple:{
            get:function () {
                return this.getElement("stipple", 0);
            },
            set:function (value) {
                this.setElement(value, "stipple");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Filter = xfalib.script.dom.Filter = xfalib.script.DOMElement.extend({
        msClassName:"filter"
    });

    Filter.defineProps({
        addRevocationInfo:{
            get:function () {
                return this.getAttribute("addRevocationInfo");
            },
            set:function (value) {
                this.setAttribute(value, "addRevocationInfo");
            }
        },
        version:{
            get:function () {
                return this.getAttribute("version");
            },
            set:function (value) {
                this.setAttribute(value, "version");
            }
        },
        appearanceFilter:{
            get:function () {
                return this.getElement("appearanceFilter", 0);
            },
            set:function (value) {
                this.setElement(value, "appearanceFilter");
            }
        },
        certificates:{
            get:function () {
                return this.getElement("certificates", 0);
            },
            set:function (value) {
                this.setElement(value, "certificates");
            }
        },
        digestMethods:{
            get:function () {
                return this.getElement("digestMethods", 0);
            },
            set:function (value) {
                this.setElement(value, "digestMethods");
            }
        },
        encodings:{
            get:function () {
                return this.getElement("encodings", 0);
            },
            set:function (value) {
                this.setElement(value, "encodings");
            }
        },
        encryptionMethods:{
            get:function () {
                return this.getElement("encryptionMethods", 0);
            },
            set:function (value) {
                this.setElement(value, "encryptionMethods");
            }
        },
        handler:{
            get:function () {
                return this.getElement("handler", 0);
            },
            set:function (value) {
                this.setElement(value, "handler");
            }
        },
        lockDocument:{
            get:function () {
                return this.getElement("lockDocument", 0);
            },
            set:function (value) {
                this.setElement(value, "lockDocument");
            }
        },
        mdp:{
            get:function () {
                return this.getElement("mdp", 0);
            },
            set:function (value) {
                this.setElement(value, "mdp");
            }
        },
        reasons:{
            get:function () {
                return this.getElement("reasons", 0);
            },
            set:function (value) {
                this.setElement(value, "reasons");
            }
        },
        timeStamp:{
            get:function () {
                return this.getElement("timeStamp", 0);
            },
            set:function (value) {
                this.setElement(value, "timeStamp");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Font = xfalib.script.dom.Font = xfalib.script.DOMElement.extend({
        msClassName:"font"
    });

    Font.defineProps({
        baselineShift:{
            get:function () {
                return this.getAttribute("baselineShift");
            },
            set:function (value) {
                this.setAttribute(value, "baselineShift");
            }
        },
        fontHorizontalScale:{
            get:function () {
                return this.getAttribute("fontHorizontalScale");
            },
            set:function (value) {
                this.setAttribute(value, "fontHorizontalScale");
            }
        },
        fontVerticalScale:{
            get:function () {
                return this.getAttribute("fontVerticalScale");
            },
            set:function (value) {
                this.setAttribute(value, "fontVerticalScale");
            }
        },
        kerningMode:{
            get:function () {
                return this.getAttribute("kerningMode");
            },
            set:function (value) {
                this.setAttribute(value, "kerningMode");
            }
        },
        letterSpacing:{
            get:function () {
                return this.getAttribute("letterSpacing");
            },
            set:function (value) {
                this.setAttribute(value, "letterSpacing");
            }
        },
        lineThrough:{
            get:function () {
                return this.getAttribute("lineThrough");
            },
            set:function (value) {
                this.setAttribute(value, "lineThrough");
            }
        },
        lineThroughPeriod:{
            get:function () {
                return this.getAttribute("lineThroughPeriod");
            },
            set:function (value) {
                this.setAttribute(value, "lineThroughPeriod");
            }
        },
        overline:{
            get:function () {
                return this.getAttribute("overline");
            },
            set:function (value) {
                this.setAttribute(value, "overline");
            }
        },
        overlinePeriod:{
            get:function () {
                return this.getAttribute("overlinePeriod");
            },
            set:function (value) {
                this.setAttribute(value, "overlinePeriod");
            }
        },
        posture:{
            get:function () {
                return this.getAttribute("posture");
            },
            set:function (value) {
                this.setAttribute(value, "posture");
                var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.DOM_CHANGED,
                    this, "font.posture", value, null);
                this.trigger(evnt.name, evnt);
            }
        },
        size:{
            get:function () {
                return this.getAttribute("size");
            },
            set:function (value) {
                this.setAttribute(value, "size");
            }
        },
        typeface:{
            get:function () {
                return this.getAttribute("typeface");
            },
            set:function (value) {
                this.setAttribute(value, "typeface");
            }
        },
        underline:{
            get:function () {
                return this.getAttribute("underline");
            },
            set:function (value) {
                this.setAttribute(value, "underline");
            }
        },
        underlinePeriod:{
            get:function () {
                return this.getAttribute("underlinePeriod");
            },
            set:function (value) {
                this.setAttribute(value, "underlinePeriod");
            }
        },
        weight:{
            get:function () {
                return this.getAttribute("weight");
            },
            set:function (value) {
                this.setAttribute(value, "weight");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        },
        fill:{
            get:function () {
                return this.getElement("fill", 0);
            },
            set:function (value) {
                this.setElement(value, "fill");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Format = xfalib.script.dom.Format = xfalib.script.DOMElement.extend({
        msClassName:"format"
    });

    Format.defineProps({
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        },
        picture:{
            get:function () {
                return this.getElement("picture", 0);
            },
            set:function (value) {
                this.setElement(value, "picture");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Handler = xfalib.script.dom.Handler = xfalib.script.GenericText.extend({
        msClassName:"handler"
    });

    Handler.defineProps({
        type:{
            get:function () {
                return this.getAttribute("type");
            },
            set:function (value) {
                this.setAttribute(value, "type");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Hyphenation = xfalib.script.dom.Hyphenation = xfalib.script.GenericText.extend({
        msClassName:"hyphenation"
    });

    Hyphenation.defineProps({
        excludeAllCaps:{
            get:function () {
                return this.getAttribute("excludeAllCaps");
            },
            set:function (value) {
                this.setAttribute(value, "excludeAllCaps");
            }
        },
        excludeInitialCap:{
            get:function () {
                return this.getAttribute("excludeInitialCap");
            },
            set:function (value) {
                this.setAttribute(value, "excludeInitialCap");
            }
        },
        hyphenate:{
            get:function () {
                return this.getAttribute("hyphenate");
            },
            set:function (value) {
                this.setAttribute(value, "hyphenate");
            }
        },
        ladderCount:{
            get:function () {
                return this.getAttribute("ladderCount");
            },
            set:function (value) {
                this.setAttribute(value, "ladderCount");
            }
        },
        pushCharacterCount:{
            get:function () {
                return this.getAttribute("pushCharacterCount");
            },
            set:function (value) {
                this.setAttribute(value, "pushCharacterCount");
            }
        },
        remainCharacterCount:{
            get:function () {
                return this.getAttribute("remainCharacterCount");
            },
            set:function (value) {
                this.setAttribute(value, "remainCharacterCount");
            }
        },
        wordCharacterCount:{
            get:function () {
                return this.getAttribute("wordCharacterCount");
            },
            set:function (value) {
                this.setAttribute(value, "wordCharacterCount");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var ImageEdit = xfalib.script.dom.ImageEdit = xfalib.script.DOMElement.extend({
        msClassName:"imageEdit"
    });

    ImageEdit.defineProps({
        data:{
            get:function () {
                return this.getAttribute("data");
            },
            set:function (value) {
                this.setAttribute(value, "data");
            }
        },
        border:{
            get:function () {
                return this.getElement("border", 0);
            },
            set:function (value) {
                this.setElement(value, "border");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        },
        margin:{
            get:function () {
                return this.getElement("margin", 0);
            },
            set:function (value) {
                this.setElement(value, "margin");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Issuers = xfalib.script.dom.Issuers = xfalib.script.DOMElement.extend({
        msClassName:"issuers"
    });

    Issuers.defineProps({
        "type":{
            get:function () {
                return this.getAttribute("type");
            },
            set:function (value) {
                this.setAttribute(value, "type");
            }
        }

    });

})(_, xfalib);
(function (_, xfalib) {
    var Items = xfalib.script.dom.Items = xfalib.script.DOMElement.extend({
        _defaults: {
            "save": "0"
        },

        msClassName: "items",
        initialize: function () {
            Items._super.initialize.call(this);
        },

        _computeJsonDiff: function (diff_level) {

            /*
             * always return <items> - bug#3621898
             * In case of final submission, don't send Items
             */
            return diff_level === 2 ? {
                "changed": false,
                jsonDifference: {}
            } : {
                "changed": true,
                jsonDifference: this.jsonModel
            };
        }

    });

    Items.defineProps({
        "save": {
            get: function () {
                return this.getAttribute("save");
            }
        }
    });

    Items.addMixins([
        xfalib.script.mixin.AddPresence
    ]);
})(_, xfalib);

(function (_, xfalib) {
    var Keep = xfalib.script.dom.Keep = xfalib.script.DOMElement.extend({
        msClassName:"keep"
    });

    Keep.defineProps({
        intact:{
            get:function () {
                return this.getAttribute("intact");
            },
            set:function (value) {
                this.setAttribute(value, "intact");
            }
        },
        next:{
            get:function () {
                return this.getAttribute("next");
            },
            set:function (value) {
                this.setAttribute(value, "next");
            }
        },
        previous:{
            get:function () {
                return this.getAttribute("previous");
            },
            set:function (value) {
                this.setAttribute(value, "previous");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var KeyUsage = xfalib.script.dom.KeyUsage = xfalib.script.GenericText.extend({
        msClassName:"keyUsage"
    });

    KeyUsage.defineProps({
        crlSign:{
            get:function () {
                return this.getAttribute("crlSign");
            },
            set:function (value) {
                this.setAttribute(value, "crlSign");
            }
        },
        dataEncipherment:{
            get:function () {
                return this.getAttribute("dataEncipherment");
            },
            set:function (value) {
                this.setAttribute(value, "dataEncipherment");
            }
        },
        decipherOnly:{
            get:function () {
                return this.getAttribute("decipherOnly");
            },
            set:function (value) {
                this.setAttribute(value, "decipherOnly");
            }
        },
        digitalSignature:{
            get:function () {
                return this.getAttribute("digitalSignature");
            },
            set:function (value) {
                this.setAttribute(value, "digitalSignature");
            }
        },
        encipherOnly:{
            get:function () {
                return this.getAttribute("encipherOnly");
            },
            set:function (value) {
                this.setAttribute(value, "encipherOnly");
            }
        },
        keyAgreement:{
            get:function () {
                return this.getAttribute("keyAgreement");
            },
            set:function (value) {
                this.setAttribute(value, "keyAgreement");
            }
        },
        keyCertSign:{
            get:function () {
                return this.getAttribute("keyCertSign");
            },
            set:function (value) {
                this.setAttribute(value, "keyCertSign");
            }
        },
        keyEncipherment:{
            get:function () {
                return this.getAttribute("keyEncipherment");
            },
            set:function (value) {
                this.setAttribute(value, "keyEncipherment");
            }
        },
        nonRepudiation:{
            get:function () {
                return this.getAttribute("nonRepudiation");
            },
            set:function (value) {
                this.setAttribute(value, "nonRepudiation");
            }
        },
        type:{
            get:function () {
                return this.getAttribute("type");
            },
            set:function (value) {
                this.setAttribute(value, "type");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Linear = xfalib.script.dom.Linear = xfalib.script.DOMElement.extend({
        msClassName:"linear"
    });

    Linear.defineProps({
        type:{
            get:function () {
                return this.getAttribute("type");
            },
            set:function (value) {
                this.setAttribute(value, "type");
            }
        },
        color:{
            get:function () {
                return this.getElement("color", 0);
            },
            set:function (value) {
                this.setElement(value, "color");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var LockDocument = xfalib.script.dom.LockDocument = xfalib.script.GenericText.extend({
        msClassName:"lockDocument"
    });

    LockDocument.defineProps({
        type:{
            get:function () {
                return this.getAttribute("type");
            },
            set:function (value) {
                this.setAttribute(value, "type");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Manifest = xfalib.script.dom.Manifest = xfalib.script.DOMElement.extend({
        msClassName:"manifest"
    });

    Manifest.defineProps({
        action:{
            get:function () {
                return this.getAttribute("action");
            },
            set:function (value) {
                this.setAttribute(value, "action");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        }

    });

})(_, xfalib);
(function (_, xfalib) {
    var Margin = xfalib.script.dom.Margin = xfalib.script.DOMElement.extend({
        msClassName:"margin"
    });

    Margin.defineProps({
        bottomInset:{
            get:function () {
                return this.getAttribute("bottomInset");
            },
            set:function (value) {
                this.setAttribute(value, "bottomInset");
                var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.DOM_CHANGED,
                    this,"bottomInset",value, null);
                this.trigger(evnt.name,evnt);
            }
        },
        leftInset:{
            get:function () {
                return this.getAttribute("leftInset");
            },
            set:function (value) {
                this.setAttribute(value, "leftInset");
                var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.DOM_CHANGED,
                    this,"leftInset",value, null);
                this.trigger(evnt.name,evnt);
            }
        },
        rightInset:{
            get:function () {
                return this.getAttribute("rightInset");
            },
            set:function (value) {
                this.setAttribute(value, "rightInset");
                var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.DOM_CHANGED,
                    this,"rightInset",value, null);
                this.trigger(evnt.name,evnt);
            }
        },
        topInset:{
            get:function () {
                return this.getAttribute("topInset");
            },
            set:function (value) {
                this.setAttribute(value, "topInset");
                var evnt = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.DOM_CHANGED,
                    this,"topInset",value, null);
                this.trigger(evnt.name,evnt);
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Mdp = xfalib.script.dom.Mdp = xfalib.script.GenericText.extend({
        msClassName:"mdp"
    });

    Mdp.defineProps({
        permissions:{
            get:function () {
                return this.getAttribute("permissions");
            },
            set:function (value) {
                this.setAttribute(value, "permissions");
            }
        },
        signatureType:{
            get:function () {
                return this.getAttribute("signatureType");
            },
            set:function (value) {
                this.setAttribute(value, "signatureType");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Medium = xfalib.script.dom.Medium = xfalib.script.GenericText.extend({
        msClassName:"medium"
    });

    Medium.defineProps({
        imagingBBox:{
            get:function () {
                return this.getAttribute("imagingBBox");
            },
            set:function (value) {
                this.setAttribute(value, "imagingBBox");
            }
        },
        "long":{
            get:function () {
                return this.getAttribute("long");
            },
            set:function (value) {
                this.setAttribute(value, "long");
            }
        },
        orientation:{
            get:function () {
                return this.getAttribute("orientation");
            },
            set:function (value) {
                this.setAttribute(value, "orientation");
            }
        },
        "short":{
            get:function () {
                return this.getAttribute("short");
            },
            set:function (value) {
                this.setAttribute(value, "short");
            }
        },
        stock:{
            get:function () {
                return this.getAttribute("stock");
            },
            set:function (value) {
                this.setAttribute(value, "stock");
            }
        },
        trayIn:{
            get:function () {
                return this.getAttribute("trayIn");
            },
            set:function (value) {
                this.setAttribute(value, "trayIn");
            }
        },
        trayOut:{
            get:function () {
                return this.getAttribute("trayOut");
            },
            set:function (value) {
                this.setAttribute(value, "trayOut");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Message = xfalib.script.dom.Message = xfalib.script.DOMElement.extend({
        msClassName:"message"
    });

})(_, xfalib);
(function (_, xfalib) {
    var NumericEdit = xfalib.script.dom.NumericEdit = xfalib.script.DOMElement.extend({
        msClassName:"numericEdit"
    });

    NumericEdit.defineProps({
        hScrollPolicy:{
            get:function () {
                return this.getAttribute("hScrollPolicy");
            },
            set:function (value) {
                this.setAttribute(value, "hScrollPolicy");
            }
        },
        border:{
            get:function () {
                return this.getElement("border", 0);
            },
            set:function (value) {
                this.setElement(value, "border");
            }
        },
        comb:{
            get:function () {
                return this.getElement("comb", 0);
            },
            set:function (value) {
                this.setElement(value, "comb");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        },
        margin:{
            get:function () {
                return this.getElement("margin", 0);
            },
            set:function (value) {
                this.setElement(value, "margin");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Occur = xfalib.script.dom.Occur = xfalib.script.DOMElement.extend({
        msClassName:"occur",
        playJson : function(pJsonModel) {

        }

    });

    Occur.defineProps({
        initial:{
            get:function () {
                return this.getAttribute("initial");
            },
            set:function (value) {
                this.setAttribute(value, "initial");
            }
        },
        max:{
            get:function () {
                return this.getAttribute("max");
            },
            set:function (value) {
                this.setAttribute(value, "max");
            }
        },
        min:{
            get:function () {
                return this.getAttribute("min");
            },
            set:function (value) {
                this.setAttribute(value, "min");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        },
        script:{
            get:function () {
                return this.getElement("script", 0);
            },
            set:function (value) {
                this.setElement(value, "script");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Oid = xfalib.script.dom.Oid = xfalib.script.GenericText.extend({
        msClassName:"oid"
    });

})(_, xfalib);
(function (_, xfalib) {
    var Oids = xfalib.script.dom.Oids = xfalib.script.DOMElement.extend({
        msClassName:"oids"
    });

    Oids.defineProps({
        "type":{
            get:function () {
                return this.getAttribute("type");
            },
            set:function (value) {
                this.setAttribute(value, "type");
            }
        }

    });

})(_, xfalib);
(function (_, xfalib) {
    var Overflow = xfalib.script.dom.Overflow = xfalib.script.GenericText.extend({
        msClassName:"overflow"
    });

    Overflow.defineProps({
        leader:{
            get:function () {
                return this.getAttribute("leader");
            },
            set:function (value) {
                this.setAttribute(value, "leader");
            }
        },
        target:{
            get:function () {
                return this.getAttribute("target");
            },
            set:function (value) {
                this.setAttribute(value, "target");
            }
        },
        trailer:{
            get:function () {
                return this.getAttribute("trailer");
            },
            set:function (value) {
                this.setAttribute(value, "trailer");
            }
        }
    });

})(_, xfalib);
(function(_,xfalib){
    var Para = xfalib.script.dom.Para = xfalib.script.DOMElement.extend({
        msClassName:"para"
    });

    Para.defineProps({
        hAlign : {
            get : function(){
                return this.getAttribute("hAlign");
            },
            set : function(value){
                this.setAttribute(value, "hAlign");
            }
        },

        lineHeight : {
            get : function(){
                return this.getAttribute("lineHeight");
            },
            set : function(value){
                this.setAttribute(value, "lineHeight");
            }
        },

        marginLeft : {
            get : function(){
                return this.getAttribute("marginLeft");
            },
            set : function(value){
                this.setAttribute(value, "marginLeft");
            }
        },

        marginRight : {
            get : function(){
                return this.getAttribute("marginRight");
            },
            set : function(value){
                this.setAttribute(value, "marginRight");
            }
        },

        orphans : {
            get : function(){
                return this.getAttribute("orphans");
            },
            set : function(value){
                this.setAttribute(value, "orphans");
            }
        },

        preserve : {
            get : function(){
                return this.getAttribute("preserve");
            },
            set : function(value){
                this.setAttribute(value, "preserve");
            }
        },

        radixOffset : {
            get : function(){
                return this.getAttribute("radixOffset");
            },
            set : function(value){
                this.setAttribute(value, "radixOffset");
            }
        },

        spaceAbove : {
            get : function(){
                return this.getAttribute("spaceAbove");
            },
            set : function(value){
                this.setAttribute(value, "spaceAbove");
            }
        },

        spaceBelow : {
            get : function(){
                return this.getAttribute("spaceBelow");
            },
            set : function(value){
                this.setAttribute(value, "spaceBelow");
            }
        },

        tabDefault : {
            get : function(){
                return this.getAttribute("tabDefault");
            },
            set : function(value){
                this.setAttribute(value, "tabDefault");
            }
        },

        tabStops : {
            get : function(){
                return this.getAttribute("tabStops");
            },
            set : function(value){
                this.setAttribute(value, "tabStops");
            }
        },

        textIndent : {
            get : function(){
                return this.getAttribute("textIndent");
            },
            set : function(value){
                this.setAttribute(value, "textIndent");
            }
        },

        vAlign : {
            get : function(){
                return this.getAttribute("vAlign");
            },
            set : function(value){
                this.setAttribute(value, "vAlign");
            }
        },

        widows : {
            get : function(){
                return this.getAttribute("widows");
            },
            set : function(value){
                this.setAttribute(value, "widows");
            }
        },

        wordSpacingMaximum : {
            get : function(){
                return this.getAttribute("wordSpacingMaximum");
            },
            set : function(value){
                this.setAttribute(value, "wordSpacingMaximum");
            }
        },

        wordSpacingMinimum : {
            get : function(){
                return this.getAttribute("wordSpacingMinimum");
            },
            set : function(value){
                this.setAttribute(value, "wordSpacingMinimum");
            }
        },

        wordSpacingOptimum : {
            get : function(){
                return this.getAttribute("wordSpacingOptimum");
            },
            set : function(value){
                this.setAttribute(value, "wordSpacingOptimum");
            }
        }
    });

})(_,xfalib);


(function (_, xfalib) {
    var PasswordEdit = xfalib.script.dom.PasswordEdit = xfalib.script.DOMElement.extend({
        msClassName:"passwordEdit"
    });

    PasswordEdit.defineProps({
        hScrollPolicy:{
            get:function () {
                return this.getAttribute("hScrollPolicy");
            },
            set:function (value) {
                this.setAttribute(value, "hScrollPolicy");
            }
        },
        passwordChar:{
            get:function () {
                return this.getAttribute("passwordChar");
            },
            set:function (value) {
                this.setAttribute(value, "passwordChar");
            }
        },
        border:{
            get:function () {
                return this.getElement("border", 0);
            },
            set:function (value) {
                this.setElement(value, "border");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        },
        margin:{
            get:function () {
                return this.getElement("margin", 0);
            },
            set:function (value) {
                this.setElement(value, "margin");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Pattern = xfalib.script.dom.Pattern = xfalib.script.DOMElement.extend({
        msClassName:"pattern"
    });

    Pattern.defineProps({
        type:{
            get:function () {
                return this.getAttribute("type");
            },
            set:function (value) {
                this.setAttribute(value, "type");
            }
        },
        color:{
            get:function () {
                return this.getElement("color", 0);
            },
            set:function (value) {
                this.setElement(value, "color");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Picture = xfalib.script.dom.Picture = xfalib.script.GenericText.extend({
        msClassName:"picture"
    });

    Picture.defineProps({
    });

})(_, xfalib);
(function (_, xfalib) {
    var Radial = xfalib.script.dom.Radial = xfalib.script.DOMElement.extend({
        msClassName:"radial"
    });

    Radial.defineProps({
        type:{
            get:function () {
                return this.getAttribute("type");
            },
            set:function (value) {
                this.setAttribute(value, "type");
            }
        },
        color:{
            get:function () {
                return this.getElement("color", 0);
            },
            set:function (value) {
                this.setElement(value, "color");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Reason = xfalib.script.dom.Reason = xfalib.script.GenericText.extend({
        msClassName:"reason"
    });

})(_, xfalib);
(function (_, xfalib) {
    var Reasons = xfalib.script.dom.Reasons = xfalib.script.DOMElement.extend({
        msClassName:"reasons"
    });

    Reasons.defineProps({
        type:{
            get:function () {
                return this.getAttribute("type");
            },
            set:function (value) {
                this.setAttribute(value, "type");
            }
        }

    });

})(_, xfalib);
(function (_, xfalib) {
    var Ref = xfalib.script.dom.Ref = xfalib.script.GenericText.extend({
        msClassName:"ref"
    });

    Ref.defineProps({
    });

})(_, xfalib);
(function (_, xfalib) {
    var RenderAs = xfalib.script.dom.RenderAs = xfalib.script.DOMElement.extend({
        msClassName:"renderAs"
    });

    RenderAs.defineProps({
        APIVersion:{
            get:function () {
                return this.getAttribute("APIVersion");
            },
            set:function (value) {
                this.setAttribute(value, "APIVersion");
            }
        },
        svg:{
            get:function () {
                return this.getElement("svg", 0);
            },
            set:function (value) {
                this.setElement(value, "svg");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Script = xfalib.script.dom.Script = xfalib.script.GenericText.extend({
        msClassName:"script"
    });

    Script.defineProps({
        binding:{
            get:function () {
                return this.getAttribute("binding");
            },
            set:function (value) {
                this.setAttribute(value, "binding");
            }
        },
        contentType:{
            get:function () {
                return this.getAttribute("contentType");
            },
            set:function (value) {
                this.setAttribute(value, "contentType");
            }
        },
        runAt:{
            get:function () {
                return this.getAttribute("runAt");
            },
            set:function (value) {
                this.setAttribute(value, "runAt");
            }
        },
        stateless:{
            get:function () {
                return this.getAttribute("stateless");
            },
            set:function (value) {
                this.setAttribute(value, "stateless");
            }
        }
    });

})(_, xfalib);
(function(_, xfalib){
    var ScriptObject = xfalib.script.dom.ScriptObject = xfalib.script.dom.Script.extend({
        msClassName: "script",
        initialize : function(){
            ScriptObject._super.initialize.call(this);
            this._scriptInitialized = false;
        },

        _getNakedThis : function(){
            if(!this._scriptInitialized){
                if(this.value){
                    try{
                        var oldScope = null;
                        if(this.parent.parent instanceof xfalib.script.EventContainerNode) {
                            oldScope = this.parent.parent._createNakedReferencesScope();
                        }
                        this._xfa()._pushContextNode(this);
                        with(this.parent.parent) { // the parent subform of script obj.
                            with(xfalib.runtime) {
                                //TODO: possible xss attack
                                (eval("("+this.value+")")).apply(this.parent.parent,[this]); // subform -> self, this -> baseobj / script Obj
                            }
                        }
                    } catch(exception){
                        var som = this._xfa().moContextNodes[0] ? this._xfa().moContextNodes[0].somExpression
                                                                : ""
                        this._xfa().Logger.error("xfa", xfalib.locale.LogMessages["ALC-FRM-901-015"],
                                                [exception.message, this.name,
                                                 this._xfa().event.name, som])
                    } finally {
                        if(oldScope != null) {
                            this.parent.parent._resetNakedReferencesScope(oldScope);
                        }
                        this._xfa()._popContextNode();
                    }
                }
                this._scriptInitialized = true;
            }
            return this;
        }

    });
})(_, xfalib);
(function (_, xfalib) {
    var SetProperty = xfalib.script.dom.SetProperty = xfalib.script.GenericText.extend({
        msClassName:"setProperty"
    });

    SetProperty.defineProps({
        connection:{
            get:function () {
                return this.getAttribute("connection");
            },
            set:function (value) {
                this.setAttribute(value, "connection");
            }
        },
        ref:{
            get:function () {
                return this.getAttribute("ref");
            },
            set:function (value) {
                this.setAttribute(value, "ref");
            }
        },
        target:{
            get:function () {
                return this.getAttribute("target");
            },
            set:function (value) {
                this.setAttribute(value, "target");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Signature = xfalib.script.dom.Signature = xfalib.script.DOMElement.extend({
        msClassName:"signature"
    });

    Signature.defineProps({
        type:{
            get:function () {
                return this.getAttribute("type");
            },
            set:function (value) {
                this.setAttribute(value, "type");
            }
        },
        border:{
            get:function () {
                return this.getElement("border", 0);
            },
            set:function (value) {
                this.setElement(value, "border");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        },
        filter:{
            get:function () {
                return this.getElement("filter", 0);
            },
            set:function (value) {
                this.setElement(value, "filter");
            }
        },
        manifest:{
            get:function () {
                return this.getElement("manifest", 0);
            },
            set:function (value) {
                this.setElement(value, "manifest");
            }
        },
        margin:{
            get:function () {
                return this.getElement("margin", 0);
            },
            set:function (value) {
                this.setElement(value, "margin");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var SignData = xfalib.script.dom.SignData = xfalib.script.DOMElement.extend({
        msClassName:"signData"
    });

    SignData.defineProps({
        operation:{
            get:function () {
                return this.getAttribute("operation");
            },
            set:function (value) {
                this.setAttribute(value, "operation");
            }
        },
        ref:{
            get:function () {
                return this.getAttribute("ref");
            },
            set:function (value) {
                this.setAttribute(value, "ref");
            }
        },
        target:{
            get:function () {
                return this.getAttribute("target");
            },
            set:function (value) {
                this.setAttribute(value, "target");
            }
        },
        filter:{
            get:function () {
                return this.getElement("filter", 0);
            },
            set:function (value) {
                this.setElement(value, "filter");
            }
        },
        manifest:{
            get:function () {
                return this.getElement("manifest", 0);
            },
            set:function (value) {
                this.setElement(value, "manifest");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Signing = xfalib.script.dom.Signing = xfalib.script.DOMElement.extend({
        msClassName:"signing"
    });

    Signing.defineProps({
        type:{
            get:function () {
                return this.getAttribute("type");
            },
            set:function (value) {
                this.setAttribute(value, "type");
            }
        }

    });

})(_, xfalib);
(function (_, xfalib) {
    var Solid = xfalib.script.dom.Solid = xfalib.script.DOMElement.extend({
        msClassName:"solid"
    });

    Solid.defineProps({
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Speak = xfalib.script.dom.Speak = xfalib.script.GenericText.extend({
        msClassName:"speak"
    });

    Speak.defineProps({
        disable:{
            get:function () {
                return this.getAttribute("disable");
            },
            set:function (value) {
                this.setAttribute(value, "disable");
            }
        },
        priority:{
            get:function () {
                return this.getAttribute("priority");
            },
            set:function (value) {
                this.setAttribute(value, "priority");
            }
        },
        rid:{
            get:function () {
                return this.getAttribute("rid");
            },
            set:function (value) {
                this.setAttribute(value, "rid");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Stipple = xfalib.script.dom.Stipple = xfalib.script.DOMElement.extend({
        msClassName:"stipple"
    });

    Stipple.defineProps({
        rate:{
            get:function () {
                return this.getAttribute("rate");
            },
            set:function (value) {
                this.setAttribute(value, "rate");
            }
        },
        color:{
            get:function () {
                return this.getElement("color", 0);
            },
            set:function (value) {
                this.setElement(value, "color");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var SubjectDN = xfalib.script.dom.SubjectDN = xfalib.script.GenericText.extend({
        msClassName:"subjectDN"
    });

    SubjectDN.defineProps({
        delimiter:{
            get:function () {
                return this.getAttribute("delimiter");
            },
            set:function (value) {
                this.setAttribute(value, "delimiter");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var SubjectDNs = xfalib.script.dom.SubjectDNs = xfalib.script.DOMElement.extend({
        msClassName:"subjectDNs"
    });

    SubjectDNs.defineProps({
        type:{
            get:function () {
                return this.getAttribute("type");
            },
            set:function (value) {
                this.setAttribute(value, "type");
            }
        }

    });

})(_, xfalib);
(function (_, xfalib) {
    var Submit = xfalib.script.dom.Submit = xfalib.script.DOMElement.extend({
        msClassName:"submit"
    });

    Submit.defineProps({
        embedPDF:{
            get:function () {
                return this.getAttribute("embedPDF");
            },
            set:function (value) {
                this.setAttribute(value, "embedPDF");
            }
        },
        format:{
            get:function () {
                return this.getAttribute("format");
            },
            set:function (value) {
                this.setAttribute(value, "format");
            }
        },
        target:{
            get:function () {
                return this.getAttribute("target");
            },
            set:function (value) {
                this.setAttribute(value, "target");
            }
        },
        textEncoding:{
            get:function () {
                return this.getAttribute("textEncoding");
            },
            set:function (value) {
                this.setAttribute(value, "textEncoding");
            }
        },
        xdpContent:{
            get:function () {
                return this.getAttribute("xdpContent");
            },
            set:function (value) {
                this.setAttribute(value, "xdpContent");
            }
        },
        encrypt:{
            get:function () {
                return this.getElement("encrypt", 0);
            },
            set:function (value) {
                this.setElement(value, "encrypt");
            }
        }


    });

})(_, xfalib);
(function (_, xfalib) {
    var Svg = xfalib.script.dom.Svg = xfalib.script.GenericText.extend({
        msClassName:"svg"
    });

    Svg.defineProps({
        height:{
            get:function () {
                return this.getAttribute("height");
            },
            set:function (value) {
                this.setAttribute(value, "height");
            }
        },
        viewBox:{
            get:function () {
                return this.getAttribute("viewBox");
            },
            set:function (value) {
                this.setAttribute(value, "viewBox");
            }
        },
        width:{
            get:function () {
                return this.getAttribute("width");
            },
            set:function (value) {
                this.setAttribute(value, "width");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var TextEdit = xfalib.script.dom.TextEdit = xfalib.script.DOMElement.extend({
        msClassName:"textEdit"
    });

    TextEdit.defineProps({
        allowRichText:{
            get:function () {
                return this.getAttribute("allowRichText");
            },
            set:function (value) {
                this.setAttribute(value, "allowRichText");
            }
        },
        hScrollPolicy:{
            get:function () {
                return this.getAttribute("hScrollPolicy");
            },
            set:function (value) {
                this.setAttribute(value, "hScrollPolicy");
            }
        },
        multiLine:{
            get:function () {
                return this.getAttribute("multiLine");
            },
            set:function (value) {
                this.setAttribute(value, "multiLine");
            }
        },
        vScrollPolicy:{
            get:function () {
                return this.getAttribute("vScrollPolicy");
            },
            set:function (value) {
                this.setAttribute(value, "vScrollPolicy");
            }
        },
        border:{
            get:function () {
                return this.getElement("border", 0);
            },
            set:function (value) {
                this.setElement(value, "border");
            }
        },
        comb:{
            get:function () {
                return this.getElement("comb", 0);
            },
            set:function (value) {
                this.setElement(value, "comb");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        },
        margin:{
            get:function () {
                return this.getElement("margin", 0);
            },
            set:function (value) {
                this.setElement(value, "margin");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var TextNode = xfalib.script.TextNode = xfalib.script.Object.extend({
        msClassName:"textNode"
    });

    TextNode.defineProps({

    })
})(_, xfalib);
(function (_, xfalib) {
    var TimeStamp = xfalib.script.dom.TimeStamp = xfalib.script.GenericText.extend({
        msClassName:"timeStamp"
    });

    TimeStamp.defineProps({
        server:{
            get:function () {
                return this.getAttribute("server");
            },
            set:function (value) {
                this.setAttribute(value, "server");
            }
        },
        type:{
            get:function () {
                return this.getAttribute("type");
            },
            set:function (value) {
                this.setAttribute(value, "type");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var ToolTip = xfalib.script.dom.ToolTip = xfalib.script.GenericText.extend({
        msClassName:"toolTip"
    });

    ToolTip.defineProps({
        rid:{
            get:function () {
                return this.getAttribute("rid");
            },
            set:function (value) {
                this.setAttribute(value, "rid");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Traversal = xfalib.script.dom.Traversal = xfalib.script.DOMElement.extend({
        msClassName:"traversal"
    });

    Traversal.defineProps({
        passThrough:{
            get:function () {
                return this.getAttribute("passThrough");
            },
            set:function (value) {
                this.setAttribute(value, "passThrough");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        }

    });

})(_, xfalib);
(function (_, xfalib) {
    var Traverse = xfalib.script.dom.Traverse = xfalib.script.DOMElement.extend({
        msClassName:"traverse"
    });

    Traverse.defineProps({
        delegate:{
            get:function () {
                return this.getAttribute("delegate");
            },
            set:function (value) {
                this.setAttribute(value, "delegate");
            }
        },
        operation:{
            get:function () {
                return this.getAttribute("operation");
            },
            set:function (value) {
                this.setAttribute(value, "operation");
            }
        },
        ref:{
            get:function () {
                return this.getAttribute("ref");
            },
            set:function (value) {
                this.setAttribute(value, "ref");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        },
        script:{
            get:function () {
                return this.getElement("script", 0);
            },
            set:function (value) {
                this.setElement(value, "script");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Ui = xfalib.script.dom.Ui = xfalib.script.DOMElement.extend({
        msClassName:"ui",

        // TODO : remove these once Sharad merges changes from HMRC
        initialize : function(){
            Ui._super.initialize.call(this);
            for (var i = 0; i < this.moChildNodes.length; ++i) {
                var oNode = this.moChildNodes[i];
                oNode.on(xfalib.script.XfaModelEvent.DOM_CHANGED,this) ;
            }
        },

        handleEvent: function(evnt) {
            this.trigger(evnt.name,evnt);
        },

        _getOneOfChild : function(){
            var oneChild = Ui._super._getOneOfChild.call(this);
            if(oneChild)
                return oneChild;

            var childType = "textEdit";
            if(this.parent){
                var valueChild = this.parent.value.oneOfChild || {className : "text"};
                switch (valueChild.className){
                    case "dateTime" :
                    case "date" :
                    case "time" :
                        childType = "dateTimeEdit";
                        break;
                    case "decimal" :
                    case "float" :
                    case "integer" :
                        childType = "numericEdit";
                        break;
                    case "boolean" :
                        childType = "checkButton";
                        break;
                    case "text" :
                        childType = "textEdit";
                        break;
                    case "image" :
                        childType = "imageEdit";
                        break;
                }
            }
            return this._getDefaultElement(childType, 0, true);
        }

    });

    Ui.defineProps({
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        },
        picture:{
            get:function () {
                return this.getElement("picture", 0);
            },
            set:function (value) {
                this.setElement(value, "picture");
            }
        },
        barcode:{
            get:function () {
                return this.getElement("barcode", 0);
            },
            set:function (value) {
                this.setElement(value, "barcode");
            }
        },
        button:{
            get:function () {
                return this.getElement("button", 0);
            },
            set:function (value) {
                this.setElement(value, "button");
            }
        },
        checkButton:{
            get:function () {
                return this.getElement("checkButton", 0);
            },
            set:function (value) {
                this.setElement(value, "checkButton");
            }
        },
        choiceList:{
            get:function () {
                return this.getElement("choiceList", 0);
            },
            set:function (value) {
                this.setElement(value, "choiceList");
            }
        },
        dateTimeEdit:{
            get:function () {
                return this.getElement("dateTimeEdit", 0);
            },
            set:function (value) {
                this.setElement(value, "dateTimeEdit");
            }
        },
        defaultUi:{
            get:function () {
                return this.getElement("defaultUi", 0);
            },
            set:function (value) {
                this.setElement(value, "defaultUi");
            }
        },
        exObject:{
            get:function () {
                return this.getElement("exObject", 0);
            },
            set:function (value) {
                this.setElement(value, "exObject");
            }
        },
        imageEdit:{
            get:function () {
                return this.getElement("imageEdit", 0);
            },
            set:function (value) {
                this.setElement(value, "imageEdit");
            }
        },
        numericEdit:{
            get:function () {
                return this.getElement("numericEdit", 0);
            },
            set:function (value) {
                this.setElement(value, "numericEdit");
            }
        },
        passwordEdit:{
            get:function () {
                return this.getElement("passwordEdit", 0);
            },
            set:function (value) {
                this.setElement(value, "passwordEdit");
            }
        },
        signature:{
            get:function () {
                return this.getElement("signature", 0);
            },
            set:function (value) {
                this.setElement(value, "signature");
            }
        },
        textEdit:{
            get:function () {
                return this.getElement("textEdit", 0);
            },
            set:function (value) {
                this.setElement(value, "textEdit");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Validate = xfalib.script.dom.Validate = xfalib.script.DOMElement.extend({
        msClassName:"validate"
    });

    Validate.defineProps({
        disableAll:{
            get:function () {
                return this.getAttribute("disableAll");
            },
            set:function (value) {
                this.setAttribute(value, "disableAll");
            }
        },
        formatTest:{
            get:function () {
                return this.getAttribute("formatTest");
            },
            set:function (value) {
                this.setAttribute(value, "formatTest");
            }
        },
        nullTest:{
            get:function () {
                return this.getAttribute("nullTest");
            },
            set:function (value) {
                var oldValue = this.nullTest;
                this.setAttribute(value, "nullTest");
                var event = xfalib.script.XfaModelEvent.createEvent(xfalib.script.XfaModelEvent.DOM_CHANGED, this,
                        'nullTest', oldValue, value);
                this.trigger(event.name, event);
            }
        },
        scriptTest:{
            get:function () {
                return this.getAttribute("scriptTest");
            },
            set:function (value) {
                this.setAttribute(value, "scriptTest");
            }
        },
        extras:{
            get:function () {
                return this.getElement("extras", 0);
            },
            set:function (value) {
                this.setElement(value, "extras");
            }
        },
        message:{
            get:function () {
                return this.getElement("message", 0);
            },
            set:function (value) {
                this.setElement(value, "message");
            }
        },
        picture:{
            get:function () {
                return this.getElement("picture", 0);
            },
            set:function (value) {
                this.setElement(value, "picture");
            }
        },
        script:{
            get:function () {
                return this.getElement("script", 0);
            },
            set:function (value) {
                this.setElement(value, "script");
            }
        }
    });

})(_, xfalib);
(function (_, xfalib) {
    var Value = xfalib.script.dom.Value = xfalib.script.DOMElement.extend({
        msClassName: "value",

        _getOneOfChild: function () {
            var oneChild = Value._super._getOneOfChild.call(this);
            if (oneChild)
                return oneChild;

            var childType = "text";
            if (this.parent && (this.parent.className == "field" || this.parent.className == "draw")) {
                /*
                 * Bug:3600246
                 * When checking ui oneOfChild, do not directly use ui.oneOfChild since it would again fallback to value.onOfChild in case value is also missing.
                 * So check json instead and see if ui oneOfChild exist and then only access it.
                 */
                var uiChild = this.xfaUtil().getUiOneOfChildTag(this.parent.jsonModel) ? this.parent.ui.oneOfChild : {className: "text"};
                switch (uiChild.className) {
                    case "numericEdit" :
                        childType = "float";
                        break;
                    case "dateTimeEdit" :
                        childType = "dateTime";
                        break;
                    case "imageEdit" :
                        childType = "image";
                        break;
                    case "textEdit" :
                        if (uiChild.allowRichText) {
                            childType = "exData";
                        }
                        else {
                            childType = "text";
                        }
                        break;
                    case "choiceList" :
                        if (uiChild.open == "multiSelect") {
                            childType = "exData";
                        }
                        else {
                            childType = "text";
                        }
                        break;
                }
            }
            return this._getDefaultElement(childType, 0, true);
        },

        _computeJsonDiff: function (diff_level) {

            //Force all the descendants of value irrespective of submit call
            var diffObj = xfalib.ut.XfaUtil.prototype.stripOrCall.call(this, false, Value._super._computeJsonDiff, [0]);

            //now strip all the EXTRA properties from value if it is final submission  or restoreFormState
            if (diff_level>0 && this.getOrElse(diffObj, 'jsonDifference.children.length', 0)) {
                //believe me this is not that costly as it looks to be as there will be only one child in all the differences and only two keys per child
                var blacklisted = ['extras'];
                diffObj.jsonDifference.children = _.map(diffObj.jsonDifference.children, function (child) {
                    var copy = {};
                    _.each(Object.keys(child), function (key) {
                        if (!_.contains(blacklisted, key)) {
                            copy[key] = child[key];
                        }
                    });
                    return copy;
                }, this);
            }

            //LC-8319 : don't send [] in diffObj.jsonDifference.children
            if (diffObj.jsonDifference && _.every(diffObj.jsonDifference.children, _.isEmpty)) {  // diffObj should have a jsonDifference member
                diffObj.jsonDifference.children = undefined; // scary to use delete due to perf. impact
            }
            return diffObj;
        }

    });

    Value.defineProps({
        override: {
            get: function () {
                return this.getAttribute("override");
            },
            set: function (value) {
                this.setAttribute(value, "override");
            }
        },
        relevant: {
            get: function () {
                return this.getAttribute("relevant");
            },
            set: function (value) {
                this.setAttribute(value, "relevant");
            }
        },
        arc: {
            get: function () {
                return this.getElement("arc", 0);
            },
            set: function (value) {
                this.setElement(value, "arc");
            }
        },
        "boolean": {
            get: function () {
                return this.getElement("boolean", 0);
            },
            set: function (value) {
                this.setElement(value, "boolean");
            }
        },
        "date": {
            get: function () {
                return this.getElement("date", 0);
            },
            set: function (value) {
                this.setElement(value, "date");
            }
        },
        "dateTime": {
            get: function () {
                return this.getElement("dateTime", 0);
            },
            set: function (value) {
                this.setElement(value, "dateTime");
            }
        },
        "decimal": {
            get: function () {
                return this.getElement("decimal", 0);
            },
            set: function (value) {
                this.setElement(value, "decimal");
            }
        },
        exData: {
            get: function () {
                return this.getElement("exData", 0);
            },
            set: function (value) {
                this.setElement(value, "exData");
            }
        },
        "float": {
            get: function () {
                return this.getElement("float", 0);
            },
            set: function (value) {
                this.setElement(value, "float");
            }
        },
        "image": {
            get: function () {
                return this.getElement("image", 0);
            },
            set: function (value) {
                this.setElement(value, "image");
            }
        },
        "integer": {
            get: function () {
                return this.getElement("integer", 0);
            },
            set: function (value) {
                this.setElement(value, "integer");
            }
        },
        line: {
            get: function () {
                return this.getElement("line", 0);
            },
            set: function (value) {
                this.setElement(value, "line");
            }
        },
        rectangle: {
            get: function () {
                return this.getElement("rectangle", 0);
            },
            set: function (value) {
                this.setElement(value, "rectangle");
            }
        },
        "text": {
            get: function () {
                return this.getElement("text", 0);
            },
            set: function (value) {
                this.setElement(value, "text");
            }
        },
        "time": {
            get: function () {
                return this.getElement("time", 0);
            },
            set: function (value) {
                this.setElement(value, "time");
            }
        }
    });

})(_, xfalib);

(function(_, $, xfalib){

    var HtmlTemplateCache = xfalib.view.util.HtmlTemplateCache = xfalib.ut.Class.extend({
        initialize : function(){
            HtmlTemplateCache._super.initialize.call(this);
            this._cache = {};
            this._hiddenObjPages = [];
        },

        put: function (el) {
            var occurIndex = this.getOrElse(this.xfaUtil().$data(el, xfalib.view.LayoutConst.XFA_MODEL), xfalib.view.LayoutConst.LAYOUT_MODEL + "." + xfalib.view.LayoutConst.OCCUR_INDEX, '0');
            if (!this.contains(el.id) || this._cache[el.id][occurIndex] === undefined) {
                this._cache[el.id] = this._cache[el.id] || {};
                this._cache[el.id][occurIndex] = el; // the cache is now 2D, against each el id store a map, indexed by occur index
                this._cacheChildren(el);
            }
        },

        contains : function(elId){
            return (this._cache.hasOwnProperty(elId) && this._cache[elId] !== undefined);
        },

        get : function(elId, lookUpHiddenCache){
            var $nodeDiv = null,
                nodeXfaModel = null,
                partOffsetY = 0,
                $pageDiv,
                $splitPart;

            function stitchNodes() {
                // We need to collect all parts of this node from various pages/occurrences and stitch them together.
                // We start by picking *stitched* children of this part and append them to initially empty $nodeDiv. As we move on to next
                // part, we'll pick only those children which starts from that part(occurIndex:0)
                // Stitching would require modify the extenty of children to add content height of current stitched
                // part and then modify the extenth of currently stitched part to include height of new part. All the children from new part are cloned-appended into
                // current stitch part.

                if (!$nodeDiv) {
                    //do not modify existing node. Work on it's clone and start building from scratch.
                    $nodeDiv = $splitPart.clone();
                    $nodeDiv.children().remove();
                    nodeXfaModel = this.xfaUtil().$data($nodeDiv.get(0), xfalib.view.LayoutConst.XFA_MODEL);
                }
                else {
                    partOffsetY = parseFloat(nodeXfaModel[xfalib.view.LayoutConst.LAYOUT_MODEL][xfalib.view.LayoutConst.EXTENT_H]) -
                        parseFloat(this.getOrElse(nodeXfaModel[xfalib.view.LayoutConst.LAYOUT_MODEL][xfalib.view.LayoutConst.MARGIN_TOP], 0)) -
                        parseFloat(this.getOrElse(nodeXfaModel[xfalib.view.LayoutConst.LAYOUT_MODEL][xfalib.view.LayoutConst.MARGIN_BOTTOM], 0));
                }

                _.each($splitPart.children().get(),
                    function (partChild) {
                        var childId = partChild.id;
                        var childHasSplit = (this.getOrElse(this.xfaUtil().$data(partChild, xfalib.view.LayoutConst.XFA_MODEL), xfalib.view.LayoutConst.LAYOUT_MODEL + "." + xfalib.view.LayoutConst.OCCURRENCES, 1) > 1);
                        var isChildFirstSplit = (this.getOrElse(this.xfaUtil().$data(partChild, xfalib.view.LayoutConst.XFA_MODEL), xfalib.view.LayoutConst.LAYOUT_MODEL + "." + xfalib.view.LayoutConst.OCCUR_INDEX, 0) == 0);
                        var $childClone = null;
                        if (childHasSplit && !isChildFirstSplit) {
                            //split child would already been handled when it's first part was found.
                            return;
                        }
                        else if (childHasSplit && isChildFirstSplit) {
                            //If this child has split and it is first part of the child split, get the entire stitched child.
                            $childClone = $(this.get(childId, true));
                        }
                        else {
                            $childClone = $(partChild).clone();
                        }
                        var childXfaModel = this.xfaUtil().$data($childClone.get(0), xfalib.view.LayoutConst.XFA_MODEL);
                        if (childXfaModel) {
                            // modify the extenty of child and then append this child clone to current stitch part $nodeDiv
                            childXfaModel[xfalib.view.LayoutConst.LAYOUT_MODEL][xfalib.view.LayoutConst.EXTENT_Y] = partOffsetY + parseFloat(this.getOrElse(childXfaModel[xfalib.view.LayoutConst.LAYOUT_MODEL][xfalib.view.LayoutConst.EXTENT_Y], 0));
                            $childClone.attr("data-" + xfalib.view.LayoutConst.XFA_MODEL, JSON.stringify(childXfaModel));
                        }
                        $childClone.appendTo($nodeDiv);
                    },
                    this
                );

                // modify the extenth part $nodeDiv
                nodeXfaModel[xfalib.view.LayoutConst.LAYOUT_MODEL][xfalib.view.LayoutConst.EXTENT_H] = parseFloat(this.xfaUtil().$data($splitPart.get(0), xfalib.view.LayoutConst.XFA_MODEL)[xfalib.view.LayoutConst.LAYOUT_MODEL][xfalib.view.LayoutConst.EXTENT_H]) + partOffsetY;
            }

            if(this.contains(elId)) {
                if(_.keys(this._cache[elId]).length === 1) {
                    return this._cache[elId]["0"].cloneNode(true);
                }
                // subform was split into different parts, stitch each part in order of occurIndex
                for (var occurIndex = 0; occurIndex < _.keys(this._cache[elId]).length; ++occurIndex) {
                    $splitPart = $(this._cache[elId][occurIndex]);
                    stitchNodes.call(this);
                }

                if ($nodeDiv && $nodeDiv.get(0)) {
                // update stitched node in cache, after modifying occurrences and occur index to make it appear as unsplit
                    this._cache[elId] = undefined;
                    nodeXfaModel[xfalib.view.LayoutConst.LAYOUT_MODEL][xfalib.view.LayoutConst.OCCURRENCES] = "1";
                    nodeXfaModel[xfalib.view.LayoutConst.LAYOUT_MODEL][xfalib.view.LayoutConst.OCCUR_INDEX] = undefined;
                }
            }
            else if(lookUpHiddenCache) {
                for(var i = 0; i < this._hiddenObjPages.length; ++i) {
                    $pageDiv = $(this._hiddenObjPages[i]);
                    $splitPart = $pageDiv.find(this.jqId(elId));
                    if($splitPart && $splitPart.get(0)){
                        stitchNodes.call(this);
                    }
                    this._hiddenObjPages[i] = $pageDiv.get(0); // cache the constructed page dom back in hidden objects array in case page was string as it happens for the first time.
                }
            }

            if ($nodeDiv && $nodeDiv.get(0)) {
                $nodeDiv.attr("data-" + xfalib.view.LayoutConst.XFA_MODEL, JSON.stringify(nodeXfaModel));
                this.put($nodeDiv.get(0));  //put it in the cache.
                return $nodeDiv.get(0).cloneNode(true);
            }
            else {
                return null;
            }
        },

        setHiddenObjPages : function(hiddenPages){
            this._hiddenObjPages = hiddenPages || [];
        },

        _cacheChildren : function(parent){
            var that = this;
            $(parent).children().each(function(){
                //cache xfa sub elements as well.
                if(that.getOrElse(that.xfaUtil().$data(this, xfalib.view.LayoutConst.XFA_MODEL), xfalib.view.LayoutConst.NODE_TYPE, "").length > 0){
                    that.put(this);
                }
            });
        }
    });
})(_, $, xfalib);
(function(_,xfalib) {
    var Constants = {
        XFA_MODEL : "x",
        NODE_TYPE : "t",
        LAYOUT_MODEL: "l",
        SUBFORM_LAYOUT: "sl",
        EXTENT_X : "x",
        EXTENT_Y : "y",
        EXTENT_W : "w",
        EXTENT_H : "h",
        EXTENT_MIN_H : "nh",
        EXTENT_MIN_W : "nw",
        EXTENT_MAX_H : "xh",
        EXTENT_MAX_W : "xw",
        EXTENT_ACTUAL_H : "ah",
        EXTENT_ACTUAL_W : "aw",
        MARGIN_TOP : "t",
        MARGIN_LEFT : "l",
        MARGIN_BOTTOM : "b",
        MARGIN_RIGHT : "r",

        BORDER_TOP : "bt",
        BORDER_LEFT : "bl",
        BORDER_BOTTOM : "bb",
        BORDER_RIGHT : "br",

        COL_SPAN : "c",
        ROW_SPAN : "rs",
        OCCURRENCES : "o",
        OCCUR_INDEX: "i",
        COLUMN_WIDTHS : "cw",
        PAGE_NUMBER: "pn",
        CAP_PLACEMENT : "p",
        LAYOUT_LEFTRIGHTTOPBOTTOM : "lr",
        LAYOUT_RIGHTLEFTTOPBOTTOM : "rl",
        LAYOUT_TOPBOTTOM : "tb",
        LAYOUT_TABLE : "t",
        LAYOUT_ROW : "r",
        LAYOUT_RIGHTLEFTROW : "rr",
        LAYOUT_DATATABLE : "dt"
    };
    xfalib.view.LayoutConst = Constants;
})(_,xfalib);
(function(_, $, xfalib){
    var LayoutBase = xfalib.view.layout.LayoutBase = xfalib.ut.Class.extend({
        initialize : function(){
            xfalib.ut.Class.prototype.initialize.apply(this, arguments);
            this._layoutManager = this._xfaViewRegistry().layoutManager();
            this.target = this.options.target; //ContainerView instance
            this._positioningCssPropertyX = "left";
            this._positioningCssPropertyY = "top";
        },

        measureSize : function(){
            return xfalib.view.BaseView.prototype.measureSize.apply(this.target, arguments);
        },

        invalidateSize : function(){
            return xfalib.view.BaseView.prototype.invalidateSize.apply(this.target, arguments);
        },

        updateDisplay : function(){
            xfalib.view.BaseView.prototype.updateDisplay.apply(this.target, arguments);
            _.each(this.target._normalizedChildViews(), function(childView, index){
                var extent = {};
                extent[this._positioningCssPropertyX] =  childView.layoutModel.measuredx;
                extent[this._positioningCssPropertyY] =  childView.layoutModel.measuredy;
                this.$css(childView.el, extent);
            }, this);
        },

        _targetPaddingX : function(){
            return this.target._padLeft();
        },

        _targetPaddingY : function(){
            return this.target._padTop();
        },

        $data : xfalib.ut.XfaUtil.prototype.$data,

        $css : xfalib.ut.XfaUtil.prototype.$css,

        _xfaViewRegistry : function() {
            return window.xfaViewRegistry;    //TODO: remove window dependency
        }

    })

})(_, $, xfalib);


(function(_, $, xfalib){
    xfalib.view.layout.PositionLayout = xfalib.view.layout.LayoutBase.extend({
        initialize : function(){
            xfalib.view.layout.LayoutBase.prototype.initialize.apply(this, arguments);
        },

        measureSize : function(){
            var layoutModel = this.target.layoutModel;
            var parentPadLeft = this._targetPaddingX();
            var parentPadTop = this._targetPaddingY();
            var oldExtentW = layoutModel.extentw;
            var oldExtentH = layoutModel.extenth;
            var containerW = 0;
            var containerH = 0;
            _.each(this.target._normalizedChildViews(), function(childView, index){

                childView.layoutModel.measuredx =  parentPadLeft + childView.layoutModel.extentx;
                childView.layoutModel.measuredy =  parentPadTop + childView.layoutModel.extenty;
                if(childView.layoutModel.extentx + childView.layoutModel.extentw > containerW)
                    containerW = childView.layoutModel.extentx + childView.layoutModel.extentw;
                if(childView.layoutModel.extenty + childView.layoutModel.extenth > containerH)
                    containerH = childView.layoutModel.extenty + childView.layoutModel.extenth;
            }, this);

            if(layoutModel.extentactualw < 0){
                var parentExtentW = layoutModel.marginleft + containerW + layoutModel.marginright;
                layoutModel.extentw = parentExtentW;
            }
            if(layoutModel.extentactualh < 0){
                var parentExtentH = layoutModel.margintop + containerH + layoutModel.marginbottom;
                layoutModel.extenth = parentExtentH;
            }

            if(oldExtentW != layoutModel.extentw || oldExtentH != layoutModel.extenth){
                return true;
            }
            else {
                return false;
            }
        }

    })
})(_, $, xfalib);



(function(_, $, xfalib){
    xfalib.view.layout.LeftRightLayout = xfalib.view.layout.LayoutBase.extend({
        initialize : function(){
            xfalib.view.layout.LayoutBase.prototype.initialize.apply(this, arguments);
        },

        measureSize : function(){
            var layoutModel = this.target.layoutModel;
            var parentPadX = this._targetPaddingX();
            var parentPadY = this._targetPaddingY();
            var oldExtentW = layoutModel.extentw;
            var oldExtentH = layoutModel.extenth;
            var parentContentWidth  =  layoutModel.extentw - layoutModel.marginleft - layoutModel.marginright + this._layoutManager.LAYOUT_ERROR_MARGIN;
            if(layoutModel.extentactualw < 0){
                parentContentWidth = 1000000; //Arbitrary limitation for max width. Could be MAX_VALUE, but that may be costly?
            }

            var currentX =  0;//Right of the last element
            var currentLineY = 0;
            var lineHeight = 0; //Line Height for current line
            _.each(this.target._normalizedChildViews(), function(childView, index){
                if(currentX + childView.layoutModel.extentw > parentContentWidth){
                    currentX = 0;
                    currentLineY = currentLineY + lineHeight;
                    lineHeight = 0;
                }
                childView.layoutModel.measuredx =  parentPadX + currentX;
                childView.layoutModel.measuredy = parentPadY + currentLineY;
                if(lineHeight < childView.layoutModel.extenth){
                    lineHeight = childView.layoutModel.extenth;
                }
                //update top variables for second element
                currentX = currentX +  childView.layoutModel.extentw;
            }, this);
            if(layoutModel.extentactualw < 0) {
                var parentExtentW = layoutModel.marginleft + currentX + layoutModel.marginright;
                layoutModel.extentw = parentExtentW;
            }
            if(layoutModel.extentactualh < 0) {
                var parentExtentH = layoutModel.margintop + currentLineY + lineHeight + layoutModel.marginbottom;
                layoutModel.extenth = parentExtentH;
            }

            if(oldExtentW != layoutModel.extentw || oldExtentH != layoutModel.extenth){
                return true;
            }
            else{
                return false;
            }
        }

    })
})(_, $, xfalib);

(function(_, $, xfalib){
    xfalib.view.layout.RightLeftLayout = xfalib.view.layout.LeftRightLayout.extend({
        initialize : function(){
            xfalib.view.layout.LeftRightLayout.prototype.initialize.apply(this, arguments);
            this._positioningCssPropertyX = "right";
            this._positioningCssPropertyY = "top";
        },

        _targetPaddingX : function(){
            return this.target._padRight();
        },

        _targetPaddingY : function(){
            return this.target._padTop();
        }

    })
})(_, $, xfalib);


(function(_, $, xfalib){
    xfalib.view.layout.TopBottomLayout = xfalib.view.layout.LayoutBase.extend({

        measureSize : function(){
            var layoutModel = this.target.layoutModel;
            var parentPadLeft = this._targetPaddingX();
            var parentPadTop = this._targetPaddingY();
            var oldExtentW = layoutModel.extentw;
            var oldExtentH = layoutModel.extenth;
            var containerW = 0;
            var currentLineY  =  0;
            _.each(this.target._normalizedChildViews(), function(childView, index){
                childView.layoutModel.measuredx = parentPadLeft;
                childView.layoutModel.measuredy =  parentPadTop + currentLineY;
                if(childView.layoutModel.extentw > containerW) {
                    containerW = childView.layoutModel.extentw;
                }
                //update currentLineY variables for second element
                currentLineY = currentLineY + childView.layoutModel.extenth;
            }, this);

            if(layoutModel.extentactualw < 0){
                var parentExtentW = layoutModel.marginleft + containerW + layoutModel.marginright;
                layoutModel.extentw = parentExtentW;
            }
            if(layoutModel.extentactualh < 0){
                var parentExtentH = layoutModel.margintop + currentLineY + layoutModel.marginbottom;
                layoutModel.extenth = parentExtentH;
            }

            if(oldExtentW != layoutModel.extentw || oldExtentH != layoutModel.extenth){
                return true;
            }
            else {
                return false;
            }
        }

    })
})(_, $, xfalib);


(function(_, $, xfalib){
    xfalib.view.layout.RowLayout = xfalib.view.layout.LayoutBase.extend({
        initialize : function(){
            xfalib.view.layout.LayoutBase.prototype.initialize.apply(this, arguments);
        },

        measureSize : function(){
            var layoutModel = this.target.layoutModel;
            var lineHeight = 0; //Line Height for current line
            _.each(this.target._normalizedChildViews(), function(childView, index){
//                if(childView.model && childView.model.className == "draw")      //Draw table cells are set to 100% sizes. They can not grow. If moved, they'll overlay border
//                    return;
                if(lineHeight < childView.layoutModel.extenth){
                    lineHeight = childView.layoutModel.extenth;
                }
            }, this);
            //Set extenth for all row cells
            _.each(this.target._normalizedChildViews(), function(childView, index){
                if(childView.layoutModel.extenth != lineHeight){
                    childView.layoutModel.extenth = lineHeight;
                    childView.invalidateDisplay();
                }
            }, this);

            layoutModel.extenth = layoutModel.margintop + lineHeight + layoutModel.marginbottom;

            //in case of rowLayout measure would always return true which means
            // layout algo of table would always be triggered as row does not have enough data to compute if any column width changed
            return true;
        }

    })
})(_, $, xfalib);


(function(_, $, xfalib){
    xfalib.view.layout.DataTableRowLayout = xfalib.view.layout.RowLayout.extend({
        initialize : function(){
            xfalib.view.layout.RowLayout.prototype.initialize.apply(this, arguments);
        },

        measureSize : function(){
            //in case of rowLayout measure would always return true which means
            // layout algo of table would always be triggered as row does not have enough data to compute if any column width changed
            return true;
        },

        updateDisplay : function(){
            xfalib.view.layout.RowLayout.prototype.updateDisplay.apply(this, arguments);
            this.$css(this.target.el, {"position":"relative"});
            _.each(this.target._normalizedChildViews(), function(childView){
                var extent = {};
                extent["position"] =  "relative";
                this.$css(childView.el, extent);
                if(childView.layoutModel.borderleft > 2) {
                    this.$css(childView.el, {"border-left-width":childView.layoutModel.borderleft/2.0});
                }
                if(childView.layoutModel.bordertop > 2) {
                    this.$css(childView.el, { "border-top-width":childView.layoutModel.bordertop/2.0});
                }
                if(childView.layoutModel.borderbottom > 2) {
                    this.$css(childView.el, {"border-bottom-width":childView.layoutModel.borderbottom/2.0});
                }
                if(childView.layoutModel.borderright > 2) {
                    this.$css(childView.el, {"border-right-width":childView.layoutModel.borderright/2.0});
                }
            }, this);

        }
    })
})(_, $, xfalib);
(function(_, $, xfalib){
    xfalib.view.layout.RightLeftRowLayout = xfalib.view.layout.RowLayout.extend({
        initialize : function(){
            xfalib.view.layout.RowLayout.prototype.initialize.apply(this, arguments);
            this._positioningCssPropertyX = "right";
            this._positioningCssPropertyY = "top";
        },

        _targetPaddingX : function(){
            return this.target._padRight();
        },

        _targetPaddingY : function(){
            return this.target._padTop();
        }
    })
})(_, $, xfalib);



(function(_, $, xfalib){
    xfalib.view.layout.TableLayout = xfalib.view.layout.LayoutBase.extend({
        initialize : function(){
            xfalib.view.layout.LayoutBase.prototype.initialize.apply(this, arguments);
            this._tableCellGrid = [ [] ];
            this.assignedColWidths = this.getOrElse(this.target.layoutModel.columnwidths, []);
            this._columnWidths = this.assignedColWidths.slice();
        },

        /**
         * Returns the Rows in the table by filtering out rows from all the child views
         * @returns Array containing the child views that are rows
         * @private
         */
        _getRows : function () {
            return _.filter(this.target._normalizedChildViews(), function (childView) {
                if (childView.layoutModel.layout == xfalib.view.LayoutConst.LAYOUT_ROW
                        || childView.layoutModel.layout == xfalib.view.LayoutConst.LAYOUT_RIGHTLEFTROW) {
                    return true;
                } else {
                    return false;
                }
            }, this);
        },

        measureSize : function () {
            var layoutModel = this.target.layoutModel,
                rowViews = this._getRows();

            this._validCellsInRow(rowViews);

            _.each(rowViews, function(rowView, rowIndex){
                _.each(rowView._normalizedChildViews(), function(cellView){
                    var cellLayout = cellView.layoutModel;
                    var colspan = this.getOrElse(cellLayout.colspan, 1);
                    if(colspan == -1)
                        colspan = this._tableCellGrid.length - cellView.effectiveCellIndex; //if colpan is -1, then set it to remaining grid length
                    var lastCellIndex = cellView.effectiveCellIndex + colspan -1;

                    if(!this._tableCellGrid[lastCellIndex]){
                        var lastNonEmptyColIndex = -1;
                        for(var j = lastCellIndex; j>=0; j-- ){
                            if(this._tableCellGrid[j]){
                                lastNonEmptyColIndex = j;
                                break;
                            }
                        }
                        //lastNonEmptyColIndex can not be -1 here. since it should be at least 0
                        //Now copy fill all previous missing column data with lastNonEmptyCol data
                        for(var k = lastNonEmptyColIndex + 1; k <= lastCellIndex ; k++){
                            this._tableCellGrid[k] = this._tableCellGrid[k-1].splice() ;
                        }
                    }
                    //Now add currentCellView to proper location in cell grid
                    for(var i = cellView.effectiveCellIndex; i <= lastCellIndex;  i++){
                        this._tableCellGrid[i][rowIndex] = cellView;
                    }

                    if(this.assignedColWidths[cellView.effectiveCellIndex] > -1){
                        this._columnWidths[cellView.effectiveCellIndex] = this.assignedColWidths[cellView.effectiveCellIndex];
                        return;
                    }
                    else if(this.getOrElse(cellLayout.colspan, 1) == 1){ // use actual colspan
                        //TODO:check if tableCellIndex maintained properly
                        if(cellLayout.extentw > (this._columnWidths[cellView.effectiveCellIndex] || 0))
                            this._columnWidths[cellView.effectiveCellIndex]  = cellLayout.extentw;
                    }
                }, this);
            }, this);

            //Additional pass to adjust columnWidths for columns with colpsan > 1
            _.each(this._tableCellGrid, function(columnCells, colIndex){
                if(this.assignedColWidths[colIndex] > -1)
                    return;
                var colWidth = this._columnWidths[colIndex];
                _.each(columnCells, function(cellView){
                    var colspan = this.getOrElse(cellView.layoutModel.colspan, "1");
                    if(colspan == -1)
                        colspan = this._tableCellGrid.length - cellView.effectiveCellIndex;
                    //If colspan is one, we have already taken care. if this cell still extends beyond this column, we'll handle it later
                    if( colspan == 1 || ((cellView.effectiveCellIndex + colspan -1) != colIndex))
                        return;
                    //For spanned column, compute the with of the cell that lies in this cloumn.
                    var spannedColWidth = cellView.layoutModel.extentw;
                    for(var l = cellView.effectiveCellIndex; l < colIndex; l++){
                        spannedColWidth = spannedColWidth - this._columnWidths[l];
                    }
                    if(spannedColWidth > this._columnWidths[colIndex])
                        this._columnWidths[colIndex] = spannedColWidth;
                }, this);
            }, this);

            //Now update the final computed extentw for cells and rows.
            //Also update measuredx/y for it's cells
            _.each(rowViews, function(rowView, rowIndex){
                var rowPadX = rowView.layout._targetPaddingX();
                var rowPadY = rowView.layout._targetPaddingY();
                var rowWidth = 0;
                _.each(rowView._normalizedChildViews(), function(cellView){
                    var newCellW = this._computeColumnWidth(cellView);
                    if(newCellW != cellView.layoutModel.extentw){
                        cellView.layoutModel.extentw = newCellW;
                        cellView.invalidateDisplay();
                    }
                    cellView.layoutModel.measuredx = rowPadX + rowWidth;
                    cellView.layoutModel.measuredy = rowPadY;
                    rowWidth = rowWidth + cellView.layoutModel.extentw;
                }, this);
                var newRowWidth = rowView.layoutModel.marginleft + rowWidth + rowView.layoutModel.marginright;
                if(rowView.layoutModel.extentw != newRowWidth){
                    rowView.layoutModel.extentw = newRowWidth;
                    rowView.invalidateDisplay();
                }
            }, this);

            //Now update the final computed extentw for table and measuredx/y for it's children
            var tablePadX = this._targetPaddingX();
            var tablePadY = this._targetPaddingY();
            var parentW = 0;
            var parentH = 0;
            _.each(this.target._normalizedChildViews(), function(childView, childIndex){
                if(childView.layoutModel.extentw > parentW){
                    parentW = childView.layoutModel.extentw;
                }
                childView.layoutModel.measuredx = tablePadX;
                childView.layoutModel.measuredy = tablePadY + parentH;
                parentH = parentH + childView.layoutModel.extenth;
            }, this);

            var oldExtentW = layoutModel.extentw;
            var oldExtentH = layoutModel.extenth;
            layoutModel.extentw = layoutModel.marginleft + parentW + layoutModel.marginright;
            layoutModel.extenth = layoutModel.margintop + parentH + layoutModel.marginbottom;
            if(oldExtentW != layoutModel.extentw || oldExtentH != layoutModel.extenth){
                return true;
            }
            else {
                return false;
            }
        },

        _computeColumnWidth : function(cellView){
            var colspan = this.getOrElse(cellView.layoutModel.colspan, 1);
            if(colspan <0){
                colspan = this._columnWidths.length - cellView.tableCellIndex;
            }
            if(cellView.effectiveCellIndex + colspan -1 >= this._columnWidths.length)
                return cellView.layoutModel.extentw;              //should not be the case ever
            else{
                var colWidth = 0;
                for(var i= cellView.effectiveCellIndex; i <= cellView.effectiveCellIndex + colspan -1; i++){
                    colWidth = colWidth + this._columnWidths[i];
                }
                return colWidth;
            }
        },

        _validCellsInRow : function(rowViews) {
            var hiddenChildIndex;
            var index;
            var count =0;

            _.each(rowViews, function(rowView, rowIndex){
                var ChildViews = rowView.childViews;
                hiddenChildIndex = [];
                _.each(ChildViews,function(vChildView, index){
                       if(vChildView.model.presence != "visible") {
                          hiddenChildIndex.push(index);  // keeps the index of hidden fields
                       }
                  },this);


                  for(var i=ChildViews.length-1;i>0;i--) {
                     count = 0;
                     _.each(hiddenChildIndex,function(value,index){ // this is to find the number of hidden elements before the given index.
                         if(value < i) count++;
                     },this);
                     ChildViews[i].effectiveCellIndex = ChildViews[i].tableCellIndex - count ; // to calculate the effective cell index for visible fields.
                  }

            },this);
        },

        //layout related functions
        invalidateSize : function(){
            if(!this._layoutManager.isPendingValidateSize(this.target)){ //check isPending to avoid recursion
                _.each(this.target._normalizedChildViews(), function(childView) {
                    if (!this._layoutManager.isPendingValidateSize(childView) && (childView.layoutModel.layout == xfalib.view.LayoutConst.LAYOUT_ROW ||
                            childView.layoutModel.layout == xfalib.view.LayoutConst.LAYOUT_RIGHTLEFTROW)) {
                        _.each(childView._normalizedChildViews(), function(cellView) {
                            if (!this._layoutManager.isPendingValidateSize(cellView)) {
                                cellView.invalidateSize();
                            }
                        }, this);
                        childView.invalidateSize();
                    }
                }, this);
                xfalib.view.layout.LayoutBase.prototype.invalidateSize.apply(this, arguments);
            }
        }

    })
})(_, $, xfalib);



(function(_, $, xfalib){

    xfalib.view.layout.DataTableLayout = xfalib.view.layout.TableLayout.extend({

        //for a given id get the list of headers (including row-headers and column-headers)
        //this can be multiple in case we have multiple row/column, or cell spans multiple columns
        //TCH: Table Column Header
        //TRH: Table Row Header
        //TDC: Table Data Cell
        getHeader:function(cellId,dataPresenceTable) {
            // use headers as a Set
            var headers = {};
            _.each(dataPresenceTable, function(row, i) {
                _.each(dataPresenceTable[i], function(column, j) {
                    if(cellId == dataPresenceTable[i][j].substring(4)) {
                        var k, header;
                        for(k=0;k<i;k++) {
                            if(dataPresenceTable[k][j].indexOf("TCH:") == 0) {
                                header = dataPresenceTable[k][j].substring(4);
                                if(!headers.hasOwnProperty(header)) {
                                    headers[header] = true;
                                }
                            }
                        }
                        for(k=0;k<j;k++) {
                            if(dataPresenceTable[i][k].indexOf("TRH:") == 0) {
                                header = dataPresenceTable[i][k].substring(4);
                                if(!headers.hasOwnProperty(header)) {
                                    headers[header] = true;
                                }
                            }
                        }
                    }
                },this);
            },this);
            // convert headers Set into string to be added to headers attribute
            return _.keys(headers).join(" ").trim();
        },


        measureSize: function () {
            //heightTable: contains the height for each row
            //widthTable: contains the width for each cell
            //dataPresenceTable: captures the mapping for header to data cells
            var heightTable = [], widthTable = [], dataPresenceTable = [];

            var layoutModel = this.target.layoutModel;
            //get child of tables which are actually rows
            var rowViews = _.filter(this.target._normalizedChildViews(), function (childView) {
                if (childView.layoutModel.layout == xfalib.view.LayoutConst.LAYOUT_ROW || childView.layoutModel.layout == xfalib.view.LayoutConst.LAYOUT_RIGHTLEFTROW)
                    return true;
                else
                    return false;
            }, this);
            this._validCellsInRow(rowViews);

            //identify the number of columns in the table (the first row is the bet to get this as
            // previous row rowspan does not impact it). Add all colspans to get the actual number of columns
            var numColumns = 0;
            _.each(rowViews, function (rowView, rowIndex) {
                _.each(rowView._normalizedChildViews(), function (cellView, cellIndex) {
                    if(rowIndex == 0){
                        numColumns+=this.getOrElse(cellView.layoutModel.colspan, 1);
                    }
                }, this);
                //initilaize the columns to an __empty string, and the end of processing table will not
                //contain any __empty cells
                dataPresenceTable[rowIndex] = [];
                for(var i=0;i<numColumns;i++) {
                    dataPresenceTable[rowIndex][i] = "__empty";
                }
            },this);


            //Populate the dataPresenceTable with the IDs for header and data cell - required to associate the headers
            // with the data cells. Also populate the height tables needed for formatting the table.
            _.each(rowViews, function (rowView, rowIndex) {
                _.each(rowView._normalizedChildViews(), function (cellView, cellIndex) {
                    var cellLayout = cellView.layoutModel;
                    var rowspan = this.getOrElse(cellLayout.rowspan, 1);
                    var colspan = this.getOrElse(cellLayout.colspan, 1);
                    if (colspan == -1) {
                        //if colpan is -1, then set it to remaining grid length
                        colspan = this._tableCellGrid.length - cellView.effectiveCellIndex;
                    }
                    if(rowspan == 1){
                        if(heightTable[rowIndex] == undefined || cellView.layoutModel.extenth > heightTable[rowIndex] ) {
                            heightTable[rowIndex] = cellView.layoutModel.extenth;
                            if(cellView.layoutModel.extenth < cellView.layoutModel.initialh)
                                heightTable[rowIndex] = cellView.layoutModel.initialh;
                        }
                    }
                    var actualColumnIndex = 0;
                    for (var i = 0; i < numColumns; i++) {
                        if(dataPresenceTable[rowIndex][i] == "__empty") {
                            for(var j=0;j<colspan;j++) {
                                for(var k=0;k<rowspan;k++) {
                                    if(cellView.el.nodeName == "TH") {
                                        if(cellView._isPartOfHeaderRow()) {
                                            dataPresenceTable[rowIndex+k][actualColumnIndex+j] = "TCH:"+cellView._id;
                                        } else {
                                            dataPresenceTable[rowIndex+k][actualColumnIndex+j] = "TRH:"+cellView._id;
                                        }
                                    } else {
                                        dataPresenceTable[rowIndex+k][actualColumnIndex+j] = "TDC:"+cellView._id;
                                    }
                                    if(colspan == 1){
                                        if(widthTable[actualColumnIndex] == undefined || cellView.layoutModel.extentw > widthTable[actualColumnIndex] ) {
                                            widthTable[actualColumnIndex] = cellView.layoutModel.extentw;
                                        }
                                    }
                                }
                            }

                            break;
                        } else {
                            actualColumnIndex++;
                        }
                    }
                    layoutModel.extenth = 0;
                    layoutModel.extentw = 0;
                    _.each(heightTable, function(height) {
                        layoutModel.extenth+=height ;
                    });

                    _.each(widthTable, function(width) {
                        layoutModel.extentw+=width;
                    });

                }, this);
            }, this);

            //set the row and cell height from height table to keep all cells symmetric
            //also add the headers attribute to the view
            _.each(rowViews, function (rowView, rowIndex) {
                var rowPadX = rowView.layout._targetPaddingX();
                var rowPadY = rowView.layout._targetPaddingY();
                rowView.layoutModel.extenth =  heightTable[rowIndex];

                //process the info to get row heights, column heights and first cell
                _.each(rowView._normalizedChildViews(), function (cellView, cellIndex) {
                    var headers = this.getHeader(cellView._id,dataPresenceTable);
                    if(headers != "") {
                        cellView.$el.attr('headers', headers);
                    }
                    if(cellView.layoutModel.rowspan == 1) {
                        cellView.layoutModel.extenth =  heightTable[rowIndex]
                            - cellView.layoutModel.bordertop / 2.0
                            - cellView.layoutModel.borderbottom / 2.0;
                        cellView.invalidateDisplay();

                    }

                },this);
            },this);
            return true;
        },

        updateDisplay : function(){
            xfalib.view.layout.TableLayout.prototype.updateDisplay.apply(this, arguments);
            this.$css(this.target.el, {"border-spacing":"0"});
            // LC-3911668 : Safari does not update the display when a DOM change is done in a table:
            if(xfalib.ut.XfaUtil.prototype.isSafari()) {
                this.target.$el.hide().css("height");this.target.$el.show();
            }
        }

    }, this);
})(_, $, xfalib);
(function (_, $, xfalib) {
    xfalib.view.layout.StaticLayout = xfalib.view.layout.LayoutBase.extend({

        measureSize : function () {
            var growableOffsetH = 0, growableAssignedH, newOffset;
            var initialGrowableBottom = -1;
            var growableView = this.target.growableView;
            var layoutModel = this.target.layoutModel;
            var growF = 0;
            if (!_.isEmpty(growableView)) {
                for (var i = 0; i < growableView.length; i++) {
                    if ((growableView[i].layoutModel.extenth - growableView[i].layoutModel.initialh) > 0) {
                        growF = i;
                    }
                }

                growableAssignedH = growableView[growF].layoutModel.initialh;
                newOffset = growableView[growF].layoutModel.extenth - growableAssignedH;
                initialGrowableBottom = growableView[growF].layoutModel.extenty + growableAssignedH;

                //bug#3475566, make an exception for first page and render it even if there is no content.
                if (!this.target._forceView() &&
                    growableView[growF].layoutModel.extenth <= (growableView[growF].layoutModel.margintop + growableView[growF].layoutModel.marginbottom)) {
                    //All the children of growable subform have either been removed or been hidden. So set it's height to zero as well.
                    growableOffsetH = -layoutModel.initialh;
                    layoutModel.measureddisplay = "hidden";
                }
                else {
                    if (newOffset > 0 || (!this._xfaViewRegistry().pagingConfig().shrinkPageDisabled &&
                        this.target._formDomRoot().host.numPages > 1)) {
                        //If view has overgrown or
                        //pageShrink is enabled and total number of pages are more that one then change the growableOffSet and move everything.
                        growableOffsetH = newOffset;
                        if (newOffset < 0 && this.target instanceof xfalib.view.PageView) {
                            this.target._formDomRoot().host.pagingManager.autoRenderPage();
                        }
                    }
                    layoutModel.measureddisplay = "block";
                }
            }
            var parentPadLeft = this._targetPaddingX();
            var parentPadTop = this._targetPaddingY();
            var oldExtentH = layoutModel.extenth;
            var containerH = layoutModel.initialh + growableOffsetH;
            _.each(this.target.childViews, function (childView, index) {
                childView.layoutModel.measuredx = parentPadLeft + childView.layoutModel.extentx;
                if (childView.layoutModel.extenty >= initialGrowableBottom) {
                    childView.layoutModel.measuredy = parentPadTop + childView.layoutModel.extenty + growableOffsetH;
                } else {
                    childView.layoutModel.measuredy = parentPadTop + childView.layoutModel.extenty;
                }
                if(layoutModel.measureddisplay !== "hidden") {
                    if (childView.model && childView.model.jsonModel && childView.model.jsonModel.presence !== "hidden" &&
                        childView.layoutModel.measuredy + childView.layoutModel.extenth > containerH) {
                        containerH = childView.layoutModel.measuredy + childView.layoutModel.extenth
                    }
                }
            }, this);

            layoutModel.extenth = containerH;
            if (oldExtentH != layoutModel.extenth) {
                return true;
            }
            else {
                return false;
            }
        },

        _getRootView : function () {
            return this._xfaViewRegistry().rootSubformView;
        },

        renderNextPage : function () {
            this._getRootView().renderDeferredPage();
        },

        updateDisplay : function () {
            xfalib.view.layout.LayoutBase.prototype.updateDisplay.apply(this, arguments);
            if (this.getOrElse(this.target, "layoutModel.measureddisplay", "") == "hidden") {
                this.$css(this.target.el, {"display" : "hidden"});
            }
            else {
                this.$css(this.target.el, {"display" : "block"});
            }
        }

    })
})(_, $, xfalib);




(function(_, $, xfalib){
    xfalib.view.layout.SubformSetLayout = xfalib.view.layout.LayoutBase.extend({
        measureSize : function(){
            //Subformset should always return true show that measureSize(0 of parent is called.
            return true;
        },

        invalidateSize : function(){
            if(this.target.parentView){
                this.target.parentView.invalidateSize();
            }
        }

        })
})(_, $, xfalib);




(function(_, $, xfalib){
    xfalib.view.layout.RootSubformLayout = xfalib.view.layout.LayoutBase.extend({
        measureSize : function(){
            return false;
        },

        updateDisplay : function(){
            return;
        }
    })
})(_, $, xfalib);




(function(_, $, xfalib){
    xfalib.view.layout.LayoutManager = xfalib.ut.Class.extend({
        LAYOUT_ERROR_MARGIN : 1,

        initialize : function(){
            xfalib.ut.Class.prototype.initialize.apply(this, arguments);
            this._invalidSizeQ = [];
            this._invalidDisplayQ = [];
            this._validatingSize = false;
            this._validatingDisplay = false;
            this._validationPending = false;
        },

        invalidateSize : function(view){
            if(this._validatingDisplay && view && view instanceof Object){
                xfalib.runtime.xfa.Logger.error("xfaView", "invalidateSize is called while validatingDisplay is running which is an issue. id" + view._id +
                    ", parent id:"+ (view.parentView && (view.parentView instanceof Object)) ? view.parentView._id : view.parentView);
            }

            if(!this._validatingSize && !this._validationPending){
                var that = this;
                this._validationPending = true;
                var timeout = window.setTimeout(function(){
                    that.triggerValidation();
                }, 1);
                xfalib.ut.XfaUtil.prototype.clearTimeoutOnDestroy(timeout);
            }

            var found = this.isPendingValidateSize(view);
            if(!found){
                this._invalidSizeQ.push(view);
            }
        },

        invalidateDisplay : function(view){
            var found = _.find(this._invalidDisplayQ, function(invalidView){
                if(invalidView == view){
                    return true;
                }
            });
            if(!found){
                this._invalidDisplayQ.push(view);
            }
        },

        triggerValidation : function(){
            if(this._validatingSize){
                xfalib.runtime.xfa.Logger.debug("xfaView", "validation is already running");
            }
            this._validationPending = false;
            this._validatingSize = true;
            while(this._invalidSizeQ.length > 0){
                var view = this._invalidSizeQ.shift();
                view._validateSize();
            }
            this._validatingSize = false;
            if (this._xfaViewRegistry().rootSubformView._formDomRoot()._modelInitialize === 'INITIALIZED') {
                this._xfaViewRegistry().rootSubformView._formDomRoot().form.execLayoutReady();
            }

            this._validatingDisplay = true;
            while(this._invalidDisplayQ.length >0){
                var view = this._invalidDisplayQ.shift();
                view._validateDisplay();
            }
            this._validatingDisplay = false;

             if (formBridge && xfalib.globals.highlight)   // highLight newly added fields
                $(formBridge).trigger("xfaLayoutComplete");
        },

        createLayout : function(view){
            var options = {target:view} ;
            if(view instanceof xfalib.view.RootSubformView)
                return new xfalib.view.layout.RootSubformLayout(options);
            else if(view instanceof xfalib.view.PageView )
                return new xfalib.view.layout.StaticLayout(options);
            else if(view instanceof xfalib.view.ContentAreaView)
                return new xfalib.view.layout.TopBottomLayout(options);
            else if(view instanceof xfalib.view.SubformSetView)
                return new xfalib.view.layout.SubformSetLayout(options);
            else if(view.el.nodeName == "TR")
                return new xfalib.view.layout.DataTableRowLayout(options);

            var layout = null;
            switch (view.layoutModel.layout)
            {
                case xfalib.view.LayoutConst.LAYOUT_LEFTRIGHTTOPBOTTOM:
                    layout = new xfalib.view.layout.LeftRightLayout(options);
                    break;
                case xfalib.view.LayoutConst.LAYOUT_RIGHTLEFTTOPBOTTOM:
                    layout = new xfalib.view.layout.RightLeftLayout(options);
                    break;
                case xfalib.view.LayoutConst.LAYOUT_TOPBOTTOM:
                    layout = new xfalib.view.layout.TopBottomLayout(options);
                    break;
                case xfalib.view.LayoutConst.LAYOUT_TABLE:
                    layout = new xfalib.view.layout.TableLayout(options);
                    break;
                case xfalib.view.LayoutConst.LAYOUT_ROW:
                    layout = new xfalib.view.layout.RowLayout(options);
                    break;
                case xfalib.view.LayoutConst.LAYOUT_RIGHTLEFTROW:
                    layout = new xfalib.view.layout.RightLeftRowLayout(options);
                    break;
                case xfalib.view.LayoutConst.LAYOUT_DATATABLE:
                    layout = new xfalib.view.layout.DataTableLayout(options);
                    break;
                default :
                    layout = new xfalib.view.layout.PositionLayout(options);
            }
            return layout;
        },

        isPendingValidateSize : function(view){
            return (this._invalidSizeQ.indexOf(view)  > -1);
        },

        _xfaViewRegistry : function() {
            return window.xfaViewRegistry;    //TODO: remove window dependency
        },
        /*
         * Checks whether any view has any kind of layout activity pending either in measure or update phase.
         */
        isLayoutCycleComplete : function(){
            return !(this._invalidSizeQ.length  > 0 || this._invalidDisplayQ.length > 0);
        }

    })
})(_, $, xfalib);

(function(_, $, xfalib){
    xfalib.view.XfaViewEvent = {
        PRESENCE_CHANGE : "presenceChange",
        EXTENT_CHANGE : "extentChange"
    }
})(_, $, xfalib);

(function(_, $, xfalib){
    xfalib.view.ObjectView = xfalib.ut.EventClass.extend({


        initialize : function(){
            xfalib.ut.EventClass.prototype.initialize.apply(this, arguments);
            this.id = this.options.id;
            this.$el = (this.options.el instanceof $) ? this.options.el : $(this.options.el);
            this.el = this.$el[0];
            this._layoutManager = this._xfaViewRegistry().layoutManager();
        },

        // jQuery delegate for element lookup, scoped to DOM elements within the
        // current view. This should be prefered to global lookups where possible.
        $: function(selector) {
            return this.$el.find(selector);
        },

        _formDomRoot : function() {
            return xfalib.script.Xfa.Instance; //TODO: Remove singleton dependency
        },

        _bind : function(context, func) {
            return function() {
                return func.apply(context, arguments);
            }
        },

        _xfaViewRegistry : function() {
            return window.xfaViewRegistry;    //TODO: remove window dependency
        },

        _mm2px : function(mmSize){
            return xfalib.view.util.Styles._mm2px(mmSize);
        },

        _convertToPx : function(size){
            return xfalib.view.util.Styles._convertToPx(size);
        },

        getOrElse : xfalib.ut.Class.prototype.getOrElse, //short cut but really needed to avoid duplicate code. May be better way next time.

        jqId: xfalib.ut.XfaUtil.prototype.jqId,

        matchJsonType: xfalib.ut.XfaUtil.prototype.matchJsonType,

        $data : xfalib.ut.XfaUtil.prototype.$data,

        $css : xfalib.ut.XfaUtil.prototype.$css

    });

})(_, $, xfalib);
(function(_, $, xfalib){
    var BaseView = xfalib.view.BaseView =  xfalib.view.ObjectView.extend({

        initialize : function() {
            xfalib.view.ObjectView.prototype.initialize.apply(this, arguments);
            this._id = this.el.id;
            this._initialized = false;
            this.parentView = this.options.parentView;
            this.tableCellIndex = this.options.tableCellIndex || 0;
            this.effectiveCellIndex = 0;
            this.model = null;
            this.layoutModel = null;
            this._invalidSizeFlag = true;
            this._invalidDisplayFlag = true;
            this._resizable = false;
            this.edgePresence = true;
            this.$data(this.el, "xfaView", this);
            if(this._id)
                this.model = this._formDomRoot()._xfaTemplateCache.getModel(this._id);
            if(this.model){
                this.createBorder();
                if(this.model.presence == "visible") {
                    this._initialized = true;
                } else {
                    var that = this;
                    var initHandler = {
                        handleEvent: function(evnt) {
                            if(evnt._property == "presence" && !that._initialized){
                                that._initLayout();
                                if(that._initialized){
                                    that.model.off(xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED, initHandler);
                                }
                            } else if(that._initialized){
                                //The only case when initHandler can be called even if it's initialized is in case of server side scripts which change presence on server.
                                //but does not call initHandler at that time. So we need to remove initHandler explicitly in next call.
                                that.model.off(xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED, initHandler);
                            }
                        }
                    };
                    this.model.on(xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED, initHandler);
                }
                this.model.on(xfalib.script.XfaModelEvent.DOM_CHANGED, this);


            }

        },

        createBorder : function(){
            var border = this.model.getElement("border",0,true),
                fill,
                color,
                edge;
            if(border){
                if((fill = border.getElement("fill",0,true)) && (color = fill.getElement("color",0,true))
                    && fill.presence!="hidden"
                    && fill.presence !="invisible"
                    ) {
                    color = color.value;
                    if(color == "")
                        color="255,255,255";     // if no color value is specified then fill default color
                    color = "rgb(" + color + ")";
                    $(this.el).css("background-color", color);
                }

                var allEdgeHidden = true,
                index = 0,
                edge;
                while(edge = border.getElement("edge",index,true)) {
                    if(edge.presence!="hidden" &&  edge.presence!="invisible") {
                        allEdgeHidden = false;
                        break;
                    }
                    index++;
                }
                if(border.presence == "visible"
                    && !allEdgeHidden) {
                    var cssStyleObj = xfalib.view.util.Styles.getStyleForBorder(border);
                    if(cssStyleObj){
                        this.$css(this.el, cssStyleObj);
                        return;
                    }

                } else {
                    // LC-3910380 : In case border presence or edge presence is invisible or hidden then marking border as none
                    if(border.presence=="hidden"
                        || border.presence=="invisible"
                        || allEdgeHidden){
                            $(this.el).css("border", "none");
                    }
                }
            }
            this.edgePresence = false;
        },

        //generic function to compute css style from the <font> & <para> element of the model
        _getTextStyle : function(referenceModel) {
            var cssStyleObj={};
            var asparaStylesObj = {};

            var fontElement = referenceModel.getElement('font',0,true);
            if(fontElement) {
                cssStyleObj['font-family'] = fontElement.getAttribute('typeface');
                cssStyleObj['font-size']   = this._convertToPx(fontElement.getAttribute('size'));
                cssStyleObj['font-style']  = fontElement.getAttribute('posture');
                cssStyleObj['font-weight'] = fontElement.getAttribute('weight');
                cssStyleObj['text-decoration'] = fontElement.getAttribute('underline') != 0 ? 'underline' : undefined;

                var fill = fontElement.getElement('fill',0,true);
                if(fill) {
                    var color = fill.getElement('color',0,true);
                    var colorValue = color.value;
                    if(colorValue) {
                        cssStyleObj['color'] = 'rgb('+colorValue+')';
                    }
                }
            }

            var para = referenceModel.getElement('para',0,true);
            if(para) {
                if(para.hAlign)  {
                    asparaStylesObj['right']= this._convertToPx(para.marginRight);
                    asparaStylesObj['left']= this._convertToPx(para.marginLeft);
                    asparaStylesObj['overflow']= "hidden";
                    switch(para.hAlign) {
                        case "right":
                            asparaStylesObj['text-align']= "right";
                            break;
                        case "left":
                        case "radix":  //Till now radix is not implemented, it is mapped to the default one i.e left
                            asparaStylesObj['text-align']= "left";
                            break;
                        case "center":
                            asparaStylesObj['text-align']= "center";
                            break;
                        case "justify":
                        case "justifyAll":
                            asparaStylesObj['text-align']= "justify";
                            break;
                    }
                }
                switch(para.vAlign) {
                   case "top":
                       asparaStylesObj['top']= this._convertToPx(para.spaceAbove);
                       break;
                   case "bottom":
                       asparaStylesObj['bottom']= this._convertToPx(para.spaceBelow);
                       break;
                }
                asparaStylesObj['text-indent'] = this._convertToPx(para.textIndent);
            }
            return {fontStyles : cssStyleObj, paraStyles :  asparaStylesObj};
        },

        _convertXFARichToHtml: function(text){
            var value;
            if(text != null)  {
             if(typeof text == 'string' && text[0] != '<') {
                 text = "<span>"+text+"</span>";   // $.replaceWith expects a HTML string
             }

             //--conversion to jQuery obj to handle font-size of span
             var spanText = $(text);
             spanText.find("*").each(function(index, span){
                  if(span.style) {
                      if(span.style.fontSize) {
                        value= xfalib.view.util.Styles._convertToPx(span.style.fontSize)+"px";
                        span.style['font-size'] = span.style.fontSize = value;
                   }
                }
             });

             text= "<span>"+spanText.html()+"</span>";
           }
           return text;
        },

        _initAccessibilityInfo: function() {
            //accessibility info

            if(this.layoutModel.colspan > 1) {
                this.$el.attr("colspan", this.layoutModel.colspan);
            }
            if(this.layoutModel.rowspan > 1) {
                this.$el.attr("rowspan", this.layoutModel.rowspan);
            }

            // TODO - move these table related stuff to table view
            //The below roles are not conflicting with the native accessibility support introduced in DataTables, but
            //not recommended until scripted data element is used (Refer to: http://www.w3.org/TR/aria-in-html/).
            //With the introduction of row-span and row header - the current info is not complete for ARIA-Roles
            //So if native HTML table is being used for render (DataTableLayout, do not add the ARIA-Roles below).
            // - No change required for table as layout for DataTable is  DATA_LAYOUT_TABLE
            // - Do not add accessibility for 'columnheader' or 'gridcell' if node is TH or TR (the check will also avoid the inefficient check)
            // - Do not add the accessibility for 'row' if node is TR
            var nodeName = this.el.nodeName;
            var partOfNativeTable = (nodeName == "TABLE"
                                    || nodeName == "TR"
                                    || nodeName == "TD"
                                    || nodeName == "TH");

            if(!partOfNativeTable) {
                if (this.layoutModel.layout == xfalib.view.LayoutConst.LAYOUT_TABLE) {
                    //put grid role
                    this.$el.attr("role", "grid");
                }
                else if (this._isTableHeaderCell()) {
                    this.$el.attr("role", "columnheader");
                }
                else if (this._isTableCell()) {
                    this.$el.attr("role", "gridcell");
                }
                else if (this.layoutModel.layout == xfalib.view.LayoutConst.LAYOUT_ROW) {
                    this.$el.attr("role", "row");
                }
                else if (this.layoutModel.layout == xfalib.view.LayoutConst.LAYOUT_RIGHTLEFTROW) {
                    this.$el.attr("role", "row");
                }
            }
            //add role and title to this.$el
            var assist = this.model.getElement("assist", 0, true);
            if(assist && assist.role) {
                //translate XFA roles to HTML5 roles (WAria roles)
                if(assist.role == 'TR' && !partOfNativeTable)
                    this.$el.attr("role", "row");
                else if(assist.role == 'TH'){
                    //do nothing as header info is to be propagated to individual cells
                    //this.$el.attr("role", "row");
                }
                else if(assist.role == 'TF'){
                    //do nothing as header info is to be propagated to individual cells
                    //this.$el.attr("role", "row");
                }
                else if(!partOfNativeTable) {
                    this.$el.attr("role", assist.role);
                }
            }

            if (nodeName === "TABLE") {
                this.$el.attr("aria-label", this._getScreenReaderText());
            }

            //add lang parameter
            var lang = this._langFromLocale(this.model.jsonModel.locale);
            if(lang && lang.length > 0){
                this.$el.attr("lang", lang);
            }

            this._assignToolTip();
        },

        _assignToolTip : function () {
        },

        _getScreenReaderText: function(){
        },

        /**
         *
         * @param i
         * @param val
         * @return {String}
         * @private used by XfaDrawView and FieldView
         */
        _adjustTextCoordinate: function(i, val){
            //somehow jquery attr() function cannot read textLength attribute
            var sTextLen = this.getAttribute('textLength');
            if(sTextLen && val && val.length > 2) {
                //remove px
                var textLen = Number(sTextLen.substr(0, sTextLen.length-2));
                var x = Number(val.substr(0, val.length-2));
                //server adjust x for all rtl text content so we need to revert it back for webkit
                x += textLen;
                return x+"px";
            }
        },

        /**
         *
         * @private
         * internal function to extract lang from locale
         */
        _langFromLocale : function(locale) {
            var lang;
            if(locale && locale.length > 0) {
                //locale can be in the form of country_LANG -- en_US
                //Whereas lang attribute of html expects only country code
                var index = locale.indexOf('_');

                if(index != -1){
                    lang = locale.substr(0, index);
                }
                else {
                    lang = locale;
                }

                //leap of faith that lang would be ISO 631 complaint.
            }
            return lang;
        },

        setElement: function(element) {
          this.undelegateEvents();
          this._setElement(element);
          this.delegateEvents();
          return this;
        },

        _setElement: function(el) {
          this.$el = el instanceof $ ? el : $(el);
          this.el = this.$el[0];
        },


        delegateEvents: function(events) {
          var delegateEventSplitter = /^(\S+)\s*(.*)$/;
          events || (events = _.result(this, 'events'));
          if (!events) return this;
          this.undelegateEvents();
          for (var key in events) {
            var method = events[key];
            if (!_.isFunction(method)) method = this[method];
            if (!method) continue;
            var match = key.match(delegateEventSplitter);
            this.delegate(match[1], match[2], _.bind(method, this));
          }
          return this;
        },

        delegate: function(eventName, selector, listener) {
          this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);
          return this;
        },

        undelegateEvents: function() {
          if (this.$el) this.$el.off('.delegateEvents' + this.cid);
          return this;
        },

        _initLayout : function(){
            var presence = this.model ? this.model.presence : "visible";

            if(!this.layoutModel){
                //If layoutmodel has not been initialized, initialize that.
                this._initializeLayoutModel();
            }

            if(this._isPlaceHolderEl() && (presence == "visible" || presence == "invisible")){
                // Currently we are on a placeholder div el (because this element was hidden or inactive). It's time to find the actual element.
                var templateId = (this.model ? this.model._templateId() : this._id) || this._id;
                var actualEl = this._xfaViewRegistry().templateCache().get(templateId, true);
                if(actualEl){
                    // hides the actualEL as the layout is still disturbed, removes the hideElement class on updateDisplay
                    $(actualEl).addClass("hideElement");
                    this.$el.replaceWith(actualEl);
                    this.setElement(actualEl);
                    this.$data(this.el, "xfaView", this);
                    this._initializeLayoutModel(); //need to re-initialize layout model at this point.
                }
                else
                    xfalib.runtime.xfa.Logger.error("xfaView", "Html template could not be found. id:"+this._id+", som:"+this.getOrElse(this.model, "somExpression"));
            }

            if(presence == "visible"){
                var nodeName = "";
                if(this.model){
                    this.model.on(xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED, this);
                    this._initAccessibilityInfo();
                    nodeName = this.model.getAttribute("name");
                }
                // as part of html size reduction, server stopped sending node type and name of the component
                // add classes for the same
                var nodeType = (xfalib.ut.XfaUtil.prototype.$data(this.el, xfalib.view.LayoutConst.XFA_MODEL) ||{})[xfalib.view.LayoutConst.NODE_TYPE];
                if(nodeType)
                    this.$el.addClass(nodeType);
                if(nodeName != null && nodeName.length > 0) {
                    this.$el.addClass(nodeName);
                }
                var extent = this._computeExtent();
                this.$css(this.el, extent);
                this._initialized = true;
            } else{
                //If presence is set to visible then _handlePresenceChange is called as part of sync from subclasses
                // But otherwise we need to explicitlly call _handlePresenceChange here.
                this._handlePresenceChange({newText : presence});
            }
        },

        handleEvent: function(evnt) {
            switch(evnt.name) {
                case xfalib.script.XfaModelEvent.FORM_MODEL_CHANGED:
                    this.handleModelChanged(evnt);
                    break;
                case xfalib.script.XfaModelEvent.DOM_CHANGED:
                    this.handleDomChanged(evnt);
                    break;
                default:
                    /* log an error message */
            }
        },

        handleDomChanged : function(event){
            switch(event._property) {
                case "font.fill.color.value":
                    this._handleFontFillColorValue(event);
                    break;
                case "border.fill.color.value":
                case "textEdit.border.fill.color.value":
                case "numericEdit.border.fill.color.value":
                case "imageEdit.border.fill.color.value":
                case "signature.border.fill.color.value":
                case "dateTimeEdit.border.fill.color.value":
                case "passwordEdit.border.fill.color.value":
                case "choiceList.border.fill.color.value":
                    this._handleBorderFillColorValue(event);
                    break;
                case "border.edge.presence":
                    this._handleBorderEdgePresence(event);
                    break;
                case "border.edge.color.value":
                    this._handleBorderChange(event);
                    break;
                case "border.edge.thickness":
                    this._handleBorderChange(event);
                    break;
                case "border.fill.presence":
                    this._handleBorderFillPresence(event);
                    break;
                case "topInset":
                    this._handleTopInset(event);
                    break;
                case "bottomInset":
                    this._handleBottomInset(event);
                    break;
                case "leftInset":
                    this._handleLeftInset(event);
                    break;
                case "rightInset":
                    this._handleRightInset(event);
                    break;
            }
        },

        handleModelChanged : function(event) {
            if (event._property == "presence") {
                this._handlePresenceChange(event);
            } else if (event._property == "access") {
                this._handleAccessChange(event);
            }else if (event._property == "relevant")  {
                this._handleRelevantChange(event);
            }
        },

        _handleRelevantChange : function(event) {
//				xfa.Logger.debug("[_handlePresenceChange]presence:som"
//						+ event.newText + ":" + this.$el.data("som"));
            switch (event.newText) {
                case "+print":
                case "print" :
                    if(this.model.getAttribute("presence") == "visible")
                        this.el.style.visibility = "hidden" ;
                    break;
                case "-print":
                    if(this.model.getAttribute("presence") == "visible")
                        this.el.style.visibility = "visible";
                    break;
                default:
                    break;
            }
            this.parentView.invalidateSize();
        },

        _handlePresenceChange : function(event) {
//				xfa.Logger.debug("[_handlePresenceChange]presence:som"
//						+ event.newText + ":" + this.$el.data("som"));
            switch (event.newText) {
            case "visible":
                if(this.model.getAttribute("relevant") == "print" || this.model.getAttribute("relevant") == "+print")
                    this.el.style.visibility = "hidden" ;
                else this.el.style.visibility= "inherit";
                break;
            case "invisible":
            case "hidden":
            case "inactive":
                this.el.style.visibility = "hidden";
                break;
            default:
                this.el.style.visibility= "inherit";
                break;
            }
            if (xfalib.runtime.xfa.form.mbInitialized) {
                this.parentView.invalidateSize();
            }
        },

        _handleRightInset : function(event) {
        },

        _handleBottomInset : function(event) {
            /*var bottomInset = parseFloat(event.prevText) ;
             if(bottomInset)  {
             var extent = this._computeExtent();
             extent["margin-bottom"] =  this._mm2px(25.4* bottomInset) ;
             this.layoutModel.marginbottom = extent["margin-bottom"];
             this._invalidDisplayFlag = true;
             this._validateDisplay();
             var a= this.measureSize();
             this.$css(this.el, extent);
             } */

        },

        _handleLeftInset : function(event) {
        },

        _handleTopInset : function(event) {
        },

        _handleFontFillColorValue : function(event) {

        },

        _handleBorderFillColorValue : function(event) {
            var borderFillColorValue = event.prevText;
            var visibility =  this.model.border.fill.presence ;

            if(borderFillColorValue && visibility != "invisible" && visibility != "hidden")  {
                if(borderFillColorValue.indexOf("rgb") == -1)
                    borderFillColorValue = "rgb(" + borderFillColorValue + ")";

                if (_.contains(["textEdit","numericEdit","imageEdit","signature","dateTimeEdit","choiceList",
                        "passwordEdit"], event._property.substring(0,event._property.indexOf('.')))) {
                    $(this.widget).css("background-color", borderFillColorValue);
                } else if( event._property === "border.fill.color.value") {
                    $(this.el).css("background-color", borderFillColorValue);
                }
            }
        },

        _handleBorderEdgePresence : function(event) {
            var visibility = event.prevText;
            var defaultBorder = "1px solid rgb(0, 0, 0)"
            if(visibility == "hidden" || visibility == "invisible") {
                $(this.el).css("border", "none");
            }
            else {
                var cssStyleObj = xfalib.view.util.Styles.getStyleForBorder(this.model.border);
                if(cssStyleObj)
                    this.$css(this.el, cssStyleObj);
                else $(this.el).css("border", defaultBorder);
            }


        },

        _handleBorderChange : function(event) {
            var cssStyleObj = xfalib.view.util.Styles.getStyleForBorder(this.model.border);
            if(cssStyleObj)
                this.$css(this.el, cssStyleObj);
        },

        _handleBorderFillPresence : function(event) {
            var borderFillPresence = event.prevText;
            var color = this.model.border.fill.color.value;
            if(borderFillPresence == "hidden" || borderFillPresence == "invisible"){
                $(this.el).css("background-color", "rgb(255,255,255)" )
            }
            else {
                if(color.indexOf("rgb") == -1)
                    color = "rgb(" + color + ")";
                $(this.el).css("background-color", color);
            }
        },

        _fillColor : function(color) {
            $(this.el).css("background-color", color)
        },

        _borderColor : function(color) {
            $(this.el).css("borderColor", color)
        },

        _handleAccessChange : function(event) {

        },

        /*
         * This method calls _initLayout in addition to calling original _syncFormToHtml.
         * This is specially useful when using server side scripts and calls deep sync.
         * If you are sure that object has been initialized call _syncFormToHtml else call this method.
         * Other objects(other than *this*) should always call this method insteadOf internal _syncFormToHtml method.
         */
        syncFormNodeToHtml: function(deepSync){
            if(!this._initialized && this._isPlaceHolderEl()){
                //If this is uninitialized placeHolderEl(in case presence is hidden initially and has not been changed since
                // then we want to attempt an _initLayout to check if presence needs to be handled.
                this._initLayout();
                if(!this._initialized && this._isPlaceHolderEl()){
                    //If this is still placeHolderEl then no point of running a sync
                    return;
                }
            }
            this._syncFormNodeToHtml(deepSync);
        },

        _syncFormNodeToHtml : function(deepSync) {
            // TODO : make sync logic better
            if (this.model) {
                this._handlePresenceChange({newText:this.model.presence})  ;
                //this._handleAccessChange({newText:this.model.mEffAccess})      ;
            }
            this.invalidateSize();
        },

        _initializeLayoutModel : function() {
            //In order to minimize the size of html generated, this layoutmodel is generated in a cryptic way
            //here is the mapping between the cryptic variables and explanatory variables.
            //in the interest of readability, preserving the good readable names

            var lm = this.getOrElse(this.$data(this.el, xfalib.view.LayoutConst.XFA_MODEL), xfalib.view.LayoutConst.LAYOUT_MODEL, {})
            var layout = {};
            if(this instanceof xfalib.view.ContainerView && !lm.hasOwnProperty(xfalib.view.LayoutConst.SUBFORM_LAYOUT)){
                layout.layout = "position";
            }
            else if(lm.hasOwnProperty(xfalib.view.LayoutConst.SUBFORM_LAYOUT)) {
                layout.layout = lm[xfalib.view.LayoutConst.SUBFORM_LAYOUT]
            }

            if (lm.hasOwnProperty(xfalib.view.LayoutConst.EXTENT_X))
                layout.extentx = this._mm2px(lm[xfalib.view.LayoutConst.EXTENT_X]);
            else
                layout.extentx = 0;

            if (lm.hasOwnProperty(xfalib.view.LayoutConst.EXTENT_Y))
                layout.extenty = this._mm2px(lm[xfalib.view.LayoutConst.EXTENT_Y]);
            else
                layout.extenty = 0;

            if (lm.hasOwnProperty(xfalib.view.LayoutConst.EXTENT_MIN_W))
                layout.extentminw = this._mm2px(lm[xfalib.view.LayoutConst.EXTENT_MIN_W]);
            else
                layout.extentminw = -1;

            if (lm.hasOwnProperty(xfalib.view.LayoutConst.EXTENT_MIN_H))
                layout.extentminh = this._mm2px(lm[xfalib.view.LayoutConst.EXTENT_MIN_H]);
            else
                layout.extentminh = -1;

            if (lm.hasOwnProperty(xfalib.view.LayoutConst.EXTENT_MAX_W))
                layout.extentmaxw = this._mm2px(lm[xfalib.view.LayoutConst.EXTENT_MAX_W]);
            else
                layout.extentmaxw = -1;

            if (lm.hasOwnProperty(xfalib.view.LayoutConst.EXTENT_MAX_H))
                layout.extentmaxh = this._mm2px(lm[xfalib.view.LayoutConst.EXTENT_MAX_H]);
            else
                layout.extentmaxh = -1;

            if (lm.hasOwnProperty(xfalib.view.LayoutConst.EXTENT_W))
                layout.extentw = Math.max(this._mm2px(lm[xfalib.view.LayoutConst.EXTENT_W]), layout.extentminw);
            else
                layout.extentw =  Math.max(0, layout.extentminw);

            if (lm.hasOwnProperty(xfalib.view.LayoutConst.EXTENT_H))
                layout.extenth = Math.max(this._mm2px(lm[xfalib.view.LayoutConst.EXTENT_H]), layout.extentminh);
            else
                layout.extenth =  Math.max(0, layout.extentminh);

            if (lm.hasOwnProperty(xfalib.view.LayoutConst.EXTENT_ACTUAL_W))
                layout.extentactualw = this._mm2px(lm[xfalib.view.LayoutConst.EXTENT_ACTUAL_W]);
            else
                layout.extentactualw =  -1;

            if (lm.hasOwnProperty(xfalib.view.LayoutConst.EXTENT_ACTUAL_H))
                layout.extentactualh = this._mm2px(lm[xfalib.view.LayoutConst.EXTENT_ACTUAL_H]);
            else
                layout.extentactualh =  -1;

            if (lm.hasOwnProperty(xfalib.view.LayoutConst.MARGIN_TOP))
                layout.margintop = this._mm2px(lm[xfalib.view.LayoutConst.MARGIN_TOP]);
            else
                layout.margintop = 0;

            if (lm.hasOwnProperty(xfalib.view.LayoutConst.MARGIN_RIGHT))
                layout.marginright = this._mm2px(lm[xfalib.view.LayoutConst.MARGIN_RIGHT]);
            else
                layout.marginright = 0;

            if (lm.hasOwnProperty(xfalib.view.LayoutConst.MARGIN_BOTTOM))
                layout.marginbottom = this._mm2px(lm[xfalib.view.LayoutConst.MARGIN_BOTTOM]);
            else
                layout.marginbottom = 0;

            if (lm.hasOwnProperty(xfalib.view.LayoutConst.MARGIN_LEFT))
                layout.marginleft = this._mm2px(lm[xfalib.view.LayoutConst.MARGIN_LEFT]);
            else
                layout.marginleft = 0;

            if (lm.hasOwnProperty(xfalib.view.LayoutConst.BORDER_TOP))
                layout.bordertop = this._mm2px(lm[xfalib.view.LayoutConst.BORDER_TOP]);
            else
                layout.bordertop = 0;

            if (lm.hasOwnProperty(xfalib.view.LayoutConst.BORDER_RIGHT))
                layout.borderright = this._mm2px(lm[xfalib.view.LayoutConst.BORDER_RIGHT]);
            else
                layout.borderright = 0;

            if (lm.hasOwnProperty(xfalib.view.LayoutConst.BORDER_BOTTOM))
                layout.borderbottom = this._mm2px(lm[xfalib.view.LayoutConst.BORDER_BOTTOM]);
            else
                layout.borderbottom = 0;

            if (lm.hasOwnProperty(xfalib.view.LayoutConst.BORDER_LEFT))
                layout.borderleft = this._mm2px(lm[xfalib.view.LayoutConst.BORDER_LEFT]);
            else
                layout.borderleft = 0;

            if (lm.hasOwnProperty(xfalib.view.LayoutConst.COL_SPAN))
                layout.colspan = +lm[xfalib.view.LayoutConst.COL_SPAN];
            else
                layout.colspan = 1;

            if (lm.hasOwnProperty(xfalib.view.LayoutConst.ROW_SPAN))
                layout.rowspan = +lm[xfalib.view.LayoutConst.ROW_SPAN];
            else
                layout.rowspan = 1;

            if(lm.hasOwnProperty(xfalib.view.LayoutConst.COLUMN_WIDTHS)){
                var colWidths = lm[xfalib.view.LayoutConst.COLUMN_WIDTHS].split(" ");
                var calcWidths = _.map(colWidths,
                    function(colWidth){
                        return this._mm2px(colWidth);
                    },
                    this);
                layout.columnwidths = calcWidths;
            }

            if(this._isTableCell()){
                var columnWidth = -1;
                var tableLayoutModel = this.parentView.parentView.layoutModel;
                if(tableLayoutModel.columnwidths && tableLayoutModel.columnwidths.length >= this.tableCellIndex)
                    columnWidth = tableLayoutModel.columnwidths[this.tableCellIndex];
                if(columnWidth >= 0){
                    layout.extentw = columnWidth;
                    layout.extentactualw = columnWidth;
                    layout.extentminw = 0;
                    layout.extentmaxw = "none";
                }
            }
            layout.initialh = layout.extenth;
            layout.initialw = layout.extentw;

            if(lm.hasOwnProperty(xfalib.view.LayoutConst.CAP_PLACEMENT))
                layout.captionPlacement = lm[xfalib.view.LayoutConst.CAP_PLACEMENT];

            if(lm.hasOwnProperty(xfalib.view.LayoutConst.PAGE_NUMBER))
                layout.pageNumber = lm[xfalib.view.LayoutConst.PAGE_NUMBER];

            this.layoutModel = layout;
            this.resizable = this.layoutModel.extentactualw < 0 ||  this.layoutModel.extentactualh < 0;
        },

        _computeExtent : function() {
            var extent = {} ;
            extent["margin-left"] = this._marginLeft();
            extent["margin-right"] = this._marginRight();
            extent["margin-top"] = this._marginTop();
            extent["margin-bottom"] = this._marginBottom();
            extent["padding-left"] = this._padLeft();
            extent["padding-right"] = this._padRight();
            extent["padding-top"] = this._padTop();
            extent["padding-bottom"] = this._padBottom();
            extent["border-left-width"] = this._subPixelValue(this.layoutModel.borderleft);
            extent["border-right-width"] = this._subPixelValue(this.layoutModel.borderright);
            extent["border-top-width"] = this._subPixelValue(this.layoutModel.bordertop);
            extent["border-bottom-width"] = this._subPixelValue(this.layoutModel.borderbottom);
            extent["-webkit-box-sizing"] = "border-box";
            extent["-moz-box-sizing"] = "border-box";
            extent["box-sizing"] = "border-box";
            extent["position"] = "absolute";
            return extent;
        },

        _padLeft : function() {
            return this.layoutModel.marginleft
                    - this.layoutModel.borderleft / 2;
        },

        _padRight : function() {
            return this.layoutModel.marginright
                    - this.layoutModel.borderright / 2;
        },

        _padTop : function() {
            return this.layoutModel.margintop - this.layoutModel.bordertop / 2;
        },

        _padBottom : function() {
            return this.layoutModel.marginbottom
                    - this.layoutModel.borderbottom / 2;
        },

        _marginLeft : function() {
            return -this.layoutModel.borderleft / 2;
        },

        _marginRight : function() {
            return -this.layoutModel.borderright / 2;
        },

        _marginTop : function() {
            return -this.layoutModel.bordertop / 2;
        },

        _marginBottom : function() {
            return -this.layoutModel.borderbottom / 2;
        },

        _isTableCell : function(){ //Too long check??? Please shorten it.
            if(this.parentView && this.parentView.layoutModel &&
                (this.parentView.layoutModel.layout == xfalib.view.LayoutConst.LAYOUT_ROW || this.parentView.layoutModel.layout == xfalib.view.LayoutConst.LAYOUT_RIGHTLEFTROW) &&
                this.parentView.parentView && this.parentView.parentView.layoutModel &&
                this.parentView.parentView.layoutModel.layout == xfalib.view.LayoutConst.LAYOUT_TABLE){
                  return true;
                }
            return false;
        },

        _isTableHeaderCell : function(){ //Too long check??? Please shorten it.
            if(this.parentView && this.parentView.layoutModel &&
                (this.parentView.layoutModel.layout == xfalib.view.LayoutConst.LAYOUT_ROW || this.parentView.layoutModel.layout == xfalib.view.LayoutConst.LAYOUT_RIGHTLEFTROW) &&
                this.parentView.model.getElement("assist", 0, true) && this.parentView.model.assist.role == "TH"){
                return true;
            }
            return false;
        },


        //For a given cell identify if the cell is part of header row (THEAD)
        _isPartOfHeaderRow : function(){
            if(this.parentView && this.parentView.layoutModel &&
                (this.parentView.layoutModel.layout == xfalib.view.LayoutConst.LAYOUT_ROW || this.parentView.layoutModel.layout == xfalib.view.LayoutConst.LAYOUT_RIGHTLEFTROW) &&
                this.parentView.el.parentNode.nodeName == "THEAD"){
                return true;
            }
            return false;
        },

        $computeWH : function(){
            //private method but still overridden in SubformSetView
            var extent = {};
            //If the field is not initialized(invisible or hidden), then there is no need to set w/h for el. This would automatically be done during initialization via sync
            extent["width"] = this.layoutModel.extentw + this.layoutModel.borderleft/2 + this.layoutModel.borderright/2;
            extent["height"] = this.layoutModel.extenth + this.layoutModel.bordertop/2 + this.layoutModel.borderbottom/2 ;
            return extent;
        },

        _isPlaceHolderEl : function(){
            return this.$data(this.el, "xfaHiddenPH");
        },

        //layout related functions
        invalidateSize : function(){
            this._invalidSizeFlag = true;
            this._layoutManager.invalidateSize(this);
            this.invalidateDisplay();
        },

        invalidateDisplay : function(){
            this._invalidDisplayFlag = true;
            this._layoutManager.invalidateDisplay(this);
        },

        _validateSize : function(recursive){
            if(this._invalidSizeFlag){
                if(this._initialized){
                    var sizeChanged = this.measureSize();
                    if(sizeChanged)
                       this.parentView.invalidateSize();
                }
                this._invalidSizeFlag = false;
            }
        },

        _validateDisplay : function(recursive){
            if(this._invalidDisplayFlag){
                if(this._initialized){
                    this.updateDisplay();
                    this.trigger("layoutComplete");
                }
                this._invalidDisplayFlag = false;
            }
        },

        measureSize : function(){
            var changed = false;
            if(!this.resizable){
                if(this.layoutModel.extenth != this.layoutModel.initialh){
                    this.layoutModel.extenth = this.layoutModel.initialh;
                    changed = true;
                }
                if(this.layoutModel.extentw != this.layoutModel.initialw){
                    this.layoutModel.extentw = this.layoutModel.initialw;
                    changed = true;
                }
            }
            return changed;
        },

        updateDisplay : function(){
            var extent = this.$computeWH();
            this.$css(this.el, extent);
            $(this.el).removeClass("hideElement");
        },

        _subPixelValue : function(value){
            if(value > 0.01)
                return Math.max(value, 1.0);
            else
                return value;
        },

        /*
         * Return the page number containing this view.
         * Note: page number starts with 1 instead of 0
         */
        _pageNumber : function(){
            //Page number is passed as argument to createView and is available in options
            return this.getOrElse(this, "options.pageNumber", -1);
        },

        /*
         * @function
         * Focuses the widget of the provided view.
         * @param {Object} view : view whose widget needs to be focussed.
         */
        _focusWidget : function (view) {
            var jqWidget = view.jqWidget;
            if (!jqWidget) {
                return;
            }
            if(xfalib.ut.XfaUtil.prototype._isIpad()) {
                var offset = jqWidget.$userControl.offset(),
                    top = offset.top,
                    left = offset.left;
                window.scrollTo(left,top) ;
            }
            jqWidget.focus();
        }

    });

    Object.defineProperty(BaseView.prototype, "resizable", {
        get : function(){
            return this._resizable;
        },

        set : function(sValue){
            this._resizable = sValue;
        }
    });
})(_, $, xfalib);
(function(_, $, xfalib){
    xfalib.view.XfaDrawView = xfalib.view.BaseView.extend({
        $drawChild : null,

        initialize : function(){
            xfalib.view.BaseView.prototype.initialize.apply(this, arguments);
            this._initLayout();
            this._createAccessibilityInfo();
        },

        handleModelChanged : function(event) {
            switch(event._property) {
                case "rawValue" :
                                if(event.jsonModel.newText) {
                                    this._updateView(event.jsonModel.newText);
                                }
                                break;
                default:
                    xfalib.view.BaseView.prototype.handleModelChanged.apply(this,
                        arguments);
            }
        },

        handleDomChanged : function(event) {
             switch(event._property) {
                 case "value.text" :
                 case "value.exData" :
                                    if(event.jsonModel.newText) {
                                        this._updateView(event.jsonModel.newText);
                                    }
                                    break;
                 case "h" ://--we support computation only on line for now.
                                 if(this.getOrElse(this.model, "value.oneOfChild.className", "") === "line"){
                                     this._computeLineHeight();
                                 }
                                 break;
                 default:
                     xfalib.view.BaseView.prototype.handleDomChanged.apply(this,
                          arguments);
            }
        },

        _handleFontFillColorValue : function(event) {
            if(this.model && this.model.value) {
                var content = this.model.value.oneOfChild;
                var htmlText = content.jsonModel._value;
                if(content.getAttribute('contentType') == 'text/html') {
                    var $internalHTML = $('<span>'+htmlText+'</span>');
                    //change the top level element to span to wrap up all the <p>, because it will cause unnecessary paragraph break
                    //add 'display:inline' style
                    //no null check because jQuery is cool!
                    //ToDo: change all your paragraphs into <span> and add a <br> element between them
                    //this will work for few cases where there is one single paragraph in the text or plain text cases.
                    $internalHTML.find("p").eq(0).css('display','inline');
                    this._updateView($internalHTML[0]);
                }
                else
                    this._updateView(htmlText);
            }
            //now check the rawValue and update view based on that rawValue

        },

        _updateView : function(text) {
              if (this._initialized && this.model) {
                  var value = this.model.getElement('value',0, true);
                  if(value) {
                      var  child = value.oneOfChild;
                      if (["text","exData"].indexOf(child.className) !== -1) {
                          var cssObj = this._getTextStyle(this.model);
                          if (cssObj)
                              this.$css(this.el, cssObj.fontStyles);

                          text = xfalib.ut.XfaUtil.prototype.encodeScriptableTags(this._convertXFARichToHtml(text));
                          this.$el.children().replaceWith(text);
                          if (this.el.children[0] && cssObj) {
                              this.$css(this.el.children[0], cssObj.paraStyles);
                          }
                      }
                      else if (child.className === 'image' && text) {//if draw is of type image
                          this.$el.children()[0].setAttribute('src', 'data:;base64,' + text);
                      }

                      if(this.resizable){
                          this.invalidateSize();
                      }
                  }
            }
        },

        measureSize : function(){
            var resized = false,
                text = null,
                content = this.getOrElse(this, "model.value.oneOfChild", null);

            // check to resize draw only in case of floating field and is resizable
            if(this.resizable && this._isFloatingFieldPresent(content)){
                // if content is rich text, then use jquery html() to support rich text element else text()
                if(content && content.getAttribute('contentType') == 'text/html') {
                    text = this.$el.html();
                } else {
                    text = this.$el.text();
                }
                resized = xfalib.view.FieldView.prototype._updateWidgetModel.call(this, text);
            }
            return resized;
        },

        _getMeasurementOptions : function(){
           var measureOptions = xfalib.view.FieldView.prototype._getMeasurementOptions.apply(this, arguments),
               content = this.getOrElse(this, "model.value.oneOfChild", null);
           return $.extend({}, measureOptions, {
               contentType : content ? content.getAttribute('contentType') : "",
               isDraw : true,
               refEl : this.el
           });

        },
        /**
         * @function
         * Utility function to checks whether the draw is having floating field or not
         * @param {object} content : contains jsonValue , _origTmpltVal etc.
         * @returns {boolean} : true if draw contains floating field else false
         */
        _isFloatingFieldPresent : function (content) {
            if (content && content._origTmpltVal) {
                var $internalHTML = $('<span>' + content._origTmpltVal + '</span>');
                return $internalHTML.find('[xfa\\:embed]').length > 0;
            }
            return false;
        },

        _syncFormNodeToHtml : function(val) {
            //in order to save some bytes
            // we don't send xmlns attributes from server so set it here
            var children = this.$el.children(),
                value = null;
            if(children.length)
            {
                if (children[0].tagName === 'svg')
                {
                    children[0].setAttribute('role','presentation'); // CQ-4274732 : To prevent svg being read out as graphic
                    children[0].setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                    children[0].setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
                    children[0].setAttribute('focusable', 'false'); //LC-7105 LC-5444 svg tabIndex doesn't work so adding focusable as false
                    //Required so that draw do not spill out of their parent div.
                    var cssExtent = {};
                    cssExtent["width"] = "100%";
                    cssExtent["height"]= "100%";
                    this.$css(children[0], cssExtent);
                    if(this.getOrElse(this.model, "value.oneOfChild.className", "") === 'line'){
                       var pxHeight = xfalib.view.util.Styles._convertToPx(this.model.h);
                       var svgHeight = xfalib.view.util.Styles._convertToPx(children[0].getAttribute('height'));
                       if(svgHeight && pxHeight != svgHeight) {
                           this._computeLineHeight();
                       }
                    }
                }
            }

            if(this.model){
                value = this.model.getElement('value',0, true);
            }
            if(value) {
                var  child = value.oneOfChild;
                if (child._modelChanged === true) { //no need to check it here as updateview checks it anyway
                    var jsonVal = child.jsonValue || child.value; // call to child.value will use typedVal and strip off html tags : LC-5427
                    if (child.className === "image" && jsonVal == null) {
                        //for images, if the value is undefined or null return the href attribute
                        jsonVal = child.href;
                    }
                    this._updateView(jsonVal);
                } else { //for draw do it for the very first time as well
                    if (child.className === 'image') { //if draw is of type image
                        if (child.value) {
                            this.$el.children()[0].setAttribute('src',
                                'data:;base64,' + child.value);
                        } else {
                            this.$el.children()[0].setAttribute('src', child.href);
                        }
                    }
                }
            }

            xfalib.view.BaseView.prototype._syncFormNodeToHtml.apply(this, arguments);
        },

        _computeLineHeight : function() {   //lc-5463
           //-- computing line height
          var children = this.$el.children();
          var lineNode ={};
          if(children[0]) {
             lineNode = children[0].childNodes[0];
          }
          var pxHeight = xfalib.view.util.Styles._convertToPx(this.model.h);
          if(lineNode) {
             //--transforming the code from other units to pixel and changing its type to Numer for further computation
             var x1 = xfalib.view.util.Styles._convertToPx(lineNode.getAttribute('x1'));
             var x2 = xfalib.view.util.Styles._convertToPx(lineNode.getAttribute('x2'));
             var y1 = xfalib.view.util.Styles._convertToPx(lineNode.getAttribute('y1'));
             var y2 = xfalib.view.util.Styles._convertToPx(lineNode.getAttribute('y2'));

             var slope = (y2-y1)/(x2-x1);
             if(!isFinite(slope)) {
                y2 = y1 +  pxHeight;
                lineNode.setAttribute('y2',String(y2 +'px'));
                children[0].setAttribute('height',String(pxHeight +'px'));
                this.layoutModel.extenth = pxHeight ;
                var cssHeight = {};
                cssHeight['height'] = String(pxHeight +'px');
                this.$css(this.el, cssHeight);
             }
           /*if(slope == 0) {
                x2 = x1 +  pxHeight;
             }
             if(isFinite(slope) && slope != 0) {
                x2 = x1 +  pxHeight * Math.sin(Math.atan(slope)) ;
                y2 = y1 -  pxHeight * Math.cos(Math.atan(slope)) ;
             }*/
            // lineNode.setAttribute('x2',String(x2 +'px'));

          }
        },

        _initLayout : function(){
            xfalib.view.BaseView.prototype._initLayout.apply(this, arguments);
            if(this._initialized){
                var drawType = this.getOrElse(this.$data(this.el, xfalib.view.LayoutConst.XFA_MODEL)[xfalib.view.LayoutConst.NODE_TYPE], "").toLowerCase();

                if(!$.browser.msie){
                    //All supported browser except IE are not able to gracefully handle 1px svg drawings.
                    // The reason for that, they start draw at grid lines and draw .5px on both sides of gridlines.
                    // Some browsers mix half pixel black with white to produce grey but others may not.
                    // To handle this consistently, we upgrade 1px drawings to 2px for non IE browsers.
                    if(drawType == "line"){
                        this.$('line[stroke-width="1px"]').attr("stroke-width", "2px");
                    }
                    else if(drawType == "rectangle"){
                        this.$('path[stroke-width="1px"]').attr("stroke-width", "2px");
                    }
                }

                if($.browser.webkit || $.browser.chrome || xfalib.ut.Utilities.checkMinMozillaVersion(28)){
                    //chrome handles the rtl text element in a different way.
                    //there is a similar function in FieldView
                    this.$('text[direction="rtl"]').attr('text-anchor', 'end');
                }


                this.$drawChild = $(this._findDrawElement());
                if(drawType == "line"){
                    //For very thin lines less than one pixel, to avoid missing lines, their containing div should be 1px minimum in size
                    if(this.layoutModel.extentw > 0.01 && this.layoutModel.extentw < 1.0)
                        this.layoutModel.extentw  = 1.0;
                    if(this.layoutModel.extenth > 0.01 && this.layoutModel.extenth < 1.0)
                        this.layoutModel.extenth = 1.0;
                }
                if(drawType == "rectangle"){
                    //To avoid missing edges of rectangle, their containing div should be *ceil*ed to next integer. Just heuristic/observation
                    this.layoutModel.extentw = Math.ceil(this.layoutModel.extentw);
                    this.layoutModel.extenth  = Math.ceil(this.layoutModel.extenth);
                }
                this._syncFormNodeToHtml(true);
            }
        },

        _createAccessibilityInfo: function() {
            var screenReaderText = this._getScreenReaderText();
            //add alt for img tags...
            if(screenReaderText && this.$drawChild && this.$drawChild.is("img")){
                this.$drawChild.attr("alt", screenReaderText)
            }
            else if(screenReaderText) {
                $(this).attr("aria-label", screenReaderText)
            }

            // check for heading roles
            var role = this.getOrElse(this.model.getElement("assist"), "role", "");
            if (/^H[1-6]$/.test(role)) {
                this.$el.attr("role", "heading").attr("aria-level", role[1]);
            }
        },

        _assignToolTip: function () {
            var toolTipText = xfalib.ut.XfaUtil.prototype._getToolTipText(this.model);
            if (toolTipText) {
                this.$el.attr("title", toolTipText);
            }
        },

        _getScreenReaderText : function(){
            if (this.model) {
                //find speak priority first ---
                var assist = this.model.getElement("assist", 0, true);
                var screenReaderText;

                var priority = "custom";
                var speak;
                var toolTip;

                if(assist ) {
                    //&& assist.speak && assist.speak.priority
                    speak = assist.getElement("speak", 0, true);
                    toolTip = assist.getElement("toolTip", 0, true);
                    if(speak) {
                        priority = speak.getAttribute('priority');
                    }
                }

                if(priority == "custom") {
                    if(speak) {
                        screenReaderText = speak.value;
                    }
                    else if(toolTip) {
                        screenReaderText = toolTip.value; //LC-6805: tooltip is shown as [Object Object] for text objects
                    }
                    else if(this.model.jsonModel.extras) {
                        screenReaderText = this.model.jsonModel.extras.caption;
                    }
                    else {
                        screenReaderText = this.model.jsonModel.name;
                    }
                }
                else if(priority == "toolTip") {
                    if(toolTip) {
                        screenReaderText = toolTip.value;
                    }
                    else if(this.model.jsonModel.extras) {
                        screenReaderText = this.model.jsonModel.extras.caption;
                    }
                    else {
                        screenReaderText = this.model.jsonModel.name;
                    }
                }
                else if(priority == "name") {
                    screenReaderText = this.model.jsonModel.name;
                }
                 return screenReaderText;

            }
        },

        _computeDrawChildExtent : function(){
            var extent = {};
            var drawType = this.getOrElse(this.$data(this.el, xfalib.view.LayoutConst.XFA_MODEL)[xfalib.view.LayoutConst.NODE_TYPE], "").toLowerCase();
            if(drawType == "text"){
                //This is to avoid truncation of svg text when SVG is larger than containing div.
                //In that case we allow SVG to be large upto extent of 120% of the assigned draw extents
                // Each browser handles svg differently. Below fix works for all supported browser and avoid 20% truncation which would handle most common cases.
                // Actual fix would require exact combined svg height/width calculation probably in XTG side.
                extent["width"] = "120%";
                extent["height"]= "120%";
            } else {
                //Required so that draw do not spill out of their parent div.
                extent["width"] = "100%";
                extent["height"]= "100%";
            }
            return extent;
        },

        _findDrawElement : function(){
            var drawEls = this.$el.children();
            if(drawEls.length >0)
                return drawEls.get(0);
        },

        updateDisplay : function(){
            xfalib.view.BaseView.prototype.updateDisplay.apply(this, arguments);
            if(this.$drawChild != null && !this.$drawChild.is("img")) {
                //only set extent if it is not img as img has its own extent
                var drawChildExtent = this._computeDrawChildExtent();
                //do this only if
                if(this.$drawChild.length)
                    this.$css(this.$drawChild.get(0), drawChildExtent);

            }
        }

    });
})(_, $, xfalib);
(function(_, $, xfalib){
    var btwn = xfalib.ut.XfaUtil.prototype.btwn;

    xfalib.view.FieldView =  xfalib.view.BaseView.extend({
        //list of RTL languages
        _rtlLang:{he : "he", ar : "ar", fa: "fa"},

        _addOns:{
            "x-scribble-add-on" : xfalib.template.Constants.ScribbleImageField
        },
        initialize : function() {
            xfalib.view.BaseView.prototype.initialize.apply(this, arguments);
            this.captionLayoutModel = null;
            this.widgetLayoutModel = null;
            this.jqWidget = null;
            this.commitEvent = this.options.commitEvent;
            this.commitProperty = this.options.commitProperty;
            this.commitTarget = this.options.commitTarget;
            this.isError = false;

            this.caption = this._findCaption();
            this.widget = this._findWidget();
            if (this.widget) {
                this.createBorderForWidget();
                if(this.commitEvent != null) {
                    $(this.widget).on(this.commitEvent,
                        this._bind(this, this.handleCommit));
                }
                $(this.widget).on(xfalib.ut.XfaUtil.prototype.XFA_CLICK_EVENT,
                    this._bind(this, this.handleClickEvent));
                $(this.widget).on(xfalib.ut.XfaUtil.prototype.XFA_EXIT_EVENT,
                    this._bind(this, this.handleFocusOut));
                $(this.widget).on(xfalib.ut.XfaUtil.prototype.XFA_CHANGE_EVENT,
                    this._bind(this, this.handleChangeEvent));
                $(this.widget).on(xfalib.ut.XfaUtil.prototype.XFA_ENTER_EVENT,
                    this._bind(this, this.handleFocusEvent));
                $(this.widget).on("keypress",
                    this._bind(this, this.handleKeyPressEvent));
                $(this.widget).on(xfalib.ut.XfaUtil.prototype.XFA_PREOPEN_EVENT,
                    $.proxy(this.handlePreOpenEvent, this));
            }
            var that = this;
            if(this.caption) {
                this.$css(this.caption,{"cursor":"default"});
                //add presentation role to caption
                $(this.caption).attr("role", "presentation")
            }
            $(this.$el).on("mousedown", $.proxy(this._handleMouseDown,this))
                       .on("click", function(event) {
                            if(that.model.mEffectiveAccess != "open") {
                               return;
                            }
                            //label is clicked click the widget
                            if(!$(event.target).closest(".widget").length) {
                                that.jqWidget.click();
                            }
                        });
            this._initLayout();
        },

        createBorderForWidget : function(){
            if(this.model){
                var ui = this.model.getElement("ui", 0,true);
                var fill,color ;
                if(ui) {
                    var border = ui.oneOfChild.getElement("border", 0,true);
                    if(border && border.presence == "visible") {
                        if(this.caption  && parseInt(this.model.caption.getAttribute("reserve"))!=0  && this.model.parent.className !="exclGroup"){
                            var cssStyleObj = xfalib.view.util.Styles.getStyleForBorder(border);
                            if(cssStyleObj)
                                this.$css(this.widget, cssStyleObj);
                        } else if(!this.edgePresence  && this.model.parent.className !="exclGroup") {
                            var cssStyleObj = xfalib.view.util.Styles.getStyleForBorder(border);
                            if(cssStyleObj)
                                this.$css(this.widget, cssStyleObj);
                        }
                    }
                    if(border && (fill = border.getElement("fill",0,true)) && (color = fill.getElement("color",0,true))
                        && fill.presence!="hidden"
                        && fill.presence !="invisible"
                       ) {
                        var color = color.value;
                        if(color == "")
                            color="255,255,255";  // if no color value is specified then fill default color
                        color = "rgb(" + color + ")";
                        $(this.widget).css("background-color", color);
                    }
                }
            }
        },


        _handleMouseDown: function(event) {
            if( !$(event.target).closest(".widget").length && xfalib.view.FieldView.prototype.currentFocus == this ) {
                this.clickedOnCaption = true;
            }
        },

        _markAccess : function(access) {
            switch(access) {
                case "open" :
                    $(this.widget).removeClass("widgetreadonly");
                    break;
                case "nonInteractive" :
                case "protected" :
                    $(this.widget).addClass("widgetreadonly");
                    break;
                case "readOnly" :
                    $(this.widget).addClass("widgetreadonly");
                    break;
            }
        },

        _initLayout : function(){
            xfalib.view.BaseView.prototype._initLayout.apply(this, arguments);
            if(this._initialized){
                this._initializeFieldChildLayoutAndExtent();
                this._syncFormNodeToHtml(true);
                this.markMandatory();
                this.$css(this.el, {"z-index": 2});
                if(this.caption){
                    //This is to avoid truncation of svg text when SVG is larger than containing div.
                    //In that case we allow SVG to be large upto extent of 120% of the assigned draw extents
                    // Each browser handles svg differently. Below fix works for all supported browser and avoid 20% truncation which would handle most common cases.
                    // Actual fix would require exact combined svg height/width calculation probably in XTG side.
                    var captionSVG = $(this.caption).children("svg").get(0);

                    // Due to extra 20%, Button-1 and Button-2 placed next to each other overlaps.
                    // So when clicking on Button-2, click on Button-1 gets triggered because of Button-1 overlapping area
                    // Removing extra 20% and hiding overflown SVG text for button field.

                    // Checking for submit and radio button
                    var hasParentButtonField = $(this.caption).parent().length && $(this.caption).parent().hasClass('buttonfield');
                    var hasSiblingButtonField = $(this.caption).siblings().length && $(this.caption).siblings().hasClass('buttonfieldwidget');
                    var hasParentRadioButtonField = $(this.caption).parent().length && $(this.caption).parent().hasClass('radiofield');
                    var hasSiblingRadioButtonField = $(this.caption).siblings().length && $(this.caption).siblings().hasClass('radiofieldwidget');
                    if(captionSVG){
                        $(captionSVG).attr('focusable', 'false'); //LC-7105 LC-5444 svg tabIndex doesn't work so adding focusable as false
                        //CQ-4274732 : To prevent svg being read out. Caption(svg) and input both are being read by screen reader, only focussable should be read.
                        $(captionSVG).attr('aria-hidden', 'true');
                        var captionChildExtent = {};
                        if((hasParentButtonField && hasSiblingButtonField) || (hasParentRadioButtonField && hasSiblingRadioButtonField)){
                            captionChildExtent["width"] = "100%";
                            captionChildExtent["height"]= "100%";
                            $(this.caption).css("overflow", "hidden");
                        }else{
                            captionChildExtent["width"] = "120%";
                            captionChildExtent["height"]= "120%";
                        }
                        this.$css(captionSVG, captionChildExtent);
                        if($.browser.webkit || $.browser.chrome || xfalib.ut.Utilities.checkMinMozillaVersion(28)){
                            //chrome handles the rtl text element in a different way.
                            //there is a similar function in XfaDrawView
                            $(captionSVG).children('text[direction="rtl"]').attr('x', this._adjustTextCoordinate);

                        }
                    }
                }
                //Invalidate the tab indexes for the page containing this field when this field is initialized.
                //This would just queue the tabbing computation for this particular page.
                this._xfaViewRegistry().invalidateTabIndex(this._pageNumber());
            }
        },

        handlePreOpenEvent: function(event) {
                this.model.execEvent("preOpen");
        },

        handleFocusEvent: function(event) {
            if(!this.clickedOnCaption) {
                this.model._xfa().setSubformFocus(this.model.parentSubform);
                this.model.execEvent("enter");
            }
            this.clickedOnCaption = false; // reset the state
            xfalib.view.FieldView.prototype._setFocusParam(this);
            if(formBridge) {
                if(formBridge.isAnalyticsEnabled) {   //Only computing when analytics enabled
                    var prevFocus=xfalib.view.FieldView.prototype.prevFocus,
                        currFocus=xfalib.view.FieldView.prototype.currentFocus;
                    if(prevFocus){  //if prevFocus is already null then no need to pass SOM Expression
                        prevFocus=prevFocus.model.somExpression;
                    }
                    if(currFocus){ //if currFocus is already null then no need to pass SOM Expression
                        currFocus=currFocus.model.somExpression;
                    }
                    xfalib.ut.XfaUtil.prototype._triggerOnBridge("elementFocusChanged", this.model, "focus", prevFocus, currFocus);
                }
                formBridge.clickedOnWindow = false;
            }
        },

        handleFocusOut : function(event) {
            if(!this.clickedOnCaption) {
                this.model.execEvent("exit");
            }
            if(formBridge && formBridge.clickedOnWindow === true) {
                xfalib.view.FieldView.prototype._setFocusParam(null);
                formBridge.clickedOnWindow = false;
            }
        },

        _setFocusParam : function(currFocus) {
            xfalib.view.FieldView.prototype.prevFocus = xfalib.ut.Class.prototype.getOrElse(xfalib.view.FieldView.prototype.currentFocus, null);
            //To minimize regression impact as "xfalib.view.FieldView.prototype.currentFocus" is used at all the places in the code
            xfalib.view.FieldView.prototype.currentFocus=currFocus;
        },

        _clearFocusInfo : function() {
            xfalib.view.FieldView.prototype.prevFocus = null;
            xfalib.view.FieldView.prototype.currentFocus=null;
        },

        handleKeyPressEvent: function(event) {
            var code = event.charCode || event.which || event.keyCode || 0;
            var character = String.fromCharCode(code);

            if(xfalib.ut.XfaUtil.prototype.isNonPrintableKey(event.key)) { // mozilla also generates a keypress, along with keydown
                return true;                                               // for all keys, so only handling printable keys in keypress
            }

            if(this.character != undefined) { // takes care of cases when xfa.event.change is set by user script
                if(this.character == null) {
                    this.jqWidget.option("value",this.jqWidget.option("curValue"));
                    this.jqWidget.option("displayValue",this.jqWidget.option("curValue"));
                }
                else if(this.character != character &&
                    !(event.key === "Enter" && this.character === "\n")) {
                    //String.fromCharCode returns \r for Enter key, but character is \n - ignore this mismatch
                    this.jqWidget.option("value",this.current);
                    this.jqWidget.option("displayValue",this.current);
                    event.preventDefault();
                }
                this.character = undefined;
            }
        },

        _syncFormNodeToHtml : function(deepSync) {
            var pluginOptions = this._createPluginOptions();
            if(!this.jqWidget)
                this.createWidgetPlugin(pluginOptions);
            else {
                _.each(pluginOptions, function(value, key){
                    this.jqWidget.option(key, value);
                }, this);
            }
            this._markAccess(this.model.mEffectiveAccess)
            if(this.model.__errorText)
                this._deferredMarkError();
            xfalib.view.BaseView.prototype._syncFormNodeToHtml.apply(this, arguments);
        },

        handleModelChanged : function(event) {
            if (event._property == this.commitTarget) {
                this._handleValueChange(event);
            }
            else{
                switch(event._property) {
                    case "focus":
                        this._focusWidget(this);
                        break;
                    case "ValidationState" :
                        this._markError(event);
                        break;
                    case "change":
                        this._handleEventChangeProperty(event);
                        break;
                    case "ClearError":
                        this._clearError(event);
                        break;
                    case "fillColor":
                        this._fillColor(event.newText);
                        break;
                    default:
                        xfalib.view.BaseView.prototype.handleModelChanged.apply(this,
                            arguments);
                }

            }
        },

        handleDomChanged :function(event){
            switch(event._property) {
                case "font.fill.color.value":
                    this._handleFontFillColorValue(event.prevText);
                    break;
                case "font.posture":
                    this._handleFontPosture(event.prevText);
                    break;
                case "value.maxChars":
                    this._handleMaxChars(event);
                    break;
                case "caption.font.fill.color.value":
                    this._handleCaptionFontFillColorValue(event);
                    break;
                case "nullTest":
                    this._handleNullTest(event, $(this.widget));
                    break;
                default:
                    xfalib.view.BaseView.prototype.handleDomChanged.apply(this, arguments);
            }
        },

        _handleNullTest: function (event, $target) {
            this._handleMandatory(event.newText, $target);
            this._handleDisabled(event);
        },

        _handleMandatory: function (change, $target) {
            if (_.contains(['disabled', 'warning'], change)) {
                $target.attr('data-mandatory', 'false')
                       .removeClass('widgetMandatoryBorder');
            } else if (change === 'error') {
                $target.attr('data-mandatory', 'true')
                       .toggleClass("widgetMandatoryBorder", xfalib.globals.highlight);
            }
        },

        _handleDisabled: function(event){
           var change = event.newText;
           if (change === 'disabled') {
              this._clearError(event);
           }
        },


        _handleCaptionFontFillColorValue :function(event) {
            var childSvg = this.caption.children[0];
            var fill = "rgb(" + event.prevText + ")" ;

            if(childSvg.tagName == "svg" && childSvg.childNodes) {
              _.each(childSvg.childNodes,function(node,index){
                if(node.tagName == 'text') {
                    this.$css(node,{'fill' : fill});
                }
              },this);
            }
        },

        _handleFontFillColorValue : function (value) {
            this.jqWidget.option("color", value);
        },

        _handleFontPosture : function (value) {
            this.jqWidget.option("font-style", value);
        },

        _handleMaxChars : function(event) {
            var maxchars = event.prevText;
            if(maxchars)
                this.jqWidget.option("maxChars",event.prevText);
        },

        handleCommit : function(event) {
            var resizeRqd = false;
            if(this.resizable && this.jqWidget.option("value") != this.model[this.commitTarget])
                resizeRqd = true;
            this.model[this.commitTarget] = this.jqWidget.option("value");
            if(resizeRqd)
                this.invalidateSize();
        },

        handleChangeEvent : function(changeEvent) {
            var current,
                event = changeEvent.originalEvent,
                maxChars = parseInt(this.jqWidget.option("maxChars") || this.jqWidget.option("combCells")) || 0, // to take care for both text & numeric fields
                val = this.jqWidget.option("curValue") || this.jqWidget.option("displayValue") || '',
                selectionStart = event.selectionStart,
                selectionEnd = event.selectionEnd,
                code = event.charCode || event.keyCode || event.which,
                character = event.character || '',
                change,
                fullText;

            if(event.originalType == "cut") {
                change = "";
                if(val) {
                    current = val.substr(0, selectionStart) + val.substr(selectionEnd);
                    fullText = current;
                }
            } else if(event.originalType == "keydown") {
                change = "";

                if(val) {
                    if (code == 8 || code == 46) {  // backSpace or Del
                        if (selectionStart !== selectionEnd) {
                            current = val.substr(0, selectionStart) + val.substr(selectionEnd);
                        } else {
                            if (code == 8) {  // backspace
                                current = val.substr(0, selectionStart - 1) + val.substr(selectionStart);
                            }
                            if (code == 46) {  // del
                                current = val.substr(0, selectionStart) + val.substr(selectionStart + 1);
                            }
                        }
                    }
                } else {
                    current = val;
                }
                fullText = current;
            }
            else { // keypress or paste
                change = character;
                if (maxChars > 0 ) {
                    if (val.length - (selectionEnd - selectionStart) >= maxChars) {
                        change = "";
                    } else {
                        change = character.substr(0, maxChars - val.length + selectionEnd - selectionStart);
                    }
                }

                if (val) {
                    current = val.substr(0, selectionStart) + change + val.substr(selectionEnd);
                    fullText = val.substr(0, selectionStart) + character + val.substr(selectionEnd);

                } else {
                    current = change;
                    fullText = character;
                }

                if( (maxChars !=0 && current.length  > maxChars) || !this.jqWidget.option("lengthLimitVisible") ) {
                    change = "";
                    current = val;
                }

                // LC-6290 : prevent paste from truncating any of the previous text
                if (event.originalType == "paste" &&
                    ((maxChars != 0 && fullText.length > maxChars) || !this.jqWidget.option("lengthLimitVisible"))) { // TODO : take care of multiline selection later
                    var self = this;
                    self.jqWidget.$userControl.one("input", function () {  // wait till the paste action occurs and then replace with correct value
                        self.jqWidget.$userControl.val(current)
                                                  .prop("selectionStart", selectionEnd) // LC-6290 : reset the cursor pos afterwards
                                                  .prop("selectionEnd", selectionEnd);
                    });
                }
            }

            var detail = {
                prevText:val,
                keycode:code,
                modifier:event.ctrlKey,
                keyDown: event.keyDown,
                shift:event.shiftKey,
                change:change,
                newText:current,
                fullText: fullText
            };
            if(!!change || current != val)
                this.model.execEvent("change", detail);
        },

        handleClickEvent : function(event) {
            var prevValue= this.jqWidget.option("value");
            var detail = {
                keycode:event.which,
                modifier:event.ctrlKey,
                shift:event.shiftKey
            };
            this.model.execEvent("click", detail);
        },

        _handleEventChangeProperty : function(event) {
            this.character = event.prevText;
            var prevValue= this.jqWidget.option("curValue") || this.jqWidget.option("displayValue") || "";
            var pos = this.jqWidget.options.pos ;
            this.current = prevValue.substr(0, pos) + this.character + prevValue.substr(pos);
            //var value = this.jqWidget.option("value") || "" ;
            //var displayValue = this.jqWidget.option("displayValue") || ""   ;

        },

        _handleValueChange : function(event) {
            //xfa.Logger.debug("[FieldView._handleValueChange]value:som"
            //        + event.newText + ":" + this.$el.data("som"));
            var resizeRequired =  (this.jqWidget.option("displayValue") != event.newText) && this.resizable ;
            this.jqWidget.option("value",event.prevText);
            this.jqWidget.option("displayValue",event.newText);
            if(resizeRequired){
                this.invalidateSize();
            }
        },

        _markError : function(evnt) {
            //this.$css(this.widget, "background-color","#D3D3D3");
            $(this.widget).addClass("widgetError");
            this.jqWidget.markError(evnt.newText, evnt.prevText);
            this._updateWidgetOption("isValid",false);
        },

        _deferredMarkError : function() {
            //this.$css(this.widget, "background-color","#D3D3D3");
            if(this.model.mandatory == "error")
                $(this.widget).addClass("widgetError");
            this.jqWidget.markError(this.model.__errorText, this.model.mandatory);
            this._updateWidgetOption("isValid",false);
        },

        _clearError : function(evnt) {
            //this.$css(this.widget, "background-color", "white");
            $(this.widget).removeClass("widgetError");
            this.jqWidget.clearError();
            this._updateWidgetOption("isValid",true);
        },

        // for all fields
        _updateWidgetOption: function(optionName, optionValue){
            this.jqWidget.option(optionName, optionValue);
        },

        _handleAccessChange : function(event) {
            //xfa.Logger.debug("[_handleAccessChange]access:som"
            //        + event.newText + ":" + this.$el.data("som"));
            this.jqWidget.option("access",event.newText);
            if(event.newText != event.prevText)
                this._markAccess(event.newText)
        },

        _findWidget : function() {
            if (this.$el.hasClass("widget"))
                return this.$el.get(0);
            else {
                var widgetList = this.$el.find(".widget");
                if (widgetList.length > 0){
                    return widgetList.get(0);
                }
            }
        },
        _findCaption : function() {
            var captionList = $(".caption", this.$el);
            if (captionList.length > 0){
                return captionList.get(0);
            }
        },

        _getParaStyles : function(){
            var paraStyles = {},para;
            para = this.model.getElement("para", 0, true);
            if(para){
                paraStyles = {
                    "text-align" : para.hAlign,
                    "vertical-align" : para.vAlign,
                    "text-indent" : this._convertToPx(para.textIndent),
                    "padding-left" : this._convertToPx(para.marginLeft),
                    "padding-right" : this._convertToPx(para.marginRight),
                    "padding-top" : this._convertToPx(para.spaceAbove),
                    "padding-bottom" : this._convertToPx(para.spaceBelow)
                };
            }
            return paraStyles;
        },

        _createPluginOptions : function() {
            if(this.model){
                var value = this.model[this.commitTarget] || null;
                var screenReaderText;
                screenReaderText = this._getScreenReaderText();
                var tabIndex = 0;
                if(this.model.jsonModel.extras && this.model.jsonModel.extras.tabIndex) {
                    tabIndex = this.model.jsonModel.extras.tabIndex;
                }

                var lang = this._langFromLocale(this.model._getLocale());
                var direction;

                if(lang && this._rtlLang[lang]){
                    direction = "rtl";
                }

                var paraStyles = this._getParaStyles();
                var widgetModel = this.widgetLayoutModel || this.layoutModel;
                return {
                    "name" : this.model.jsonModel.name+""+this._id,
                    "value" : value,
                    "displayValue": this.model.formattedValue,
                    "commitProperty" : this.commitProperty,
                    "access": this.model.mEffectiveAccess,
                    "platform": this.model._xfa().host.platform,
                    "screenReaderText": screenReaderText,
                    /*"tabIndex": tabIndex,*/
                    "paraStyles" : paraStyles,
                    "dir" : direction,
                    "hScrollDisabled" : !this.resizable && this.model.ui.oneOfChild.hScrollPolicy === "off",
                    "height" : widgetModel.extenth + widgetModel.bordertop/2 + widgetModel.borderbottom/2,
                    "commitEvent" : this.commitEvent
                };
            }

        },

        _getScreenReaderText: function () {
            var screenReaderText = "";
            if (this.model) {
                var assist = this.model.getElement("assist", 0, true);
                if (this.getOrElse(assist, "speak.disable", 0) != 1) { // loose compare string value

                    var priority = this.getOrElse(assist, "speak.priority", "speak"),
                        candidates = {
                            "speak": this.getOrElse(assist, "speak.value", ""),
                            "caption": this.getOrElse(this.model, "jsonModel.extras.caption", ""),
                            "toolTip": this.getOrElse(assist, "toolTip.value", ""),
                            "name": this.getOrElse(this.model, "jsonModel.name", "")
                        };

                    screenReaderText = candidates[priority] ||
                                       candidates["speak"] ||
                                       candidates["caption"] ||
                                       candidates["toolTip"] ||
                                       candidates["name"];
                    // CQ-85183 : going against xfa spec (pg 505) prioritise caption over tooltip
                }
            }
            return screenReaderText;
        },

        _assignToolTip: xfalib.view.XfaDrawView.prototype._assignToolTip,

		_instantiateWidget:function(widgetName,options){
		    if (widgetName && widgetName.length > 0) {
                    try{
                        $(this.widget)[widgetName](options);
                        return this.$data(this.widget, widgetName) ||
                               this.$data(this.widget, "xfaWidget-"+widgetName);
                    } catch(exception) {
                        xfalib.runtime.xfa.Logger.error("xfaView", "exception "+exception.message+" in creating user widget. widget:"+widgetName);
                    }
            }
		},
        _createScribbleWidgetOptions:function(options){
            var initParams = this.getOrElse(this.model.ui,"extras.children",null);
            var geoLocParam = _.find(initParams,function(obj){
	            return obj&&obj.name=="geoLocMandatoryOnIpad";    
            });

            var geoLocMandatoryOnIpad = (geoLocParam&&geoLocParam.value) || ( window.formBridge.userConfig
                                         && window.formBridge.userConfig['scribbleImageFieldConfig']
                                         && window.formBridge.userConfig['scribbleImageFieldConfig'].geoLocMandatoryOnIpad );
            return _.extend({
                              geoLocMandatoryOnIpad:geoLocMandatoryOnIpad
                            },options);
        },
        createWidgetPlugin : function(options) {
            var widgetConfig = this._xfaViewRegistry().widgetConfig();
            var widgetName;
			
            if(widgetConfig){
                    widgetName = _.filter(widgetConfig,
                    function(widgetName, selector){
                        if(this.$el.filter(selector).length >0)
                            return true;
                        else
                            return false;
                    },
                    this)[0];
            } 

            this.jqWidget = this._instantiateWidget(widgetName,options);
			
            if(!this.jqWidget){
                widgetName = this._getWidgetNameFromUiExtra();
                if (widgetName) {
                    this.jqWidget = this._instantiateWidget(widgetName, this._createScribbleWidgetOptions(options));
                }
            }
			
            if(!this.jqWidget){
					this._createDefaultWidgetPlugin(options);
			}
            xfalib.runtime.xfa.Logger.debug("xfaView", "creating user widget. widget:" + this.jqWidget._widgetName
            + " for " + this.model.somExpression);
        },

        /**
        * returns the name of the widget present in ui extras
        * @returns {string} widgetName
        */
        _getWidgetNameFromUiExtra : function () {
            var widgetName = null,
                uiExtrasName = this.getOrElse(this,"model.ui.extras.name",null);
            if(uiExtrasName && uiExtrasName.length >= 2 && this._addOns.hasOwnProperty(uiExtrasName)){
                widgetName = this._addOns[uiExtrasName];
            }
            return widgetName;
        },

        _createDefaultWidgetPlugin : function(options) {
            $(this.widget).defaultWidget(options);
            this.jqWidget = this.$data(this.widget, "xfaWidget-defaultWidget");
        },

        markMandatory : function(){
            if(this.model.mandatory== "error")
                if(this.widget)
                    $(this.widget).attr("data-mandatory", "true") ;

        },

        _initializeFieldChildLayoutAndExtent : function() {
            if (this.caption) {
                var cView = _.extend({}, xfalib.view.BaseView.prototype, {
                    el : this.caption,
                    $el : $(this.caption)
                });
                xfalib.view.BaseView.prototype._initializeLayoutModel.apply(cView);  //TODO: handle things when moving layout to formDom
                this.captionLayoutModel = cView.layoutModel;
            }
            if (this.widget && this.caption) {
                var wView = _.extend({}, xfalib.view.BaseView.prototype, {
                    el : this.widget,
                    $el : $(this.widget)
                });
                xfalib.view.BaseView.prototype._initializeLayoutModel.apply(wView);
                this.widgetLayoutModel = wView.layoutModel;
            }
        },

        _getMeasurementOptions : function(){
            var widgetModel = this.widgetLayoutModel || this.layoutModel;
            return ({
               refEl : this.jqWidget && this.jqWidget.$userControl ? this.jqWidget.$userControl[0] : null,
               width : (widgetModel.extentw - widgetModel.marginleft - widgetModel.marginright),
               height : (widgetModel.extenth - widgetModel.margintop - widgetModel.marginbottom),
               minWidth : (widgetModel.extentminw>-1)?(widgetModel.extentminw - widgetModel.marginleft - widgetModel.marginright):widgetModel.extentminw,
               minHeight :(widgetModel.extentminh>-1)?(widgetModel.extentminh - widgetModel.margintop - widgetModel.marginbottom):widgetModel.extentminh,
               maxWidth : (widgetModel.extentmaxw > -1)?(widgetModel.extentmaxw - widgetModel.marginleft - widgetModel.marginright):widgetModel.extentmaxw,
               maxHeight :(widgetModel.extentmaxh > -1)?(widgetModel.extentmaxh - widgetModel.margintop - widgetModel.marginbottom):widgetModel.extentmaxh
            });
        },

        measureSize : function(){
            var resized = false;
            if(this.resizable){
                var text = (this.model && this.model[this.commitTarget]!= null)? this.model[this.commitTarget] : "";
                resized = this._updateWidgetModel(text);
                if(resized && this.caption && this.widget && this.model.caption) {
                    switch(this.model.caption.getAttribute("placement")){
                        case "left":
                        case "right":
                            this.layoutModel.extentw  = this.layoutModel.marginleft + this._getCaptionReservedW() + this.widgetLayoutModel.extentw + this.layoutModel.marginright;
                            this.layoutModel.extenth = this.layoutModel.margintop + Math.max(this._getCaptionReservedH(), this.widgetLayoutModel.extenth) + this.layoutModel.marginbottom;
                            break;
                        case "top":
                        case "bottom":
                            this.layoutModel.extentw = this.layoutModel.marginleft + Math.max(this._getCaptionReservedW(), this.widgetLayoutModel.extentw) + this.layoutModel.marginright     ;
                            this.layoutModel.extenth  = this.layoutModel.margintop + this._getCaptionReservedH() + this.widgetLayoutModel.extenth + this.layoutModel.marginbottom;
                            break;
                    }
                }
            }
            return resized;
        },

        /**
         * @function
         * To update height and width of widget model
         * @param {String} text : text to be used to compute new height and width
         * return true if height or width updated else false
         */
        _updateWidgetModel : function (text) {
            var spaceAbove = 0,
                spaceBelow = 0,
                para = this.getOrElse(this, "model.para", null),
                resized = false,
                measureOptions = this._getMeasurementOptions(),
                measuredExtent = xfalib.view.util.TextMetrics.measureExtent(text, _.clone(measureOptions)),
                widgetModel = this.widgetLayoutModel || this.layoutModel;

            if(para) {
                spaceAbove = para.spaceAbove;
                spaceBelow = para.spaceBelow;
            }

            if(measureOptions.width != measuredExtent.width || measureOptions.height != measuredExtent.height) {
                resized = true;
                if(measureOptions.width != measuredExtent.width) {
                    widgetModel.extentw = widgetModel.marginleft + measuredExtent.width + widgetModel.marginright;
                }
                if(measureOptions.height != measuredExtent.height) {
                    widgetModel.extenth = widgetModel.margintop + measuredExtent.height + widgetModel.marginbottom + this._convertToPx(spaceAbove)
                        + this._convertToPx(spaceBelow);
                }
            }
            return resized
        },

        _getCaptionReservedW: function() {
            if(this.caption && this.model.caption){
                switch(this.model.caption.getAttribute("placement")) {
                    case "left" :
                    case "right" :
                        //in case left and right, "reserve" dictates the width of the caption
                        var reserve = this.model.caption.getAttribute("reserve");
                        return (reserve != "-1" ? this._convertToPx(reserve) : 0);
                        break;
                    case "top" :
                    case "bottom" :
                        return this.captionLayoutModel.extentw;
                        break;
                }
            }
            return 0;
        },

        _getCaptionReservedH: function() {
            if(this.caption && this.model.caption){
                switch(this.model.caption.getAttribute("placement")) {
                    case "left" :
                    case "right" :
                        return this.captionLayoutModel.extenth;
                        break;
                    case "top" :
                    case "bottom" :
                        //in case top and bottom, "reserve" dictates the height of the caption
                        var reserve = this.model.caption.getAttribute("reserve");
                        //CQ-102341 : Layout of older forms got disturbes which had no reserve value. So if no reserve is found the older value i.e this.captionLayoutModel.extenth is returned
                        return (this._isReservePresent(reserve) ? this._convertToPx(reserve) : this.captionLayoutModel.extenth);
                        break;
                }
            }
            return 0;
        },

        _isReservePresent: function(reserve) {
            try {
                return !(reserve == "-1" || parseFloat(reserve.replace(/[^-\d\.]/g, '')) == 0);
            } catch(exception) {
                xfalib.runtime.xfa.Logger.warn("xfa","issue with parseFloat of reserve , reserve value :" + reserve);
                return false;
            }
        },

        _calculateDisplay : function(capExtent,wExtent) {
             wExtent["width"] = this.widgetLayoutModel.extentw + this.widgetLayoutModel.borderleft/2 + this.widgetLayoutModel.borderright/2 ;
             wExtent["height"] = this.widgetLayoutModel.extenth + this.widgetLayoutModel.bordertop/2 + this.widgetLayoutModel.borderbottom/2 ;
             switch(this.model.caption.placement) {
               case "left" :
                  capExtent["left"] = this._padLeft();
                  capExtent["top"] = this._padTop();
                  wExtent["left"] = this._padLeft() + this._getCaptionReservedW();
                  wExtent["top"] = this._padTop();
                  break;
               case "right" :
                  capExtent["right"] = this._padRight();
                  capExtent["top"] = this._padTop();
                  wExtent["right"] = this._padRight() + Math.max(this._getCaptionReservedW(), capExtent["width"]);
                  wExtent["top"] = this._padTop();
                  break;
               case "top" :
                  capExtent["left"] = this._padLeft();
                  capExtent["top"] = this._padTop();
                  wExtent["left"] = this._padLeft();
                  wExtent["top"] = this._padTop() + this._getCaptionReservedH();
                  break;
               case "bottom" :
                  capExtent["left"] = this._padLeft();
                  capExtent["bottom"] = this._padBottom();
                  wExtent["left"] = this._padLeft();
                  wExtent["bottom"] = this._padBottom()  + this._getCaptionReservedH();
                  break;
           }
       },

        updateDisplay : function(){
            xfalib.view.BaseView.prototype.updateDisplay.apply(this, arguments);
            if(this.caption && this.widget){
                var parentPadLeft = this._padLeft();
                var parentPadTop = this._padTop();
                var capExtent = {};
                var wExtent = {};
                capExtent["width"] = this.captionLayoutModel.extentw + this.captionLayoutModel.borderleft/2 + this.captionLayoutModel.borderright/2 ;
                capExtent["height"] = this.captionLayoutModel.extenth + this.captionLayoutModel.bordertop/2 + this.captionLayoutModel.borderbottom/2 ;
                this._calculateDisplay(capExtent,wExtent);
                this.jqWidget.option("width",this.widgetLayoutModel.extentw - this.widgetLayoutModel.marginleft - this.widgetLayoutModel.marginright)
                             .option("height",this.widgetLayoutModel.extenth - this.widgetLayoutModel.marginbottom - this.widgetLayoutModel.margintop)
                this.$css(this.caption, capExtent);
                this.$css(this.widget, wExtent);
            }
            else {
                this.jqWidget.option("width",this.layoutModel.extentw - this.layoutModel.marginleft - this.layoutModel.marginright)
                             .option("height",this.layoutModel.extenth - this.layoutModel.marginbottom - this.layoutModel.margintop)
            }
        },

        updateTabIndex : function(newTabIndex){
            this.jqWidget.option("tabIndex", newTabIndex);
        },

        // CQ-102472 : Overriding BaseView _handleBorderChange, as in case of field with no caption, field border color gets assigned to widget border as no caption and field divs are present
        _handleBorderChange : function(event) {
            if (this.caption || this.model.border.edge.getAttribute("thickness", false)) {
                var cssStyleObj = xfalib.view.util.Styles.getStyleForBorder(this.model.border);
                if(cssStyleObj) {
                    this.$css(this.el, cssStyleObj);
                }
            }
        }

    });
})(_, $, xfalib);

(function(_, $, xfalib){
    xfalib.view.CheckButtonFieldView = xfalib.view.FieldView.extend({

        initialize : function(){
            xfalib.view.FieldView.prototype.initialize.apply(this, arguments);
        },

        _createDefaultWidgetPlugin :  function(options){
            if(this.model){
                options.size =  this.model.ui.oneOfChild.size;
                options.state = this.model.selectedIndex;
                options.states = this.model.ui.oneOfChild.allowNeutral == "1" ? 3:2;  // #bug=3650920, typeof allowNeutral is string
                $(this.widget).XfaCheckBox(options);
                this.jqWidget = this.$data(this.widget, "xfaWidget-XfaCheckBox");
            }
            else{
                xfalib.view.FieldView.prototype._createDefaultWidgetPlugin.apply(this, [options]);
            }
        },

        /*
        //Note: The screenreader text for exclusion group should not behave differently, and should be aligned to PDF.
        //Reference: CQ-81875 (AEM Forms show radio button name included with tooltip)
        _getScreenReaderText: function() {
            var screenReaderText =  xfalib.view.FieldView.prototype._getScreenReaderText.apply(this),
                screenReaderTextParent;
            if(this.model.parent && this.model.parent._isExclusionGroup()) {
                screenReaderTextParent = this.parentView._getScreenReaderText();
                if(screenReaderTextParent) {
                    screenReaderTextParent = screenReaderTextParent + " " ;
                    if(screenReaderText) {
                        screenReaderText= screenReaderTextParent  +   screenReaderText;
                    } else {
                        screenReaderText = screenReaderTextParent;
                    }
                }
            }
                return  screenReaderText ;

        },
        */
        _handleMouseDown: function(event) {
            if(xfalib.view.FieldView.prototype.currentFocus == this) {
                this.clickedOnCaption = true;
            }
        },

        createBorderForWidget : function(){
        },

        handleChangeEvent : function(event) {
            if(this.model.parent.className == "exclGroup") {
                this.model.parent.execEvent("change");
            }
            this.model.execEvent("change");
        },

        handleClickEvent : function() {
            if(this.model.parent.className == "exclGroup") {
                this.model.parent.execEvent("click");
            }
            this.model.execEvent("click");
        },

        handleDomChanged :function(event){
            switch(event._property) {
                case "allowNeutral":
                    this._handleAllowNeutral(event);
                    break;
                default:
                    xfalib.view.FieldView.prototype.handleDomChanged.apply(this, arguments);
            }
        },

         _calculateDisplay : function(capExtent,wExtent) {
               var size = this._getWidgetReserved();  //-- we are changing the calculations from caption-centric to a widget centric
               this.widgetLayoutModel.extentw = this.widgetLayoutModel.extenth = size;
               var parentExtent = {};
               var paraField = this.model.getElement("para")
               if(paraField)
                 var vAlignWidget = paraField.getAttribute("vAlign");
               parentExtent["width"] = this.layoutModel.extentw + this.layoutModel.borderleft/2 + this.layoutModel.borderright/2 ;
               parentExtent["height"] = this.layoutModel.extenth + this.layoutModel.bordertop/2 + this.layoutModel.borderbottom/2 ;
               wExtent["width"] = this.widgetLayoutModel.extentw + this.widgetLayoutModel.borderleft/2 + this.widgetLayoutModel.borderright/2 ;
               wExtent["height"] = this.widgetLayoutModel.extenth + this.widgetLayoutModel.bordertop/2 + this.widgetLayoutModel.borderbottom/2 ;
               var topBottomPadding = (this.layoutModel.extenth-(this.widgetLayoutModel.extenth + this.captionLayoutModel.extenth))/2;

               switch(vAlignWidget) { // setting the vAlign of the widget equal to its parent. (i.e field)
                 case "bottom":
                        wExtent["bottom"]= this._padBottom();
                        break;
                  case "middle":
                        wExtent["top"] = (this.layoutModel.extenth-size)/2;
                        break;
                  case "top":
                  default:
                        wExtent["top"]= this._padTop();
               }

               switch(this.model.caption.placement) {
                    case "right" :
                        capExtent["left"] = this._padLeft() + size;
                        capExtent["top"] = this._padTop();
                        wExtent["left"] = this._padLeft()
                        break;
                    case "left" :
                        capExtent["right"] = this._padRight() + size;
                        capExtent["top"] = this._padTop();
                        wExtent["right"] = this._padRight();
                        break;
                    case "bottom" :
                        capExtent["left"] = this._padLeft();
                        capExtent["top"] = this._padTop()+ size + topBottomPadding;
                        wExtent["left"] = this._padLeft();
                        wExtent["bottom"]= undefined;
                        wExtent["top"] = this._padTop() + topBottomPadding ;
                        break;
                    case "top" :
                        capExtent["left"] = this._padLeft();
                        capExtent["bottom"] =this._padBottom()+ size + topBottomPadding;
                        wExtent["top"]= undefined;
                        wExtent["left"] = this._padLeft();
                        wExtent["bottom"] = this._padBottom()+ topBottomPadding;
                        break;
               }
               var lang = this._langFromLocale(this.model._getLocale());
               var direction = "ltr"
               if(lang && this._rtlLang[lang]){
                 direction = "rtl";
               }
               if(capExtent["width"]<(parentExtent["width"] - wExtent["width"])) {
                   switch(this.model.caption.placement) {
                       case "right" :
                           capExtent["left"] =  parentExtent["width"]-capExtent["width"] ;
                           break;
                       case "left" :
                           capExtent["right"] = undefined;
                           capExtent["left"] = this._padLeft();
                           wExtent["right"] = direction === "rtl" ? 0 : undefined
                           wExtent["left"] = direction === "rtl" ? undefined : this._padLeft()+capExtent["width"];
                           break;
                   }
               }
               if(capExtent["height"]<(parentExtent["height"] - wExtent["height"])) {
                   switch(this.model.caption.placement) {
                       case "bottom" :
                           capExtent["top"] = parentExtent["height"]-capExtent["height"];
                           break;
                       case "top" :
                           capExtent["bottom"] = parentExtent["height"]-capExtent["height"];
                           break;
                   }
               }

         },


        _getWidgetReserved: function() {
            if(this.widget ){
                 var size = this.model.ui.oneOfChild.getAttribute("size");
                 return (size != "-1" ? this._convertToPx(size) : 0);
            }
        },

        _handleAllowNeutral : function(event) {
            if(event.prevText) {
                if(event.prevText == "0" && this.model.getItemState(2)) {  // if button was in neutral,
                    this.model.setItemState(1, true);   // set it to off, while disabling allowNeutral
                }
                this.jqWidget.option("allowNeutral", event.prevText);
            }
        },

        _createPluginOptions : function(){
                var vOptions = xfalib.view.FieldView.prototype._createPluginOptions.apply(this, arguments);
            if(this.model) {
                //TODO: used _getDisplayItems. Internal API
                var vItems = _.map(
                    this.model._getDisplayItems() ? this.model._getDisplayItems().moChildNodes: [],
                    function(item, index){
                        return item.value;
                    }, this);
                vOptions.values = vItems;

                if(this.model.parent && this.model.parent._isExclusionGroup()) {
                    //push atleast one of these
                    vOptions.name = this.model.parent.name+""+this.parentView._id;
                }
            }
            return vOptions;
        }
    });

    Object.defineProperty(xfalib.view.CheckButtonFieldView.prototype, "resizable", {
        get : function(){
            return false;
        },

        set : function(sValue){
            //Do Nothing
        }
    });

})(_, $, xfalib);
(function(_, $, xfalib){
    xfalib.view.TextFieldView = xfalib.view.FieldView.extend({
        _createPluginOptions : function() {
            var vOptions = xfalib.view.FieldView.prototype._createPluginOptions.apply(this,
                    arguments);
            vOptions.multiLine = false;
            if (this.model) {
                var ui = this.model.getElement('ui', 0, true);
                var uiChild;

                if(ui) {
                    uiChild = ui.oneOfChild;
                    if(uiChild) {
                        vOptions.multiLine = uiChild.getAttribute("multiLine") == 0 ? false : true;
                    }
                }

                var value = this.model.getElement("value", 0, true);
                if(value) {
                    var valueChild = value.oneOfChild;
                    if(valueChild) {
                        var maxChars = valueChild.getAttribute("maxChars");
                        //note : maxChars/ numberOfCells as zero should be treated as undefined/no restriction
                        vOptions.maxChars = this.getOrElse(maxChars, undefined);
                    }
                    if(valueChild.className === "exData" && valueChild.jsonModel._value !== null && valueChild.jsonModel._value.indexOf("<body xmlns=") === -1){
                        valueChild._transformToXFACompliantModel();
                        vOptions.value = valueChild.jsonModel._value;
                    }
                }

                if(!vOptions.maxChars){
                    //note : numberOfCells as zero should be treated as undefined/no restriction
                    if(uiChild) {
                        var comb = uiChild.getElement("comb", 0, true);
                        if(comb) {
                            vOptions.maxChars = comb.getAttribute('numberOfCells');
                        }
                    }
                }
                if (!vOptions.fontSize) {
                    var font = this.model.getElement("font", 0, true);
                    if (font) {
                        vOptions.fontSize = this._convertToPx(font.size);
                        vOptions.fontFamily = font.typeface;
                    }
                }
            }
            return vOptions;
        },

        _createDefaultWidgetPlugin : function(options) {
            if(this._richTextSupport()){
                $(this.widget).richTextField(options);
                this.jqWidget = this.$data(this.widget, "xfaWidget-richTextField");
            }else{
                $(this.widget).textField(options);
                this.jqWidget = this.$data(this.widget, "xfaWidget-textField");
            }
        },

        _richTextSupport: function(){
           return(this.getOrElse(this.model, "value.oneOfChild.className", null) === "exData"? true:false);
        },

        createWidgetPlugin : function(options) {
            //cm-usecase: adding class to enable rich text widget registration against the class
            if(this._richTextSupport()) {
                this.$el.addClass('richtextsupport');
        }
            xfalib.view.FieldView.prototype.createWidgetPlugin.call(this,
                options);
        },


        _getMeasurementOptions : function() {
           var measureOptions = xfalib.view.FieldView.prototype._getMeasurementOptions.apply(this, arguments);
           // adding this option to check for fields requiring rich text support.
           measureOptions.contentType = this._richTextSupport() ? "text/html":"text/plain";
           measureOptions.skipXSSProtection = $(this.widget).data('skipXSSProtection');
           return measureOptions;
        },

        _getParaStyles : function(){
            var paraStyles = {},para;
            para = this.model.getElement("para", 0, true);
            if(para){
                paraStyles = xfalib.view.FieldView.prototype._getParaStyles.apply(this, arguments);
                paraStyles['line-height']= parseFloat(para.lineHeight)>0? this._convertToPx(para.lineHeight)+"px":"normal";
            }
            return paraStyles;
        }

    });
})(_, $, xfalib);
(function(_, $, xfalib){
    xfalib.view.DateTimeFieldView = xfalib.view.FieldView.extend({

        _createDefaultWidgetPlugin : function(options) {
            if (this.model /*&& xfa.host.platform !== "iPad"*/) {
                $(this.widget).dateTimeEdit(options);
                this.jqWidget = this.$data(this.widget, "xfaWidget-dateTimeEdit");
            } else {
                xfalib.view.FieldView.prototype._createDefaultWidgetPlugin.apply(this,[options]);
            }
        },

        _createPluginOptions : function(){
            var vOptions = xfalib.view.FieldView.prototype._createPluginOptions.apply(this, arguments);
            if(this.model) {
                var locale = this.model.locale;
                vOptions.days = this.model._xfa()._getLocaleSymbols(locale,"calendarSymbols.abbrdayNames");
                vOptions.months = this.model._xfa()._getLocaleSymbols(locale,"calendarSymbols.monthNames");
                vOptions.zero = this.model._xfa()._getLocaleSymbols(locale,"numberSymbols.zero");
                vOptions.clearText = xfalib.locale.Strings.clearText;
                vOptions.$clickable = this.$el;
                vOptions.useNativeWidget = false;
                var behaviorConfig = new xfalib.ut.Version(formBridge.userConfig["behaviorConfig"]);
                vOptions.showCalendarIcon = !behaviorConfig.isOn('mfDisableCalendarIcon');
                vOptions.calendarIconWidth = _.min([xfalib.template.Constants.calendarIconMaxWidth, Math.floor(vOptions.height)]) - 2;

                var editPattern = this.getOrElse(this.model, "ui.picture.value", null);
                if (editPattern) {
                    var parsedPattern = xfalib.ut.PictureUtils.parsePictureClause(editPattern);
                    if (_.isEmpty(parsedPattern) || _.isArray(parsedPattern) && parsedPattern.length > 1) {
                        editPattern = null; // for now fall back to default patterns in case of unsupported / multiple patterns
                        // TODO : make a array of the parsed objects and iter over them in abstract widget : parseEditValue
                    }
                }

                vOptions.editPattern = editPattern;
            }
            return vOptions;
        },

        handleChangeEvent: function(event) {
            //TODO: pass on the correct data
            var detail = {
                newText:null,
                keycode:null,
                modifier:null,
                keyDown:false,
                shift:false,
                change: null
            };
            this.model.execEvent("change", detail);
        }
    });
})(_, $, xfalib);
(function(_, $, xfalib){
    xfalib.view.ImageFieldView = xfalib.view.FieldView.extend({

        _createDefaultWidgetPlugin : function(options) {
            $(this.widget).imageField(options);
            this.jqWidget = this.$data(this.widget, "xfaWidget-imageField");
        },

        _createPluginOptions : function() {
            var vOptions = xfalib.view.FieldView.prototype._createPluginOptions.apply(
                    this, arguments);
            var imageObj = this.getOrElse(this, "model.value.image", null);
            if (imageObj) {
                vOptions.aspect = imageObj.getAttribute("aspect");
            }
            return vOptions;
        },

        initialize : function() {
            xfalib.view.FieldView.prototype.initialize.apply(this, arguments);
        },

        handleChangeEvent : function(changeEvent) {
           this.model.execEvent("change");
           // NPR-15286 : to trigger event on formbridge whenever the value of scribble changes.
           if (this._getWidgetNameFromUiExtra() == xfalib.template.Constants.ScribbleImageField) {
               xfalib.ut.XfaUtil.prototype._triggerOnBridge(xfalib.template.Constants.scribbleChangeEvent, this.model, "change", this.model.somExpression);
           }
        }
    });
})(_, $, xfalib);
(function(_, $, xfalib){
    xfalib.view.ButtonFieldView = xfalib.view.FieldView.extend({
        handleCommit : function(event){
            // xfa.Logger.debug("[ButtonFieldView.handleCommit]som" +
            // this.$el.data("som"));
            // do Nothing
        },

        handleClickEvent : function(event) {
            if(this.jqWidget.option("access") == "open") {
                xfalib.view.FieldView.prototype._setFocusParam(this);
                xfalib.view.FieldView.prototype.handleClickEvent.apply(this,arguments);
                xfalib.ut.XfaUtil.prototype._triggerOnBridge("elementButtonClicked", this.model, "click", this.model.somExpression);
            }
        },

        _handleKeyDown : function(event) {

        },

        handleDomChanged :function(event){
            switch(event._property) {
               case "caption.value.text":
                     this._handleCaptionValueChange(event.newText);
                     break;
               default:
                     xfalib.view.FieldView.prototype.handleDomChanged.apply(this,
                     arguments);
            }
        },

        _handleCaptionValueChange : function(text) {
             var  child = {};
             var caption = this.model.getElement('caption',0, true);
             var value = caption.getElement('value',0, true);

             if(value) {
                 child = value.oneOfChild;
                 if (["text","exData"].indexOf(child.className) !== -1) {
                    var cssObj = this._getTextStyle(caption);
                    if(cssObj) {
                        this.$css(this.caption, cssObj.fontStyles);
                    }
                    this.$css(this.caption, {'display':'table'}); // using this to utilise the css property vertical-align to account for vAlign
                    text=xfalib.ut.XfaUtil.prototype.encodeScriptableTags(this._convertXFARichToHtml(text));
                    $(this.caption.children[0]).replaceWith(text);
                    if(this.caption.children[0] && cssObj) {
                        this.$css(this.caption.children[0], cssObj.paraStyles);
                    }
                 }
             }
        },

        _getTextStyle : function(caption){
            var cssObj=xfalib.view.BaseView.prototype._getTextStyle.apply(this,[caption]);
            var para = caption.getElement('para',0,true);
            if(cssObj && para && para.vAlign) {
               cssObj.paraStyles['vertical-align']= para.vAlign;
               cssObj.paraStyles['display'] = 'table-cell';
            }
            return cssObj;
        },

        _createPluginOptions : function() {
            var pluginOptions = xfalib.view.FieldView.prototype._createPluginOptions.call(this);
            var paraStyles = null;
            if(this.model.getElement("caption", 0, true) && this.model.caption.getElement("para", 0, true)){
                var para = this.model.caption.para;
                paraStyles = {
                    "text-align" : para.hAlign,
                    "vertical-align" : para.vAlign,
                    "text-indent" : this._convertToPx(para.textIndent),
                    "padding-left" : this._convertToPx(para.marginLeft),
                    "padding-right" : this._convertToPx(para.marginRight),
                    "padding-top" : this._convertToPx(para.spaceAbove),
                    "padding-bottom" : this._convertToPx(para.spaceBelow)
                };
            }
            pluginOptions["paraStyles"] = paraStyles;
            pluginOptions["svgCaption"] = this.caption != null;
            return pluginOptions;
        },

        _createDefaultWidgetPlugin :  function(options){
            if(this.model){
                $(this.widget).xfaButton(options);
                this.jqWidget = this.$data(this.widget, "xfaWidget-xfaButton");
            }
            else{
                xfalib.view.FieldView.prototype._createDefaultWidgetPlugin.apply(this, [options]);
            }
        }

    });
})(_, $, xfalib);(function(_, $, xfalib){
    xfalib.view.NumericFieldView = xfalib.view.FieldView.extend({
        _matchArray : { "integer":"^[+-]?\\d*$", "decimal":"^[+-]?\\dld(\\.\\dfd)?$", "float":"^[+-]?\\d*(\\.\\d*)?$" },
        _createPluginOptions : function() {
            var vOptions = xfalib.view.FieldView.prototype._createPluginOptions.apply(
                    this, arguments);
            if (this.model) {
                vOptions.dataType = this.model.value.oneOfChild.className ;
                vOptions.leadDigits = this.model.value.oneOfChild.leadDigits;
                vOptions.fracDigits = this.model.value.oneOfChild.fracDigits;
                vOptions.zero = this.model._xfa()._getLocaleSymbols(this.model.locale,"numberSymbols.zero");
                vOptions.decimal = this.model._xfa()._getLocaleSymbols(this.model.locale,"numberSymbols.decimal");
                //note : numberOfCells as zero should be treated as undefined/no restriction
                var uiChild = this.model.ui.oneOfChild;
                if(uiChild != null && uiChild.getElement("comb", 0, true) != null)
                    vOptions.combCells = this.model.ui.oneOfChild.comb.numberOfCells || undefined;
            }
            return vOptions;
        },

        _createDefaultWidgetPlugin : function(options) {
            if (this.model) {
                $(this.widget).numericInput(options);
                this.jqWidget = this.$data(this.widget, "xfaWidget-numericInput");
            } else {
                xfalib.view.FieldView.prototype._createDefaultWidgetPlugin.apply(this,
                        [options]);
            }
        },

        handleCommit : function(event) {
            var _regex = null;
            var temp = this.jqWidget.option("value") + "";

            var ld = this.model.value.oneOfChild.leadDigits;
            var fd = this.model.value.oneOfChild.fracDigits;

            var matchStr = this._matchArray[this.model.value.oneOfChild.className];

            ld = (ld !== undefined && ~ld) ? "{0,"+ld+"}" : "*";
            fd = (fd !== undefined && ~fd) ? "{0,"+fd+"}" : "*";
            matchStr = matchStr.replace("ld", ld);
            matchStr = matchStr.replace("fd", fd);
            _regex = new RegExp(matchStr, "g");

            if (temp.match(_regex)) // if we need to keep this new	entered value
                xfalib.view.FieldView.prototype.handleCommit.apply(this, arguments);
            else
                 this.jqWidget.option("value",this.model[this.commitTarget]);
        }
    });
})(_, $, xfalib);
(function(_, $, xfalib){
    xfalib.view.ChoiceListFieldView = xfalib.view.FieldView.extend({

        initialize: function () {
            xfalib.view.FieldView.prototype.initialize.apply(this, arguments);
            this._prevSelection = null;
        },

        _valueToArray: function(value) {
            var valueArray;
            if(value != null)
                valueArray = value.split("\n");
            else
                valueArray = [null];
            return valueArray;
        },

        _handleValueChange : function(event){
            //xfa.Logger.debug("[ChoiceListFieldView._handleValueChange]value:som" + event.newText + ":" + this.$el.data("som"));
            var prevText = this.jqWidget.option("displayValue");
            if (_.isArray(prevText)) {
                prevText = prevText.join("\n");
            }
            this._prevSelection = prevText;

            this.jqWidget.option("value",this._valueToArray(event.prevText));
            this.jqWidget.option("displayValue",this._valueToArray(event.newText));
        },

        handleCommit : function(event){
            //xfa.Logger.debug("[ChoiceListFieldView.handleCommit]som" + this.$el.data("som"));
            var val = this.jqWidget.option("value");
            if(_.isArray(val)){
                val = val.join("\n");
            }
            this.model[this.commitTarget] = val;
        },

        _createDefaultWidgetPlugin :  function(options){
            if(this.model)
            {
                if(this.model.ui.oneOfChild.open == 'always' || this.model.ui.oneOfChild.open == 'multiSelect'){
					//do role setting --
                    $(this).attr("role", "listbox"); //find a better place to do this
                    if($.browser.msie || $.browser.mozilla){
                        $(this.widget).nwkListBox(options);
                        this.jqWidget = this.$data(this.widget, "xfaWidget-nwkListBox");
                    }
                    else {
                        $(this.widget).listBox(options);
                        this.jqWidget = this.$data(this.widget, "xfaWidget-listBox");
                    }
                }
                else{
                    $(this.widget).dropDownList(options);
                    this.jqWidget = this.$data(this.widget, "xfaWidget-dropDownList");
                }
            }
            else{
                xfalib.view.FieldView.prototype._createDefaultWidgetPlugin.apply(this, [options]);
            }
        },

        _createPluginOptions : function(){
            var vOptions =  xfalib.view.FieldView.prototype._createPluginOptions.apply(this, arguments);
            if(vOptions.value!=null && !_.isArray(vOptions.value))
            {
                if(_.isString(vOptions.value))
                    vOptions.value = vOptions.value.split("\n");
                else
                    vOptions.value = [vOptions.value]; //convert new value to array
            }
            if(this.model)
            {
                var that = this;
                vOptions.editable =  (this.model.ui.oneOfChild.textEntry == '1');
                vOptions.multiSelect =  (this.model.ui.oneOfChild.open == 'multiSelect');
                var vItems = _.map(this.model._getDisplayItems() ? this.model._getDisplayItems().moChildNodes : [],
                    function(item, index){
                        var saveItem =  that.model.getSaveItem(index);
                        var displayItem = that.model.getDisplayItem(index);
                        return {
                            "save" : saveItem,
                            "display" : displayItem
                        };
                    }
                );
                vOptions.items = vItems;
            }
            return vOptions;
        },
        
        handleModelChanged : function(event) {
            if (event._property == "addItem") {
                this._handleAddItem(event);
            }
            if (event._property == "clearItems") {
                    this._handleClearItems(event);
            }
            if (event._property == "deleteItem") {
                this._handleDeleteItem(event);
        }
            else
                xfalib.view.FieldView.prototype.handleModelChanged.apply(this,
                        arguments);
        },

        handleChangeEvent : function(event) {
            var newValue =  this.jqWidget.option("displayValue");
            if(_.isArray(newValue)) {
                newValue = newValue.join("\n"); // return a string
            }
            var detail = {
                newText:newValue,
                prevText: this._prevSelection,
                keycode:event.which,
                modifier:event.ctrlKey,
                keyDown:event.which===40,
                shift:event.shiftKey,
                change: newValue
            };
            this.model.execEvent("change", detail);
        },
        
        _handleAddItem : function(event) {
        	var itemValues = {
        			sDisplayVal:event.newText,
        			sSaveVal:event.prevText
                };
        	this.jqWidget.addItem(itemValues);
            },
        
        _handleClearItems : function(event) {
        	this.jqWidget.clearItems();
            },
                   
        _handleDeleteItem : function(event) {
        	this.jqWidget.deleteItem(event.newText);
        }

    });
})(_, $, xfalib);
(function(_, $, xfalib){

    xfalib.view.ContainerView = xfalib.view.BaseView.extend({
        initialize : function() {
            xfalib.view.BaseView.prototype.initialize.apply(this, arguments);
            this.layoutTemplate = {};
            this.childViews = [];
            this.layout = null;
            this._initLayout();
        },

        _initLayout : function(){
            xfalib.view.BaseView.prototype._initLayout.apply(this, arguments);
            if(this._initialized){
                this._processLayoutTemplate();
                this.layout = this._layoutManager.createLayout(this);
                if (this.model) {
                    this.model.on(xfalib.script.XfaModelEvent.CHILD_ADDED,this);
                    this.model.on(xfalib.script.XfaModelEvent.CHILD_REMOVED,this);
                    this.model.on(xfalib.script.XfaModelEvent.CHILD_MOVED,this);
                }
                this._syncFormNodeToHtml(true);
            }
        },

        _processLayoutTemplate : function(){
            var xfaTemplateCache = this._formDomRoot()._xfaTemplateCache;
            var htmlTemplateCache = this._xfaViewRegistry().templateCache();
            var that = this;
            var initialFormNode = xfaTemplateCache.getInitialFormDomRef(this._id);
            if(!initialFormNode){
                this.layoutTemplate.hasTemplate = false;
                return;
            } else
                this.layoutTemplate.hasTemplate = true;

            this.$elchildren().each(function() {
                var iChildNode = xfaTemplateCache.getInitialFormDomRef(this.id);
                if(!iChildNode)
                    return;

                var partBegin = true,
                    partSplit = false,
                    partEnd = true;
                var occurrences = that.getOrElse(that.$data(this, xfalib.view.LayoutConst.XFA_MODEL), xfalib.view.LayoutConst.LAYOUT_MODEL+"."+xfalib.view.LayoutConst.OCCURRENCES, 1); //occurrences
                var currentOccurence = that.getOrElse(that.$data(this, xfalib.view.LayoutConst.XFA_MODEL), xfalib.view.LayoutConst.LAYOUT_MODEL+"."+xfalib.view.LayoutConst.OCCUR_INDEX, 0); //occurIndex
                if(currentOccurence != 0){
                    //The part has been split and currentOccurance is not zero. That means this element does not start in the parent layout.
                    partBegin = false; // not really used anywhere
                }
                if((occurrences - currentOccurence) > 1){
                    //This means that this element layout has been split into multiple parts and this part is not last part.
                    partSplit = true;
                    partEnd = false;
                }
                var childTemplateId = xfaTemplateCache.getTemplateRef(iChildNode.extras.htmlId).extras.htmlId;
                that.$data(this, "templateId", childTemplateId); // Set the templateId as actual id may change.
                if(xfalib.ut.XfaUtil.prototype.isTableHF(iChildNode)){
                    //A super hack for #3468407 till we support leader/trailer. For Table Header/Footer we may not have IM before it. So handle exclusively till we fix it
                    that.layoutTemplate[iChildNode.extras.htmlId] = {hasFirstPartBegin : partBegin, hasLastPartOverflow : partSplit};
                }
                else if(iChildNode && that.getOrElse(that.$data(this, xfalib.view.LayoutConst.XFA_MODEL), xfalib.view.LayoutConst.NODE_TYPE ,"").toLowerCase() == "subform"){
                    var instanceIndex = -1;
                    var sfIM = null;
                    var found = _.find(initialFormNode.children, function(initChild){
                        if(that.matchJsonType(initChild, "instanceManager")){
                            sfIM = initChild;
                            instanceIndex = -1;
                            return false;
                        }
                        else {
                            instanceIndex = instanceIndex + 1;
                            if(initChild == iChildNode)
                                return true;
                            else
                                return false;
                        }
                    });
                    if(found){
                        // if repeatable put in cache, along with current occurIndex for later stitching
                        if(iChildNode.extras.htmlId == childTemplateId && sfIM && (parseInt(that.getOrElse(sfIM.max, xfalib.script.Occur.prototype._defaults.max)) < 0 ||
                            parseInt(that.getOrElse(sfIM.min, xfalib.script.Occur.prototype._defaults.min )) < parseInt(that.getOrElse(sfIM.max, xfalib.script.Occur.prototype._defaults.max )))){
                            htmlTemplateCache.put(this.cloneNode(true));
                        }
                        var isLastChild = true;
                        var childIndex = initialFormNode.children.indexOf(iChildNode);
                        if(initialFormNode.children.length > childIndex +1 &&
                            that.matchJsonType(initialFormNode.children[childIndex + 1], "subform")){
                            isLastChild = false;
                        }
                        instanceIndex = instanceIndex + currentOccurence/1000;  // hack, assume at most 1000 instances of a rpt. SF.
                                                                               // the decimal part is used to judge the overflowed part which has split over multiple pages
                        that.layoutTemplate[childTemplateId] = !_.isEmpty(that.layoutTemplate[childTemplateId]) ? that.layoutTemplate[childTemplateId] : {
                            id: childTemplateId,
                            start : instanceIndex,
                            end : instanceIndex,
                            hasFirstPartBegin : partBegin,
                            hasLastPartOverflow : partSplit
                        };
                        that.layoutTemplate[childTemplateId].end = isLastChild && partEnd ? -1 : instanceIndex;
                        that.layoutTemplate[childTemplateId].hasLastPartOverflow = partSplit;
                    }
                } else {
                    that.layoutTemplate[childTemplateId] = {hasFirstPartBegin : partBegin, hasLastPartOverflow : partSplit};
                }
            }) ;
        },

        _syncFormNodeToHtml: function(deepSync){
            var that = this;
            var htmlTemplateCache = this._xfaViewRegistry().templateCache();
            var oldIdToChildViews = {};
            var newIdToChildViews = {};
            var cellIndex = 0;
            var lastSibling = null;

            //cache the old child views against their IDs
            _.each(this.childViews, function(childView){
                oldIdToChildViews[childView.el.id] = childView;
            }, this);

            _.each(this.getOrElse(this, "model.children", []),
                function(childModel){
                    if(!this._validateLayoutTemplate(childModel))
                        return;
                    var cTemplateId = childModel._templateId();
                    var id = childModel.htmlId;
                    var childEl = this.$elchildren(that.jqId(id))[0];
                    if(!childEl && (!newIdToChildViews.hasOwnProperty(cTemplateId) && !oldIdToChildViews.hasOwnProperty(cTemplateId))){
                        childEl = this.$elchildren(that.jqId(cTemplateId))[0];
                    }
                    if(!childEl){
                        if(!this._isHidden(childModel)){
                            var htmlTmplt = htmlTemplateCache.get(cTemplateId, true);
                            if(!htmlTmplt){
                                xfalib.runtime.xfa.Logger.error("xfaView", "Html template could not be found. cTemplateId:"+cTemplateId+", som:"+childModel.somExpression);
                                return;
                            }
                            else{
                                childEl = htmlTmplt;
                            }
                        }
                        else {
                            var xfaHiddenPH = $("<div></div>");
                            if(childModel instanceof xfalib.script.Draw){
                                xfaHiddenPH.addClass("draw");
                            }
                            else if(childModel instanceof xfalib.script.Field){
                                xfaHiddenPH.addClass("field");
                            }
                            childEl = xfaHiddenPH.get(0);
                            //TODO: below way of finding nodetype is not always true and may break hidden objects. We will need robust way to get node type that can be used by XfaViewRegistry.nodeTyperegistry.
                            //But for current implementation it would work as we care only about container node types.
                            var elNodeType = childModel.className.toLowerCase();
                            this.$data(childEl, "xfaHiddenPH", true);
                            var xfaModelObj = {};
                            xfaModelObj[xfalib.view.LayoutConst.NODE_TYPE] = elNodeType;
                            this.$data(childEl, xfalib.view.LayoutConst.XFA_MODEL, xfaModelObj);
                        }
                    }
                    childEl.id = childModel.htmlId;

                    this.$data(childEl,"templateId", cTemplateId); //Required for nested template ELs
                    var view = null;
                    if(oldIdToChildViews.hasOwnProperty(childEl.id)) {
                        view = oldIdToChildViews[childEl.id];
                        if(lastSibling && lastSibling.model instanceof xfalib.script.Subform && lastSibling.model.instanceManager._isRepeatable())
                            lastSibling.$el.after(view.$el); //The repeatable subform might have moved using moveInstance. So position it after it's sibling.
                        if(deepSync)
                            view.syncFormNodeToHtml(deepSync); //Sync existing views only if deepSync is requested
                    } else {
                        view = this._createChild(childEl, cellIndex, lastSibling);
                    }
                    cellIndex = cellIndex + (view.layoutModel.colspan || 1); //Add the colspan or one
                    newIdToChildViews[childModel.htmlId] = view;
                    lastSibling = view;
                }, this
            );

            this.childViews = [];
            if (!this.$el.is(":empty")) {
                this.$elchildren().each(function() {
                    if(newIdToChildViews.hasOwnProperty(this.id))
                        that.childViews.push(newIdToChildViews[this.id]);
                    else {
                         xfalib.runtime.xfa.Logger.log("xfaView",5,"removing element as no corresponding form dom node found. id:" + this.id + ", parent id:"+ that._id);
                        $(this).remove();
                    }
                }) ;
            }
            xfalib.view.BaseView.prototype._syncFormNodeToHtml.apply(this, arguments);   //sync other props before layout
        },

        _createChild : function(childEl, cellIndex, previousSibling){
            var view = this._xfaViewRegistry().createView(childEl, {
                    parentView: this,
                    tableCellIndex : cellIndex,
                    pageNumber: this._pageNumber()
                });
//            if(this.resizable || view._isPlaceHolderEl()){
//                //We also need to call layoutContainer for the cases where the object is initially hidden even if parent is not resizable
//                // since we do not have el for hidden object as yet,. TODO: optimize it.
//                view.on(xfalib.view.XfaViewEvent.EXTENT_CHANGE +" "+ window.xfalib.view.XfaViewEvent.PRESENCE_CHANGE,
//                    this._layoutContainer, this);
//            }
            if(this.$el.find(view.$el).length < 1){
                if(previousSibling)
                    previousSibling.$el.after(view.$el);        //Push the element after the sibling
                else
                    this.$el.prepend(view.$el);      //push the element at the begining of parent if no sibling is found,\.
            }
            return view;
        },

        _validateLayoutTemplate : function(childModel){
            var cTemplateId = childModel._templateId();
            if(xfalib.ut.XfaUtil.prototype.isTableHF(childModel)){
                //A super hack for #3468407 till we support leader/trailer. For table Header/Footer, templateId would be this same htmlId.
                cTemplateId = childModel.htmlId;
            }
            if(!this._isPaintable(childModel))
                return false;
            if(this.layoutTemplate.hasTemplate){
                var xfaTemplateCache = this._formDomRoot()._xfaTemplateCache;
                var iChildJson = xfaTemplateCache.getInitialFormDomRef(childModel.htmlId); //find the t0 version of this child
                if(!this.layoutTemplate.hasOwnProperty(cTemplateId) && !this._isHidden(iChildJson))
                    return false; // Here because the page has been split and this childModel is rendered in different page
                else if(!this.layoutTemplate.hasOwnProperty(cTemplateId) && this._isHidden(iChildJson)){
                    //if this child may not present in layout template if it was hidden at t0 becase for hidden containers layout is not generated.
                    //So we need to put extra effort to check if this hidden object fits layout template of this view.
                    var valid = this._validateHiddenChildLayout(childModel);
                    if(valid){
                        //if found validated, cache it for future. Also hidden part are automatically stitched into one part, so hasLastPartOverflow would false
                        this.layoutTemplate[cTemplateId] = {hasFirstPartBegin: true, hasLastPartOverflow : false};
                    }
                    return valid;
                }
                else if(childModel instanceof xfalib.script.Subform &&
                    (childModel.instanceIndex < Math.floor(this.layoutTemplate[cTemplateId].start) ||
                    (childModel.instanceIndex > this.layoutTemplate[cTemplateId].end && this.layoutTemplate[cTemplateId].end > -1))){
                    return false;   //This subform is not in the range of Instances handled by this page. Lying either in earlier or next pages.
                }
            }
            return true;
        },

        _validateHiddenChildLayout : function(childModel){
            if(!childModel.parent)
                return false;       //can happen only for rootsubformview as child model
            var siblings = childModel.parent.children;
            if(siblings && siblings.indexOf(childModel) > 0){
                var childIndex = siblings.indexOf(childModel);
                var lastPaintableSibling = null;
                for(var lastIndex = childIndex-1; lastIndex >=0; lastIndex--){
                    var lastSibling = siblings[lastIndex];
                    if(lastSibling instanceof xfalib.script.InstanceManager){
                        var instanceTemplate = lastSibling._instanceTemplate();
                        var templateId = this.getOrElse(instanceTemplate, "extras.htmlId", null);
                        if(this.layoutTemplate[templateId] != null){
                            if(this.layoutTemplate[templateId].end == -1 && !this.layoutTemplate[templateId].hasLastPartOverflow){
                                //Last layout part of last instance of this IM was here at t0.
                                //So hidden object should come on this page. Else on another page.
                                return true;
                            }
                            else
                                return false;
                        }
                        else
                            continue;   //IM of this hidden sf?.
                    }
                    else if(!this._isPaintable(lastSibling)){
                        continue;
                    }
                    else{
                        lastPaintableSibling = lastSibling;
                        break;
                    }
                }
                if(!lastPaintableSibling){
                    //This hidden child model is first paintable child of this. If this layout element is first part of this model layout
                    // Then hidden child should be painted in this page/view. Else in other view.
                    if(this.getOrElse(this.layoutModel, "occurIndex", 0) == 0)
                        return true;
                    else
                        return false;
                }
                else {
                    //Else if *last part of last paintable sibling* of this hidden node belong to this layout template then this hidden node would also belong here.
                    var lastSiblingValid = this._validateLayoutTemplate(lastPaintableSibling);
                    if(lastSiblingValid){
                        var lastSiblingTemplateId = lastPaintableSibling._templateId();
                        if(!this.layoutTemplate[lastSiblingTemplateId].hasLastPartOverflow)
                            return true;
                        else
                            return false;
                    }
                    else{
                        return false;
                    }
                }
            }
        },

        handleEvent: function(evnt) {
            switch(evnt.name) {
                case xfalib.script.XfaModelEvent.CHILD_ADDED:
                    this.handleChildAdded(evnt);
                    break;
                case xfalib.script.XfaModelEvent.CHILD_REMOVED:
                    this.handleChildRemoved(evnt);
                    break;
                case xfalib.script.XfaModelEvent.CHILD_MOVED:
                    this.handleChildMoved(evnt);
                    break;
                default:
                    xfalib.view.BaseView.prototype.handleEvent.apply(this, arguments);
            }
        },

        handleDomChanged :function(event){
            switch(event._property) {
                default:
                    xfalib.view.BaseView.prototype.handleDomChanged.apply(this,
                        arguments);
            }
        },

        handleModelChanged : function(event) {
            if (event._property == "fillColor") {
                this._fillColor(event.newText);
            }
            else if (event._property == "borderColor") {
                this._borderColor(event.newText);
            }
            /*else if (event._property == "borderWidth") {
                this._borderWidth(event.newText);
            }     */
            else
                xfalib.view.BaseView.prototype.handleModelChanged.apply(this,
                    arguments);
        },

        /*_borderWidth : function(width) {
            $(this.el).css("borderWidth", width)
        },          */

        handleChildAdded : function(event) {
            var addedChild  = event.newText;
            var childTemplateId = addedChild._templateId();
            if(!this.layoutTemplate.hasTemplate || (this.layoutTemplate.hasOwnProperty(childTemplateId) && addedChild.instanceIndex >=  this.layoutTemplate[childTemplateId].start &&
                (this.layoutTemplate[childTemplateId].end < 0 || addedChild.instanceIndex <= this.layoutTemplate[childTemplateId].end))){
                //If added child resides in the range supported by this view, sync it.
                this._syncFormNodeToHtml(false);
            }
            else
                xfalib.runtime.xfa.Logger.debug( "xfaView","This instanceManager has no child in this layout template. This would be handled in other part of splitted subform. el id:"+this._id);
        },

        handleChildMoved : function(event) {
            this._syncFormNodeToHtml(true);
        },

        handleChildRemoved : function(event) {
            var removedChild = event.prevText;
            /*
             * Note/Hack: To get the templateId of removedChild, we can not simply ask child._templateId() as this would return template Id of only those
              * nodes which are still connected to xfa dom. Since remove child is disconnected from xfa, we are asking template Id of this from it's instanceManage
              * which is still there. A workaround for now.
             */
            var childTemplateId = removedChild.instanceManager._instanceTemplate().extras.htmlId;
            if(!this.layoutTemplate.hasTemplate || (this.layoutTemplate.hasOwnProperty(childTemplateId) &&
                (this.layoutTemplate[childTemplateId].end < 0 || removedChild.instanceIndex <= this.layoutTemplate[childTemplateId].end))){
                //If the removed child has instanceIndex less than the end range then there is potential for relayout of this page. So syn it.
                this._syncFormNodeToHtml(false);
            }
            else
                xfalib.runtime.xfa.Logger.debug( "xfaView","This instanceManager has no child in this layout template. This would be handled in other part of splitted subform. el id:"+this._id);
        },

        destroy : function() {
          //TODO: Implement and call destroy method
        },

        _isAnonymous : function() {
            return false;
        },

        _normalizedChildViews : function() {
            var normalizedChildViews = [];
            _.foldl(this.childViews, function(memo, childView, index){
                if(childView instanceof xfalib.view.ContainerView && childView._isAnonymous()){
                    _.each(childView._normalizedChildViews(), function(normalizedChild){
                        memo.push(normalizedChild);
                    });
                }
                else if(!this._isHidden(childView.model)){
                    memo.push(childView);
                }
                return memo;
            }, normalizedChildViews, this);
            return normalizedChildViews;
        },

        _isHidden : function(model){
            //model can be a Node object or simply a json
            if(model && (model.presence == "hidden" || model.presence == "inactive"))
                return true;
            else
                return false;
        },

        _isPaintable : function(model){
            //can this model have visual representation
            if(model && model.isContainer && model.className != "variables")
                return true;
            else
                return false;
        },

        measureSize : function(){
            if(this.layout)
                return this.layout.measureSize();
            else
                return false;
        },

        invalidateSize : function(){
            if(this.layout)
                return this.layout.invalidateSize();
        },

        updateDisplay : function(){
            if(this.layout)
                return this.layout.updateDisplay();
        },

        $elchildren : function(id) {
            return this.$el.children(id);
        }


    });
})(_, $, xfalib);
(function(_, $, xfalib){
    //Intermediate hierarchy to extract out common code for PageView/ContentAreaView/RootSubformView
    xfalib.view.LayoutContainerView = xfalib.view.ContainerView.extend({
        initialize : function(){
            this.growableView = []; // Element that can grow beyond boundary. Current assumption is that there can be only one such element in ContentArea/PageArea
            xfalib.view.ContainerView.prototype.initialize.apply(this, arguments);
        },

        _syncFormNodeToHtml: function(deepSync){
            if(this.childViews == null || this.childViews.length == 0){
                this.childViews = [];
                var that = this;
                var cellIndex = 0;
                if (!this.$el.is(":empty")) {
                    this.childViews = this.$el.children().map(function() {
                        var childView = that._xfaViewRegistry().createView(this, {
                            parentView: that,
                            tableCellIndex : cellIndex,
                            pageNumber: that._pageNumber()
                        });
                        cellIndex = cellIndex + (childView.layoutModel.colspan || 1); //Add the colspan or one
                        if(that._isGrowableView(childView)) {
                            that.growableView.push(childView);
                        }
                        return childView;
                    }).get();
                }
            } else {
                _.each(this.childViews, function(childView){
                    childView.syncFormNodeToHtml(deepSync);
                }, this);
            }
            xfalib.view.BaseView.prototype._syncFormNodeToHtml.apply(this, arguments);   //sync other props before layput
        },

        _isGrowableView :function(childView){
            return false;
        },

        _forceView: function() {
            //this function is to dictate whether the view is forced
            //will be used to force the render of first page at least.
            return false;
        }

    });
})(_, $, xfalib);

(function(_, $, xfalib){
    var SubformView = xfalib.view.SubformView = xfalib.view.ContainerView.extend({

        _assignToolTip: function () {
            var toolTipText = xfalib.ut.XfaUtil.prototype._getToolTipText(this.model);
            // CQ-4222981 : assign tooltip for subform having role as table or it is table
            if (toolTipText && xfalib.ut.XfaUtil.prototype._tableCheckForAccessibility(this)) {
                this.$el.attr("title", toolTipText);
            }
        }

    });

    Object.defineProperty(SubformView.prototype, "resizable", {
        get : function(){
            if(this._resizable)
                return true;
            var layout = this.layoutModel.layout;
            if(layout == xfalib.view.LayoutConst.LAYOUT_LEFTRIGHTTOPBOTTOM || layout == xfalib.view.LayoutConst.LAYOUT_RIGHTLEFTTOPBOTTOM || layout == xfalib.view.LayoutConst.LAYOUT_TOPBOTTOM)
                return true;
            else
                return false;
        },

        set : function(sValue){
            this._resizable = sValue;
        }
    });

})(_, $, xfalib);(function(_, $, xfalib){
    var SubformSetView = xfalib.view.SubformSetView = xfalib.view.ContainerView.extend({
        initialize : function() {
            xfalib.view.ContainerView.prototype.initialize.apply(this, arguments);
        },

        _isAnonymous : function() {
            return true;
        },

        $computeWH : function(){
            var extent = {};
            return extent;
        },

        _computeExtent : function() {
            //mark the position of the subformset as transparent
            var extent = xfalib.view.ContainerView.prototype._computeExtent.apply(this, arguments);
            extent['position'] = 'static';
            return extent
        }
    });
})(_, $, xfalib);(function(_, $, xfalib){
    xfalib.view.ContentAreaView = xfalib.view.LayoutContainerView.extend({
        _isGrowableView :function(childView){
            return (childView.model === this._formDomRoot().form.children[0]); // Is root subform of the form dom
        },

        _initializeLayoutModel : function(){
            xfalib.view.LayoutContainerView.prototype._initializeLayoutModel.apply(this, arguments);
            //Special handling for enabling shrink page functionality. We'll treat contentArea as TopBotton flowable subform.Bug#3608773
            this.layoutModel.extentactualh = -1;
            this.resizable = true;
        }

    });
})(_, $, xfalib);
(function(_, $, xfalib){
    xfalib.view.PageView = xfalib.view.LayoutContainerView.extend({

        initialize : function() {
            xfalib.view.LayoutContainerView.prototype.initialize.apply(this, arguments);
            /* Flag indicating that the tabbing computation for this Page would be redone */
            this._tabComputePending = false;
        },

        _initLayout : function(){
            xfalib.view.LayoutContainerView.prototype._initLayout.apply(this, arguments);
            if(this._initialized){
                /* When a Page View is initialized, immediately mark it for tab compute*/
                this.invalidateTabIndex();
            }
        },

        _forceView: function() {
            //this function is to dictate whether the view is forced
            //will be used to force the render of first page at least.
            return this._pageNumber() == 1;
        },

        _isGrowableView :function(childView){
            return (childView instanceof xfalib.view.ContentAreaView);
        },

        _pageNumber : function(){
            /* Return the page number that was sent from server. Page Number starts with 1.*/
            if(this.layoutModel){
                return this.layoutModel.pageNumber;
            }
            return -1;
        },

        _computeExtent : function(){
            var extent = xfalib.view.LayoutContainerView.prototype._computeExtent.apply(this, arguments);
            extent["position"] = "relative";
            extent["margin-left"] = "auto";               //We need to mark page margins to auto to adjust pages with different master page layout
            extent["margin-right"] = "auto";
            extent["margin-bottom"] = 10;
            extent["margin-top"] = this._pageNumber() == 1 ? 0 : 10 ;
            return extent;
        },

        /*
         * Marks/Queues the Page for re-compute of tab indexes. Re-computation would automatically be fired
         * asynchronously.
         */
        invalidateTabIndex : function(forceCompute) {
            if(!this._tabComputePending || forceCompute){
                /*
                 * Tab compute invalidation sets the tabComputePending flag to true and then fires actual computation async
                 * way in-order for cases where simultaneous in-validations may occur multiple times for different
                 * fields or repeatable subform of the same page. In those cases, we want to compute tab indexes only once when
                 * everything is done.
                 * Another thing, if there is any layout computation pending in layout manager, we defer the tab computation till
                 * that is complete since x,y can change in those cases.
                 **/
                this._tabComputePending = true;
                var that = this;
                xfalib.ut.XfaUtil.prototype.clearTimeoutOnDestroy(
                    window.setTimeout(function(){
                        if(!that._layoutManager.isLayoutCycleComplete()){
                            //layout cycle running so do a force invalidation to defer tab computation to next cycle
                            that.invalidateTabIndex(true);
                        }
                        else{
                            that._computeTabIndex();
                        }
                    }, 1)
                );
            }
        },

        _computeTabIndex : function () {
            this._tabComputePending = false;
            xfalib.view.util.traversalManager._computTabIndex(this);
        }

    });
})(_, $, xfalib);
(function (_, $, xfalib) {
    xfalib.view.RootSubformView = xfalib.view.LayoutContainerView.extend({
        initialize: function () {
            var pagingConfig = this._xfaViewRegistry().pagingConfig();
            this.$el = (this.options.el instanceof $) ? this.options.el : $(this.options.el);
            //make paging default
            if (pagingConfig.pagingDisabled) {
                _.each(this.options.restOfThePages, function (pageEl) {
                    // removed creation of extra page view as childView, on containerView initialize we anyways initialize childView as empty array
                    // on syncFormNodeToHtml we are using $el.children() to create new child views
                    // so just appending rest of the pages element should be enough
                    this.$el.append(pageEl);
                }, this);

            }
            else if (this.options && this.options.restOfThePages) {
                //do nothing, just mark rest of the pages as deferred pages
                this._deferredPages = this.options.restOfThePages;
            }

            this.totPages = this.getOrElse(this, "options.restOfThePages.length", 0) + 1;  // todo: fix this when initial count is present
//            console.profile("P1");
            xfalib.view.LayoutContainerView.prototype.initialize.apply(this, arguments);
//            console.profileEnd();

            //Bug#3670373: a custom event is triggered after the first page is loaded.
            var _triggerXfaFirstPgLayoutComplete = function () {
                this.childViews[0].off('layoutComplete', _triggerXfaFirstPgLayoutComplete);
                $(window).trigger('xfaFirstPgLayoutComplete');
                this._xfaViewRegistry().scaleForm();
            };
            this.childViews[0].on('layoutComplete', _triggerXfaFirstPgLayoutComplete, this);

            //accessibility
            //add form role to rootSubformView
            this.$el.attr("role", "form");

            //also add lang attribute in it
            //leap of faith -- getting the rootsubform of the form model and then set the lang attribute
            if (xfalib.runtime.form.children[0] && xfalib.runtime.form.children[0].jsonModel && xfalib.runtime.form.children[0].locale) {
                //add lang parameter
                var lang = this._langFromLocale(xfalib.runtime.form.children[0].locale);

                if (lang && lang.length > 0) {
                    this.$el.attr("lang", lang);
                }
            }

        },

        _computeExtent: function () {
            return {};
        },

        renderDeferredPage: function () {
            //assert(userConfig && userConfig.pagingConfig && userConfig.pagingConfig.pagingEnabled);
            if (this.hasMoreDeferredPages()) {                              //just make sure we have more than 10 bytes
                //create dom here
                var nextPageEl = $(this._deferredPages.shift());
                var nextPageView = this._xfaViewRegistry().createView(nextPageEl, {parentView: this});
                this.$el.append(nextPageEl);
                this.childViews = this.childViews || [];
                this.childViews.push(nextPageView);
                xfalib.ut.XfaUtil.prototype._triggerOnBridge("elementPageRendered", xfalib.runtime.xfa.form.form1, "nextPage", this.childViews.length-1, this.childViews.length);
                //this.childViews.length-1 is the page number till which form is already rendered
                //this.childViews.length indicates the page number of current page rendered
                //if(window.highlight)
                //    highlightFields();
                return nextPageView;
            }
            return null;
        },

        hasMoreDeferredPages: function () {
            return (this.getOrElse(this._deferredPages, []).length > 0);
        }
    });
})(_, $, xfalib);
(function(_, $, xfalib){
    xfalib.view.ExclGroupView = xfalib.view.ContainerView.extend({
        initialize : function(){
            xfalib.view.ContainerView.prototype.initialize.apply(this, arguments);
            $(this.$el).on(xfalib.ut.XfaUtil.prototype.XFA_CLICK_EVENT,
                                         $.proxy(this.handleClickEvent,this));
        },

        handleClickEvent : function() {
            //this.model.execEvent("click");
        },

        _getScreenReaderText : xfalib.view.FieldView.prototype._getScreenReaderText,

        _assignToolTip : xfalib.view.FieldView.prototype._assignToolTip,

        _initLayout : function(){
            xfalib.view.ContainerView.prototype._initLayout.apply(this, arguments);
            if(this._initialized){
                this.markMandatory();
                this.$el.attr("role", "radiogroup"); //add role
            }
        },

        markMandatory : function(){
            if(this.model.mandatory== "error")
                if(this.$el)
                    this.$el.attr("data-mandatory", "true") ;
        },

        handleModelChanged : function(event) {
            switch (event._property) {
                case "focus":
                    var childView = this._getChildToFocus();
                    this._focusWidget(childView);
                    break;
                case "ValidationState":
                    this._markError(event);
                    break;
                case "ClearError":
                    this._clearError(event);
                    break;
                default:
                    xfalib.view.ContainerView.prototype.handleModelChanged.apply(this, arguments);
            }
        },

        handleDomChanged: function (event) {
            switch (event._property) {
                case "nullTest":
                    xfalib.view.FieldView.prototype._handleNullTest.call(this, event, this.$el.closest('.exclgroup'));
                    break;
                default:
                    xfalib.view.ContainerView.prototype.handleDomChanged.apply(this, arguments);
            }
        },

        _handleMandatory: xfalib.view.FieldView.prototype._handleMandatory,
        _handleDisabled: xfalib.view.FieldView.prototype._handleDisabled,

        _markError : function(evnt) {
            this.$el.addClass("widgetError");
        },

        _clearError : function(evnt) {
            this.$el.removeClass("widgetError");
        },

        /*
         * @function
         * get child view of exclusion group which needs to be focussed.
         */
        _getChildToFocus : function () {
            return _.find(this.childViews, function (childView) {
                var model = childView.model;
                return (model && model.presence == "visible" && model.mEffectiveAccess == "open");
            });
        }
    });
})(_, $, xfalib);
/**
 * Created with IntelliJ IDEA.
 * User: rpandey
 * Date: 12/24/12
 * Time: 8:14 PM
 * To change this template use File | Settings | File Templates.
 */
(function(_, $, xfalib){
    xfalib.view.SignatureFieldView = xfalib.view.FieldView.extend({
        _createPluginOptions : function() {
            var vOptions = xfalib.view.FieldView.prototype._createPluginOptions.apply(this,
                arguments);
            return vOptions;
        },

        _createDefaultWidgetPlugin : function(options) {
            $(this.widget).signatureField(options);
            this.jqWidget = this.$data(this.widget, "xfaWidget-signatureField");
        }

    });
})(_, $, xfalib);(function (_, $, xfalib) {

    xfalib.view.PagingManager = xfalib.view.ObjectView.extend({

        initialize: function () {
            xfalib.view.ObjectView.prototype.initialize.call(this);
            this.autoRenderPageHandler = null;
            this._autoPageRenderPending = false;
        },

        renderNextPage: function () {
            var that = this;
            var pageView = this._getRootView().renderDeferredPage();
            if (pageView) {
                pageView.on("layoutComplete",
                    function (event) {
                        that.trigger("newPageRender");
                        this._xfaViewRegistry().scaleForm();
                    }
                );
            }
            return pageView;

        },

        autoRenderPage: function () {
            if (this.autoRenderPageHandler) {
                //Ideally autoRenderPageHandler should be postponed till all running layout/display validation cycles are finished and
                //there is no pending layout validation. For now we are doing it in next script cycle/setTimeout.
                var autoRenderHandler = this.autoRenderPageHandler;
                xfalib.ut.XfaUtil.prototype.clearTimeoutOnDestroy(window.setTimeout(autoRenderHandler, 1));
                this._autoPageRenderPending = false;
            }
            else {
                this._autoPageRenderPending = true;
            }
        },

        setAutoRenderPageHandler: function (value) {
            if (this.autoRenderPageHandler != value) {
                this.autoRenderPageHandler = value;
                if (this.autoRenderPageHandler && this._autoPageRenderPending) {
                    this.autoRenderPage();
                }
            }
        },

        hasMorePages: function () {
            return this._getRootView().hasMoreDeferredPages();
        },

        _getRootView: function () {
            return this._xfaViewRegistry().rootSubformView;
        },

        pageCount: function () {
            return (this._getRootView().totPages || 1);
        },

        _makePage: function (pageNum) {
            if (pageNum > this.pageCount()) {
                pageNum = this.pageCount();
            }
            if (pageNum > this.currentPage()) {
                var extPageCounts = pageNum - this.currentPage();
                for (var i = 0; i < extPageCounts; i++) {
                    this.renderNextPage();
                }
            }
            return true;
        },

        currentPage: function () {
            var b = this._getRootView().childViews;
            if (xfalib.view.FieldView.prototype.currentFocus) {
                var a = $(xfalib.view.FieldView.prototype.currentFocus.el).parents(".page")[0];
                //TODO: Try to do without for Loop
                for (var i = 0; i < b.length; i++)
                    if (b[i].el == a)
                        return i;
            }
            return 0;
        },

        pageDown: function () {
            if (this._getRootView().hasMoreDeferredPages()) {
                var pageView = this.renderNextPage();
                this._pageDown(pageView);

            }
            else
                this._pageDown();


        },


        _pageDown: function (pageView) {
            var nextPage = this.currentPage() + 1;
            var a = $($(".page")[nextPage]);
            window.scrollTo(0, a.offset().top);
            pageView.off("layoutComplete",
                function (event) {
                    that._pageDown();
                }
            );
        },

        _makePageForHtmlId: function (htmlId, callback, context) {
            if (htmlId == null)
                return false;
            var nodeSelector = this.jqId(htmlId);
            var rootView = this._getRootView();
            var nodeElArray = rootView.$el.find(nodeSelector);
            if (nodeElArray.length > 0) {
                if (callback)
                    callback.apply(context);
                return true;
            }


            var pageFound = false;
            while (this.hasMorePages()) {
                var view = rootView.renderDeferredPage();
                if (view.$el.find(nodeSelector).length > 0) {
                    if (callback)
//LC-4424 We are sending the event layoutComplete that the layout is complete from our view point but the
// browser has not yet painted the page( Chrome) and hence the focus is coming at the wrong place.
                        view.on("layoutComplete", function () {
                            xfalib.ut.XfaUtil.prototype.clearTimeoutOnDestroy(
                                window.setTimeout(function () {
                                    callback.apply(context);
                                })
                            );
                        });
                    pageFound = true;
                    break;
                }
            }
            if (pageFound)
                return true;
            else
                return false;
        },

        findPage: function (htmlId) {
            if (htmlId == null)
                return false;
            var nodeSelector = this.jqId(htmlId);
            var rootView = this._getRootView();
            var i = 0;
            for (; i < rootView.childViews.length; i++) {
                var nodeElArray = $(rootView.childViews[i].el).find(nodeSelector);
                if (nodeElArray.length > 0) {
                    return i;
                }
            }
            while (this.hasMorePages()) {
                rootView.renderDeferredPage();
                var nodeElArray = $(rootView.childViews[i].el).find(nodeSelector);
                if (nodeElArray.length > 0) {
                    return i;
                }
                i++;
            }
        },

        getLayout: function (htmlId) {
            if (htmlId == null)
                return false;
            var nodeSelector = this.jqId(htmlId);
            var rootView = this._getRootView();
            var el = rootView.$el.find(nodeSelector);
            if (el.get(0)) {
                var layout = this.getOrElse(this.$data(el.get(0), "xfaView"), {});
                return layout.layoutModel;
            }
            else return null;

        },

        _pageContent: function (pageNum, className, bPageArea) {
            bPageArea = bPageArea || false;
            this._makePage(pageNum);
            var pageView = this._getRootView().childViews[pageNum];
            var contentList = new xfalib.script.XfaList();
            if (pageView.model && (!className || className == "pageArea")) {
                contentList._append(pageView.model);
            }
            if (!bPageArea) {
                for (var pv in pageView.childViews) {
                    if (pageView.childViews[pv] instanceof  xfalib.view.ContentAreaView) {
                        contentList._concat(this.$pageContent(pageView.childViews[pv], className, bPageArea));   //Rather than passing the pageArea, we are passing only contentArea
                        // so that it returns all non-pageArea content nodes
                    }

                }
                return contentList;
            }
            contentList._concat(this.$pageContent(pageView, className, bPageArea));
            return contentList;
        },

        $nodeContent: function (node, className, bPageArea) {
            //process child nodes
            var contentList = new xfalib.script.XfaList();
            if (node) {
                _.each(node.children, function (nodeChild) {
                    if (!className && nodeChild.isContainer) {
                        contentList._append(nodeChild);
                    }
                    else if (nodeChild.className == className) {
                        contentList._append(nodeChild);
                    }

                    if (nodeChild.isContainer) {
                        var nodeChildContentList = this.$nodeContent(nodeChild, className, bPageArea);
                        contentList._concat(nodeChildContentList);
                    }
                }, this);
            }
            return contentList;
        },

        $pageContent: function (view, className, bPageArea) {

            var contentList = new xfalib.script.XfaList();
            //process child nodes
            if (bPageArea && view instanceof xfalib.view.ContentAreaView)
                return contentList;      // Breaking the recursion here, so that it will return only pageArea content nodes
            _.each(view.childViews, function (childView) {
                if (childView.model) {
                    var childModel = childView.model;
                    if (!className && childModel.isContainer) {
                        contentList._append(childModel);
                    } else if (childModel.className == className) {
                        contentList._append(childModel);
                    }
                }
                //Time to recurse

                if (childView._isPlaceHolderEl() && childView.model) {
                    //For hidden views that have never been initialized, we would want to return all contained nodes since we stitch
                    //hidden node together in first page.
                    contentList._concat(this.$nodeContent(childView.model, className, bPageArea));
                }
                else {
                    contentList._concat(this.$pageContent(childView, className, bPageArea));
                }

            }, this);
            return contentList;
        }

    });
})(_, $, xfalib);
(function(_, $, xfalib){

        xfalib.view.DataTableView = xfalib.view.ContainerView.extend({

        $elchildren : function(id) {
            return this.$el.children().children(id);
        },

        _getScreenReaderText: xfalib.view.FieldView.prototype._getScreenReaderText,

        _assignToolTip : xfalib.view.FieldView.prototype._assignToolTip

        });
})(_, $, xfalib);
(function(_, $, xfalib){
    var root = window;
    root.xfaViewRegistry = (function(){
        var _templateCache = new xfalib.view.util.HtmlTemplateCache();
        var _layoutManager = new xfalib.view.layout.LayoutManager();
        var xfaUtil = xfalib.ut.XfaUtil.prototype;

        var _viewTypeRegistry = {
            BaseView : xfalib.view.BaseView,
            FieldView : xfalib.view.FieldView,
            NumericFieldView : xfalib.view.NumericFieldView,
            ChoiceListFieldView : xfalib.view.ChoiceListFieldView,
            ObjectView : xfalib.view.ObjectView,
            SubformView : xfalib.view.SubformView,
            SubformSetView : xfalib.view.SubformSetView,
            PageView : xfalib.view.PageView,
            ContentAreaView : xfalib.view.ContentAreaView,
            RootSubformView : xfalib.view.RootSubformView,
            ContainerView : xfalib.view.ContainerView,
            ButtonFieldView : xfalib.view.ButtonFieldView,
            CheckButtonFieldView : xfalib.view.CheckButtonFieldView,
            TextFieldView : xfalib.view.TextFieldView,
            SignatureFieldView : xfalib.view.SignatureFieldView,
            ImageFieldView : xfalib.view.ImageFieldView,
            XfaDrawView : xfalib.view.XfaDrawView,
            DateTimeFieldView: xfalib.view.DateTimeFieldView,
            ExclGroupView: xfalib.view.ExclGroupView,
            DataTableView: xfalib.view.DataTableView
        };

        var _defaultDraw = {
            view : _viewTypeRegistry.XfaDrawView
        };

        var _defaultField = {
            view : _viewTypeRegistry.FieldView,
            widgetTemplate : null,
            viewInitConfig : {
                commitEvent : xfalib.ut.XfaUtil.prototype.XFA_EXIT_EVENT,
                commitProperty : "value",
                commitTarget : "rawValue"
            }
        };
        var _defaultContainer = {
            view : _viewTypeRegistry.ContainerView
        };
        var _defaultDataTable = {
            view : _viewTypeRegistry.DataTableView
        };

        var _nodeTypeRegistry = {
            //Containers
            "area" :    _defaultContainer,
            "contentarea" : {view : _viewTypeRegistry.ContentAreaView},
            "exclgroup" : {view : _viewTypeRegistry.ExclGroupView},
            "page" : {view : _viewTypeRegistry.PageView},
            "subform" : {view : _viewTypeRegistry.SubformView},
            "subformset" : {view : _viewTypeRegistry.SubformSetView},
            "rootsubform" : {view : _viewTypeRegistry.RootSubformView},

            //Fields
            "textfield" : {
                view : _viewTypeRegistry.TextFieldView,
                viewInitConfig : {
                    commitEvent : xfalib.ut.XfaUtil.prototype.XFA_EXIT_EVENT,
                    commitProperty : "value",
                    commitTarget : "rawValue"
                }
            },
            "signaturefield" : {
                view : _viewTypeRegistry.SignatureFieldView,
                viewInitConfig : {
                    commitEvent : xfalib.ut.XfaUtil.prototype.XFA_EXIT_EVENT,
                    commitProperty : "value",
                    commitTarget : "rawValue"
                }
            },
            "textareafield" : {
                view : _viewTypeRegistry.TextFieldView,
                viewInitConfig : {
                    commitEvent : xfalib.ut.XfaUtil.prototype.XFA_EXIT_EVENT,
                    commitProperty : "value",
                    commitTarget : "rawValue"
                }
            },
            "numericfield" : {
                view : _viewTypeRegistry.NumericFieldView,
                viewInitConfig : {
                    commitEvent : xfalib.ut.XfaUtil.prototype.XFA_EXIT_EVENT,
                    commitProperty : "value",
                    commitTarget : "rawValue"
                }
            },
            "imagefield" : {
                view : _viewTypeRegistry.ImageFieldView,
                viewInitConfig : {
                    commitEvent : xfalib.ut.XfaUtil.prototype.XFA_CHANGE_EVENT,
                    commitProperty : "src",
                    commitTarget : "rawValue"
                }
            },
            "datefield" : {
                view : _viewTypeRegistry.DateTimeFieldView,
                viewInitConfig : {
                    commitEvent : xfalib.ut.XfaUtil.prototype.XFA_EXIT_EVENT,
                    commitProperty : "value",
                    commitTarget : "rawValue"
                }
            },
            "timefield" : _defaultField,
            "datetimefield" : _defaultField,
            "passwordfield" : _defaultField,
            "buttonfield" : {
                view : _viewTypeRegistry.ButtonFieldView,
                viewInitConfig : {
                    commitEvent : null,
                    commitProperty : "value",
                    commitTarget : "rawValue"
                }
            },
            "submitfield" : _defaultDraw,
            "radiofield" : {
                view : _viewTypeRegistry.CheckButtonFieldView,
                viewInitConfig : {
                    commitEvent : xfalib.ut.XfaUtil.prototype.XFA_CHANGE_EVENT,
                    commitProperty : "value",
                    commitTarget : "rawValue"
                }
            },
            "checkboxfield" : {
                view : _viewTypeRegistry.CheckButtonFieldView,
                viewInitConfig : {
                    commitEvent : xfalib.ut.XfaUtil.prototype.XFA_CHANGE_EVENT,
                    commitProperty : "value",
                    commitTarget : "rawValue"
                }
            },
            "choicelist" : {
                view : _viewTypeRegistry.ChoiceListFieldView,
                viewInitConfig : {
                    commitEvent : xfalib.ut.XfaUtil.prototype.XFA_CHANGE_EVENT,
                    commitProperty : "value",
                    commitTarget : "rawValue"
                }
            }
        };


        return {
            viewTypeRegistry : _viewTypeRegistry,
            rootSubformView : null,
            nodeTypeRegistry : _nodeTypeRegistry,
            _userConfig : null,

            widgetConfig : function(){
                if(this._userConfig && this._userConfig["widgetConfig"]){
                    return this._userConfig["widgetConfig"];
                }
            },

            pagingConfig : function(){
                if(this._userConfig && this._userConfig["pagingConfig"]){
                    return this._userConfig["pagingConfig"];
                }
                var shrinkPageDisabledValue = false;
                if(this._userConfig && this._userConfig["behaviorConfig"]){
                    //TODO: Create a generic method somewhere in FormBridge?
                    var version = new xfalib.ut.Version(this._userConfig["behaviorConfig"]);
                    if(version.isPreviousOrSame(version.ES4))
                        shrinkPageDisabledValue = true;
                }

                return {
                    pagingDisabled : false,
                    shrinkPageDisabled : shrinkPageDisabledValue
                };
            },

            lookUpView : function(options){
                options = options || {};

                if(options.dataTable)
                    return _defaultDataTable;
                var nodeTypeView = this.nodeTypeRegistry[options.nodeType];
                if(nodeTypeView)
                    return nodeTypeView;

                if(options.field)
                    return _defaultField;
                else if(options.draw)
                    return _defaultDraw;
                else
                    return _defaultContainer;
            },

            createView : function(htmlDomNode, options){
                var $htmlDomNode = $(htmlDomNode);
                var nodeType = (xfaUtil.$data($htmlDomNode.get(0), xfalib.view.LayoutConst.XFA_MODEL) ||{})[xfalib.view.LayoutConst.NODE_TYPE];
                var isField = $htmlDomNode.hasClass("field");
                var isDraw = $htmlDomNode.hasClass("draw");
                var isDataTable = ($htmlDomNode.prop("tagName") == "TABLE");
                var isDataTableRow = ($htmlDomNode.prop("tagName") == "TR");
                var isDataTableCell = ($htmlDomNode.prop("tagName") == "TD" || $htmlDomNode.prop("tagName") == "TH" );
                var viewOptions = {
                    "nodeType" : nodeType,
                    "field" : isField,
                    "draw" : isDraw,
                    "dataTable" : isDataTable,
                    "dataTableRow" : isDataTableRow,
                    "dataTableCell" : isDataTableCell
                };
                var viewConfig = this.lookUpView(viewOptions);
                var initParam =  _.extend(
                    {el:htmlDomNode},
                    viewConfig["viewInitConfig"],
                    options
                );
                var viewInstance =  new viewConfig["view"](initParam);
                return viewInstance;
            },

            /**
             * Clears the template cache. The API is needed to clear the cache when
             * unloading one form and loading another form in Form Set.
             */
            clearTemplateCache: function () {
                _templateCache = new xfalib.view.util.HtmlTemplateCache();
            },

            /**
             * Clears the Layout Manager. The API is needed to unload the layout Manager
             * when unloading one form and loading another form in Form Set.
             */
            resetLayoutManager : function () {
              _layoutManager = new xfalib.view.layout.LayoutManager();
            },

            /**
             * The function is used to destroy the resources held by the object.
             * This function is called when the form is destroyed.
             */
            destroy: function () {
                _templateCache = undefined;
                _layoutManager = undefined;
            },

            templateCache : function(){
                return _templateCache;
            },

            layoutManager : function(){
                return _layoutManager;
            },


            /*
             * look ups the formWidth value in behaviourConfig; and if browser supports scaling, enforce that width by scaling the form
             */
            scaleForm: function () {
                var formWidth = this._userConfig["viewportWidth"];
                if (formWidth) {
                    var timeout = window.setTimeout(function () {     // wait for enough time to let layout complete
                        formWidth = parseInt(formWidth);
                        var pageMaxWidth = 0;
                        $(".page").each(function (i, obj) {
                            var tmpWidth = parseInt($(obj).width());
                            if (tmpWidth > pageMaxWidth)
                                pageMaxWidth = tmpWidth;
                        });
                        var width = pageMaxWidth,
                            height = parseInt($("body").height()),
                            scaleFactor = xfalib.ut.XfaUtil.prototype.formScaleFactor = formWidth / width,
                            transformValue = "scale(" + scaleFactor + ")",
                            marginHeight = height - scaleFactor * height,
                            marginWidth = width - scaleFactor * width,
                            scaleStyles = {
                                "-webkit-transform": transformValue, /* Saf3.1+, Chrome */
                                "-moz-transform": transformValue, /* FF3.5+ */
                                "-ms-transform": transformValue, /* IE9 */
                                "transform": transformValue,
                                "-webkit-transform-origin": "0 0",
                                "-moz-transform-origin": "0 0",
                                "-ms-transform-origin": "0 0",
                                "transform-origin": "0 0",
                                /* below two values are based on total heuristics. best combination to get thing working cross browser:
                                 *  In few browsers, after scaling there is blank space on bottom so margin-bottom is used with negative value.
                                 *  margin right is required for removing space on right in few browser, after scaling.
                                 *  And interestingly, formulae for both are different, not my mistake- total heuristics.
                                 *  IE still has space left in bottom&right in scaled down version but works good in scale up version.
                                 *  New, step would be to make these values per browser type. But common for now.
                                 * */
                                "margin-bottom": Math.min(0, -1 * marginHeight),
                                "margin-right": -1 * marginWidth
                            }
                        $("body").css(scaleStyles);
                        $(".page").css("margin", 0);
                        /*dispatch event so that toolbar and other widths can be re-computed.*/
                        $(window.formBridge).trigger("xfaFormScale");
                    }, 100);
                    xfalib.ut.XfaUtil.prototype.clearTimeoutOnDestroy(timeout);
                }
            },

            /*
             * Invalidates tab indexes for given page number. Note that page number starts with one.
             */
            invalidateTabIndex : function(pageNum){
                if(pageNum > -1 && this.rootSubformView && this.rootSubformView.childViews ){
                    var pageView = this.rootSubformView.childViews[pageNum -1];
                    if(pageView){
                        pageView.invalidateTabIndex();
                    }
                }
            }
        };
    })();

    root.xfaViewRegistry.initializeView = function(firstPageHtmlStr, restOfThePages){
        var viewStartTime = Date.now();
        var $formHtml = $(firstPageHtmlStr);
        var options = {};
        options.restOfThePages = restOfThePages;
        var pagingManager = new xfalib.view.PagingManager();
        xfalib.runtime.xfa.host.pagingManager = pagingManager;
        xfalib.runtime.xfa.$layout.pagingManager = pagingManager;
        window.xfaViewRegistry.rootSubformView = window.xfaViewRegistry.createView($formHtml, options);
        xfalib.runtime.xfa.host.on(xfalib.script.XfaModelEvent.FORM_MODEL_REFRESH,{
            handleEvent: function(evnt) {
                switch(evnt.name) {
                    case xfalib.script.XfaModelEvent.FORM_MODEL_REFRESH:
                        window.xfaViewRegistry.rootSubformView.syncFormNodeToHtml(true);
                        break;
                    default:
                    /* log an error message */
                }
            }
        });
        //TODO: move this to Logger
        formBridge.viewTime = Date.now()-viewStartTime;
        xfalib.runtime.xfa.Logger.debug("xfaView","################ total time to create view:"+formBridge.viewTime);
        return $formHtml;
    };

    root.xfaViewRegistry.initializeModel = function(xfaJson, xfaDataMergeDorm, xfalocaleset, xfarendercontext) {
        //read renderContext and other xfa specific node and push it
        xfalib.runtime.renderContext = xfarendercontext;

        if(xfalib.ut.XfaUtil.prototype.getOrElse(xfalib.runtime, "customPropertyMap.xmlOnClient", "0") === "1") {
            if(xfalib.runtime.renderContext.data) {
                formBridge.playDataXML({
                    xmlDocument : xfalib.runtime.renderContext.data
                });
            }
        }
        //read localeset as well
        xfaJson.localeSet = xfalocaleset;

        //Create Xfa Node
        xfalib.script.XfaModelRegistry.prototype.createModel(xfaJson);       //TODO: Handle window dependency

        if(xfalib.runtime.xfa.Logger.isLogEnabled("xfa", xfalib.ut.Logger.prototype.TRACE)){
            xfalib.runtime.xfa.Logger.trace("xfa","################ t0 xfadom:\n" + JSON.stringify(xfaJson));
        }

        var hasRestoreState = false;
        if (window.formBridge != undefined) {
            var localStorage = window.formBridge._getStorage();
            if (localStorage && localStorage.xfaDom) {
                xfaJson = JSON.parse(localStorage.xfaDom);
                if(xfaJson) {
                    hasRestoreState = true;
                    if(xfalib.runtime.xfa.Logger.isLogEnabled("xfa", xfalib.ut.Logger.prototype.TRACE)){
                        xfalib.runtime.xfa.Logger.trace("xfa","################ restore xfadom:\n" + JSON.stringify(xfaJson));
                    }
                    xfalib.runtime.xfa.host.playJson(xfaJson);
                }
            }
            var xmlStorage = window.formBridge._getXmlStorage();
            if(xmlStorage) {
                xfalib.runtime.xfa.Logger.trace("xfa","################ restore xml:\n" + xmlStorage);
                try {
                    xfalib.runtime.xfa.host.playDataXml(xmlStorage);
                } catch(exception) {
                    xfalib.runtime.xfa.Logger.error("xfa", "restoring xml failed ")
                    if(_.isFunction(formBridge.xmlStorage.error)) {
                        var resObj = formBridge._getResultObject();
                        resObj.addMessage(2, exception, null);
                        formBridge.xmlStorage.error.apply(formBridge.xmlStorage.context, [resObj])
                        //to ensure that success handler is not called after form render from FormBridge._xfaInitialized
                        formBridge.xmlStorage.success = null;
                    }
                }
            }
        }
        if( xfalib.ut.XfaUtil.prototype.getOrElse(xfalib.runtime, "customPropertyMap.xmlOnClient", "0") !== "1") {
            if(!hasRestoreState && xfaDataMergeDorm){
                if(xfalib.runtime.xfa.Logger.isLogEnabled("xfa", xfalib.ut.Logger.prototype.TRACE)){
                    xfalib.runtime.xfa.Logger.trace("xfa","################ restore xfadom:\n" + JSON.stringify(xfaDataMergeDorm));
                }
                xfalib.runtime.xfa.host.playJson(xfaDataMergeDorm);
            }
        }
        if( xfalib.ut.XfaUtil.prototype.getOrElse(xfalib.runtime, "customPropertyMap.destroyOnExit", "0") === "1") {
            $(window).on("beforeunload.xfa", function () {
                formBridge.destroyForm(true);
            });
        }
    };

    root.xfaViewRegistry.initializeFormOnDomReady = function() {
        $(function($){
            try {
                var initStart = Date.now();
                //initialize Acrobat specific scripts
                new xfalib.acrobat.Acrobat();
                if(xfalib.runtime.xfa) {
                    xfalib.runtime.xfa.form._initialize(true);
                    $(window).trigger("XfaInitialized");
                }
                formBridge.modelInitTime = Date.now()-initStart;
                xfalib.view.FieldView.prototype.currentFocus = null;
                $(window).on("mousedown.xfa", function() {
                    formBridge.clickedOnWindow = true;
                });
            } catch(e) {
                xfalib.runtime.xfa.Logger.error("xfa","error in form._initialize");
                if(e.stack){
                    xfalib.runtime.xfa.Logger.error("xfa", e.stack);
                }
            }
        });
    };

    //TODO: Put below call at proper place
    window._initializeXfaLoading = function (xfaJson, xfaDataMergeDorm, xfalocaleset, xfarendercontext, fileAttachmentMap) {
        window.formBridge._postExternalMessage({name : "_formdomstart"});
        var xfaModelLoadStart = Date.now();
        var xfaViewRegistry = window.xfaViewRegistry;

        //read internal css and attach it to head
        //excuse m
        if($('#formLoadingDiv').data('internalcss')) {
            var internalcss = $('#formLoadingDiv').data('internalcss'),
                styleTag = '<style id="mfstyle" type="text/css">'+internalcss+'</style>';
            //insert internal css before the first style element.
            if($('head>style:first').length > 0)
                $('head>style:first').before(styleTag);
            else if($('head').length > 0)
                $('head').append(styleTag);
            else if($('body').length > 0)
                $('body').prepend(styleTag);
            else if($('html').length > 0)
                $('html').prepend(styleTag);
            else
                $('#formLoadingDiv').prepend(styleTag);
        }

        xfaViewRegistry.initializeModel(xfaJson, xfaDataMergeDorm, xfalocaleset, xfarendercontext);

        window.formBridge._postExternalMessage({name : "_layoutstart"});
        xfaViewRegistry._userConfig = window.formBridge.userConfig;
        //TODO: move this to Logger
        formBridge.modelTime = Date.now()-xfaModelLoadStart;
        xfalib.runtime.xfa.Logger.debug("xfaView","################ total time to load xfa model:"+ formBridge.modelTime);

        xfalib.runtime.xfa.form.mbInitialized = false;

        var xfahtmldom =  $('#formLoadingDiv').data('xfahtmldom');
        var xfaresthtmldom = $('#formLoadingDiv').data('xfaresthtmldom');
        var xfahiddenobjdom = $('#formLoadingDiv').data('xfahiddenobjdom');

        xfalib.runtime.xfa.Logger.trace("xfaView","################ xfahtmldom:\n" + xfahtmldom);
        xfalib.runtime.xfa.Logger.trace("xfaView","################ xfaresthtmldom:\n" + xfaresthtmldom);
        xfalib.runtime.xfa.Logger.trace("xfaView","################ xfahiddenobjdom:\n <a>" + xfahiddenobjdom + "</a>");

        xfaViewRegistry.templateCache().setHiddenObjPages(xfahiddenobjdom); //cache the pages with hidden object layout
        $('#formLoadingDiv').replaceWith(xfaViewRegistry.initializeView( xfahtmldom, xfaresthtmldom));

        xfalib.runtime.xfa.Logger.debug("xfaView","################ total time to load xfa model + view:"+(Date.now()-xfaModelLoadStart));
        window.formBridge._postExternalMessage({name : "_layoutend"});

        xfaViewRegistry.initializeFormOnDomReady();

        xfalib.runtime.xfa.form.mbInitialized = true;

        // Restore attachments
        // We are setting this which is passed by file attachment plugin to  the fileUpload widget
        // as options.value and then widget creation takes place
        if(xfalib.runtime) {
            xfalib.runtime.fileAttachment = fileAttachmentMap;
        }

    };

})(_, $, xfalib);
