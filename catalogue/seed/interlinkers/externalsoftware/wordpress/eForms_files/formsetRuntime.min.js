/*******************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by all applicable intellectual property
 * laws, including trade secret and copyright laws.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 ******************************************************************************/


(function () {
    var FormsetResultObject = function () {
        var messages = [],
            errorCode = null,
            result = true,
            data = null;

        this.addMessage = function (msg) {
            messages.push(msg);
        };

        this.setData = function (d) {
            if (data == null) {
                data = d;
            }
        };

        this.getData = function () {
            return data;
        };

        this.setErrorCode = function (code) {
            if (errorCode === null) {
                result = false;
                errorCode = code;
            }
        };

        this.getErrorCode = function () {
            return errorCode;
        };

        this.isSuccess = function () {
            return result;
        };

        this.getNextMessage = function () {
            if (messages.length) {
                return messages.shift();
            }
            return null;
        };
    };

    formset.lib.FormsetResultObject = FormsetResultObject;
}());
/*******************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by all applicable intellectual property
 * laws, including trade secret and copyright laws.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 ******************************************************************************/

(function ($, _) {
    var currentFormBridge = null, 
        formCustomObject = null,
		sepCustomFormObject,
        formsetJson = {
            formsInfo: {},
            renderContext: {}
        },
        initialized = false,
        handlers = [],
        bridgeConfiguration,
        functionsMap = {
            "formBridge": {
                getFormState: {
                    name: "getFormState",
                    arguments: [true, 1]
                },
                restoreFormState: "restoreFormState",
                validateForm: "validateForm",
                hideSaveSubmitButtons: "hideSubmitButtons",
                playDataXML: "playDataXML",
                destroyForm: "destroyForm",
                getXML: "generateDataXML",
                setFocus: "setFocus",
                getNavigator: "getNavigator"
            }
        },
        activatedFunctionsMap = null,
        formRenderProfile = null,
        userConfig = {},
        started = false,
        formsetDraft = null,
        FormsetBridge = function () {
            this.formProvider = null;
        },
        //current XML Document
        currentXMLDocument;



    _.extend(FormsetBridge.prototype, {

        /**
         * Registers user/portal specific configurations to GuideBridge and returns the old configuration against the
         * same key
         * Currently Supported Configuration are
         * serverUrlConfig: {
         *      host: <host name> [default: localhost]
         *      port: <port name> [default: 4502]
         *      scheme: <scheme of the url> [default: http]
         *      contextPath: <context Path of the URL>
         * }
         *
         * @param key
         * @param config {object}
         * @returns {*}
         */
        registerConfig: function (key, config) {
            var result = userConfig[key];
            if(config !== undefined) {
                userConfig[key] = config;
            }
            return result;
        },

        registerMFConfig: function(configuration) {
            if(currentFormBridge != null) {
                registerBridgeConfigurations(configuration);
            } else {
                bridgeConfiguration = configuration;
            }
        },

        _getCurrentFormBridge: function() {
            return currentFormBridge;
        },

        /**
         * constructs the URL from the serverUrlConfig if registered without the trailing /. If the configuratio is not
         * registered returns empty string.
         * @returns {string}
         */
        _getServerUrl: function () {
            var config = userConfig.serverUrlConfig;
            if (_.isObject(config)) {
                var scheme = config.scheme || "http",
                    host = config.host || "localhost",
                    port = config.port || "4502",
                    contextPath = config.contextPath || "";
                return scheme + "://" + host + ":" + port + contextPath;
            }
            return "";
        },

        /**
         * registers the FormProvider object with the Formset Runtime. This FormProvider must provide the implementation
         * of the Form Provider Interface. Only one FormProvider can be set, it is not permitted to set the provider again
         * @param formProvider
         * @return {formset.lib.FormsetResultObject} If the registration is successful returns formProvider as the data
         * member. otherwise returns the object with errorCode as registrationError.
         */
        setFormProvider: function (formProvider) {
            var resultObj = new formset.lib.FormsetResultObject();
            if (this.formProvider == null) {
                resultObj.setData(formProvider);
                this.formProvider = formProvider;
                return resultObj;
            }
            resultObj.setErrorCode("registrationError");
            resultObj.addMessage({
                message: "FormProvider already registered"
            });
            return resultObj;
        },

        /**
         * Returns the formProvider registered with the Formset Runtime
         * @returns {null|*|FormsetBridge.formProvider}
         */
        getFormProvider: function () {
            return this.formProvider;
        },

        /**
         * Returns the Formstate of the current Form. It queries the Bridge API to get the diffJSON of the current Form
         * @returns {FormsetResultObject}
         */
        getCurrentFormstate: function () {
            var fn = activatedFunctionsMap.getFormState,
                formState = currentFormBridge[fn.name].apply(currentFormBridge, fn.arguments),
                resultObj = new formset.lib.FormsetResultObject(),
                msg;
            if (formState.errors) {
                msg = formState.getNextMessage();
                resultObj.setErrorCode(msg.code);
                resultObj.addMessage({
                    message: msg.message
                });
            }
            resultObj.setData(formState.data);
            return resultObj;
        },

        /**
         * Returns the form number of the form currently visible
         * @returns {number}
         */
        getCurrentFormNumber: function () {
            return this._getFormList().getCurrentFormNumber();
        },

        /**
         * Returns the uid of the current rendered form
         * @returns {string}
         */
        getCurrentFormId: function () {
            var currentFormNumber = this.getCurrentFormNumber();
            if (currentFormNumber !== formset.constants.InvalidFormNumber) {
                return this._getForm(currentFormNumber).uid;
            }
            return null;
        },

        /**
         * Returns the form number given the uid of the form.
         * Returns formset.constants.InvalidFormNumber if no formUid exists in the formset.
         * @param formUid
         * @returns {number}
         */
        getFormNumberByUid: function (formUid) {
            if(formUid) {
                var theForm = _.chain(formsetJson.formsInfo)
                               .find(function (form) {return form.uid == formUid})
                               .value();

                if (theForm) {
                    return theForm.formNumber;
                }
            }

            return formset.constants.InvalidFormNumber;
        },

        /**
         * Returns form Information of the formNumber
         * @param formNumber
         * @returns {form}
         * @private
         */
        _getForm: function (formNumber) {
            return formsetJson.formsInfo[formNumber];
        },
        /**
         *
         * @param formNumber
         * @returns an apt string to be used as name/identifier for forms messages/logs to user
         * @private
         */
        _getFormName: function(formNumber) {
            return  formsetJson.formsInfo[formNumber].title.trim()
                 || formsetJson.formsInfo[formNumber].template.replace(/\.xdp$/, "").trim()
                 || formsetJson.formsInfo[formNumber].uid.trim()
                 || formsetJson.formsInfo[formNumber].formNumber;
        },

        /**
         * Returns the form given a formUid. Returns null if no such form exists
         * The form contains, templateName, contentRoot, dataRoot, uid and formNumber.
         * @param formUid id of the form to search for.
         * @returns form having the uid as formUid or null if no such form exists
         */
        getForm: function (formUid) {
            if (formUid == null) {
                return null;
            }
            var formNumber = this.getFormNumberByUid(formUid);
            if (formNumber === formset.constants.InvalidFormNumber) {
                return null;
            }
            return _.extend({}, this._getForm(formNumber));
        },
		/**
         *
         * @param formNumber
         * @returns an apt string to be used as name/identifier for forms messages/logs to user
         * @private
         */
        _getFormName: function(formNumber) {
            return  formsetJson.formsInfo[formNumber].title.trim()
                 || formsetJson.formsInfo[formNumber].template.replace(/\.xdp$/, "").trim()
                 || formsetJson.formsInfo[formNumber].uid.trim()
                 || formsetJson.formsInfo[formNumber].formNumber;
        },
 		/**
         *
         * @param formNumber
         * @returns ANDREA CODE an apt string to be used as name/identifier for forms messages/logs to user
         */
          getFormName: function(formNumber) {
            return  formsetJson.formsInfo[formNumber].title.trim()
                 || formsetJson.formsInfo[formNumber].template.replace(/\.xdp$/, "").trim()
                 || formsetJson.formsInfo[formNumber].uid.trim()
                 || formsetJson.formsInfo[formNumber].formNumber;
        },


        /**
         * Returns the form given a formUid. Returns null if no such form exists
         * The form contains, templateName, contentRoot, dataRoot, uid and formNumber.
         * @param formUid id of the form to search for.
         * @returns form having the uid as formUid or null if no such form exists
         */
        getForm: function (formUid) {
            if (formUid == null) {
                return null;
            }
            var formNumber = this.getFormNumberByUid(formUid);
            if (formNumber === formset.constants.InvalidFormNumber) {
                return null;
            }
            return _.extend({}, this._getForm(formNumber));
        },
        /**
         * returns a list of eligible formIds
         * @returns {Array}
         */
        getAllEligibleForms: function () {
            this.updateCurrentXML();
            var loader = this._getFormLoader();
            return _.map(formsetJson.formsInfo, function (form) {return form.formNumber}).filter(loader.isFormEligible);
        },

        /**
         * Restores the Formstate of the current Form. It passes the diffJSON to the current Form using the Bridge API
         * @returns {*}
         */
        _restoreFormstate: function (formState, options) {
            var _options = options || {},
                successHandler = _options.success || null,
                errorHandler = _options.error || null,
                context = _options.context || this;
            return currentFormBridge[activatedFunctionsMap.restoreFormState]({
                formState: formState,
                success: successHandler,
                error: errorHandler,
                context: context
            });
        },

        /**
         * Returns the FormNavigator Object
         * @returns {FormNavigator}
         */
        getNavigator: function () {
            return formset.runtime.FormNavigator;
        },

        _getFormLoader: function () {
            return formset.runtime.FormLoader;
        },

        _getFormList: function () {
            return formset.runtime.formsList;
        },

        _getFormCustomObject: function () {
            return formset.runtime.FormCustomObject;
        },

        _getSepCustomFormObject: function () {
            return formset.runtime.SepCustomFormObject;
        },


        /**
         * restores the formset state using the formset state provided in the options.
         * @param options object with the following structure
         * {
         *   successHandler: function () {} // success handler which is called upon completion of the request
         *   errorHandler: function () {} // error handler to be called if something fails
         *   context: object // object to be used as 'this' object in the success and error handlers
         *   formsetState: object // formsetState which has to be restored
         *
         * }
         */
        restoreFormsetState: function (options) {
            if (!_.isObject(options)) {
                return;
            }
            var renderContext = options.renderContext,
                errorHandler = options.errorHandler,
                successHandler = options.successHandler,
                context = options.context;

            if (started === false) {
                formsetDraft = options;
            } else {
                playFormset({
                    renderContext : renderContext,
                    success: successHandler,
                    error: errorHandler,
                    context: context
                });
            }
        },

        /**
         * It appends all the prefillJSON into a set and calls the callback function onComplete. The function is recursive
         * since the getPrefillJSON API can be asynchronous
         * @param formJson
         * @param renderedForms
         * @param index
         * @param onComplete
         * @param context : context and internal state to be passed on to formProvider.getPrefillJson
         * @private
         */
        _appendAllPrefillJson: function (formJson, renderedForms, index, onComplete, context) {
            if(index < renderedForms.length) {
                var form = renderedForms[index];
                this.formProvider.getPrefillJson(form.formNumber, {
                    context: _.extend(this, context),
                    success: function (prefillJson) {
                        var valid = form.validationStatus,
                            submitForm = {
                                formNumber: form.formNumber,
                                prefillJson: prefillJson,
                                validationStatus: valid
                            };
                        //add invalid field only if form has validation errors
                        if (valid === false) {
                            submitForm.invalidField = form.invalidField;
                        }
                        formJson.push(submitForm);
                        this._appendAllPrefillJson(formJson, renderedForms, index + 1, onComplete, context);
                    },
                    error: function () {
                        //log here
                        this._appendAllPrefillJson(formJson, renderedForms, index + 1, onComplete, context);
                    }
                });
            } else {
                onComplete.apply(this);
            }
        },

        /**
         * Returns a JsonObject containing the data xml. The object has a single key dataXML which is a string
         * containing the data xml
         * @param options object with the following structure
         * {
         *   successHandler: function (dataxml) {} // success handler which is called upon completion of the request
         *   errorHandler: function () {} // error handler to be called if something fails
         *   context: object // object to be used as 'this' object in the success and error handlers
         *   renderContext: object // renderContext of the formset
         *   keepSubmittedFormNumber: boolean // whether to keep the submitted form number or not. During prefill the
         *                                      // submitted form number is used to load the appropriate form in formset
         * }
         * @param options
         * @throws exception if the service URL to get XML is not defined.
         */
         setGhostData: function (data, participants) {
              formCustomObject = this._getFormCustomObject();
              formCustomObject.setGhostTexts(data);
              sepCustomFormObject = this._getSepCustomFormObject();
              sepCustomFormObject.setGhostTexts(data, participants);


         },

        getDataXml: function (options) {
            var url = this.getFormsetUrl(),
                _options = options || {},
                bKeepSubmittedFormNumber = _options.keepSubmittedFormNumber === true,
                successHandler = _options.successHandler,
                errorHandler = _options.errorHandler,
                context = _options.context || this,
                formsetSubmitJson = {},
                renderContext = _options.renderContext || this.getRenderContext(false),
                resultObj = new formset.lib.FormsetResultObject();
            if(_options.renderContext == null) {
                this._getFormList().addDiffJson(this.getCurrentFormstate().getData());
            }
            // do not send the clientXml for now
            renderContext._clientXml = undefined;
            var formJson = [];
            this._appendAllPrefillJson(formJson, renderContext.renderedFormsList, 0, function () {
                // This case will happen only when this API is called in the background without loading the Formset
                // Generally happens with MWS

                if (url == null) {
                    url = this._getServerUrl() + renderContext.formsetUrl;
                }
                if (url == null) {
                    // log "Service URL to get XML empty";
                    resultObj.setErrorCode("emptyFormsetUrl");
                    resultObj.addMessage({
                        message: "Service URL to get XML empty"
                    });
                    if (errorHandler) {
                        errorHandler.apply(context, [resultObj]);

                    }
                    return;
                }
                formsetSubmitJson.formjson = formJson;
                //removing unnecessary payload in renderContext
				 console.log("renderContext.formsetPath <><><> "+ renderContext.formsetPath);
                console.log("renderContext.currentFormNumber <><><> "+ renderContext.currentFormNumber);
                console.log("bKeepSubmittedFormNumber <><><> "+ bKeepSubmittedFormNumber);

                formsetSubmitJson.renderContext = {
                    currentFormNumber: renderContext.currentFormNumber,
                    xml: renderContext.xml,
                    formsetPath: renderContext.formsetPath
                };
                $.ajax({
                    url: url + ".formset.dataxml.html",
                    type: "POST",
                    data: {
                        "formsetSubmitJson": JSON.stringify(formsetSubmitJson),
                        "keepSubmittedFormNumber": bKeepSubmittedFormNumber
                    }
                }).done(function (data) {
                    var dat = formCustomObject.processXmlData(data.dataXML);                  
                    resultObj.setData(dat);

                    if (successHandler) {
                        successHandler.apply(context, [resultObj]);
                    }
                }).fail(function (xhr) {
                    resultObj.setErrorCode("unknownException");
                    resultObj.addMessage({
                        message: "Unknown Exception while generating data xml" + xhr.status + " " + xhr.statusText
                    });
                    if (errorHandler) {
                        errorHandler.apply(context, [resultObj]);
                       

                    }
                });
            }, context);
        },

        /**
         * Generates a JSONObject that contains the renderContext and all the prefillJSON of the rendered forms.
         * Calls the onComplete callback on completion. The callback is passed the JSON Object
         * @param onComplete
         * @private
         */
        _generateFormsetSubmitJson: function (onComplete) {
            var renderContext = this.getRenderContext(false),
                formJson = [],
                formsetSubmitJson = {},
                self = this;
            this._getFormList().addDiffJson(this.getCurrentFormstate().getData());
            this._appendAllPrefillJson(formJson, renderContext.renderedFormsList, 0, function () {
                formsetSubmitJson.renderContext = {
                    currentFormNumber: renderContext.currentFormNumber,
                    xml: renderContext.xml,
                    formsetPath: renderContext.formsetPath
                };
                formsetSubmitJson.formjson = formJson;
                onComplete.apply(self, [formsetSubmitJson]);
            });
        },

        /**
         * Submits the data to submitServlet.
         *
         * @param options
         * {
         *   error: function (formsetResultObject) {
         *      errorCode: currentFormInvalid/UnexpectedError/FormsetIncomplete/serverConnectionFailed
         *      message: SOM Expression/ Error Message
         *   }
         * }
         */
        submitForm: function (options) {
            var validResult = this.validateFormset(),
                operationData = validResult.getData(),
                resultObj = new formset.lib.FormsetResultObject(),
                msg,
                reason,
                _options = options || {},
                disableHeadRequest = false,
                error = _options.error,
                context = _options.context || window,
                networkConnection = true;
            if (!validResult.isSuccess() || operationData.valid === false) {
                reason = validResult.isSuccess() ? operationData.reason : validResult.getErrorCode();
                resultObj.setErrorCode(reason);
                msg = validResult.getNextMessage();
                while (msg) {
                    resultObj.addMessage(msg);
                    msg = validResult.getNextMessage();
                }
                if (error) {
                    error.apply(context, [resultObj]);
                }
                return;
            }

            if (!disableHeadRequest) {
                $.ajax({
                    async: false,
                    url: this.getFormsetUrl() + ".formset.submit.html",
                    type: 'HEAD',
                    complete: function (xhr) {
                        var msg = null;
                        switch (xhr.status) {
                        case 0:
                            msg = xfalib.locale.LogMessages["ALC-FRM-901-008"] + " " + xhr.statusText;
                            break;
                        case 404:
                            msg = xfalib.locale.LogMessages["ALC-FRM-901-008"] + " " + xhr.statusText;
                            break;
                        }
                        if (msg) {
                            resultObj.setErrorCode("serverConnectionFailed");
                            resultObj.addMessage({
                                message: msg
                            });
                            if (error) {
                                error.apply(context, [resultObj]);
                            }
                            networkConnection = false;
                        }
                    }
                });
            }

            if (!networkConnection) {
                return;
            }

            this._generateFormsetSubmitJson(function (formsetSubmitJson) {

                var url = this.getFormsetUrl(),
                    $form = $("<form></form>").attr({
                        "method": "post",
                        "enctype": "multipart/form-data",
                        "action": url + ".formset.submit.html"


                    });

                $form.append($("<input>")
                    .attr("type", "hidden")
                    .attr("name", "formsetSubmitJson")
                    .val(JSON.stringify(formsetSubmitJson))).appendTo("body");

                $form.submit();

            });
        },

        /**
         * Returns a copy of the FormsInfo List (result of the listForms API)
         */
        _getFormSetJson: function () {
            return _.extend({}, formsetJson);
        },

        /**
         * API to register a callback to be called upon Formset initialization
         * @param handler
         * @param context
         */
        connect: function (handler, context) {
            if (initialized) {
                handler.apply(context, [this]);
            } else {
                handlers.push({
                    fn: handler,
                    context: context
                });
            }
        },

        initialized: function () {
            if (initialized === false) {
                _.each(handlers, function (handler) {
                    handler.fn.apply(handler.context, [this]);
                }, this);
            }
            initialized = true;
        },

        _getContextPath : function () {
            var urlConfig = userConfig.serverUrlConfig || {},
                contextPath = urlConfig.contextPath || "";
            return contextPath;
        },

        /**
         * Returns the URL of the Formset
         * @returns {*}
         */
        getFormsetUrl: function () {
            try {
                return this._getFormLoader().getFormContainer().attr("data-formset-path");
            } catch (exception) {
                return null;
            }
        },

        /**
         * The private API validates the current Form. Never to be used.
         * @returns {boolean}
         * @private
         */
        _validateForm: function () {
            var formNumber = this._getFormList().getCurrentFormNumber();
            if (formNumber < formset.constants.FormNumberStart) {
                throw "validating an invalid form";
            }
            return currentFormBridge[activatedFunctionsMap.validateForm].apply(currentFormBridge, arguments);
        },

        /**
         * API to validate the current Form.
         * @returns undefined
         * @param options object which takes success and error handler. The signature of the function is
         * {
         *  success: function () {},
         *  error: function (FormsetResultObject) {},
         *  context: object to be used as this in success and error handlers
         * }
         */
        validateCurrentForm: function (options) {
            var _options = options || {},
                success = _options.success,
                error = _options.error,
                context = _options.context || window;
            this._validateForm({
                success: function () {
                    this._getFormList().setCurrentFormValidity(true);
                    if (success) {
                        var resultObj = new formset.lib.FormsetResultObject();
                        resultObj.setData(true);
                        success.apply(context, [resultObj]);
                    }
                },
                error: function (xfaResultObj) {
                    var msg = xfaResultObj.getNextMessage(),
                        resultObj;
                    this._getFormList().setCurrentFormValidity(false, msg.somExpression);
                    if (error) {
                        resultObj = new formset.lib.FormsetResultObject();
                        while (msg != null) {
                            resultObj.addMessage({
                                message: msg.message,
                                data: msg.somExpression
                            });
                            msg = xfaResultObj.getNextMessage();
                        }
                        resultObj.setData(false);
                        error.apply(context, [resultObj]);
                    }
                },
                context : this
            });
        },

        /**
         * Validates the Formset and returns true if and only if all the eligible forms are valid.
         * Algorithm is as follows
         * 1. Iterate over all the forms in the Formset and Find a form (other than current Form)
         *   which is eligible and is not in the FormsList (not rendered) or is invalid
         * 2. If a form is found in step 1 return fasle otherwise go to next step
         * 3. Validate the current Form and return the result of that.
         *
         * @return {FormsetResultObject} having the following properties
         * getData returns an object {valid: true/false, reason: currentFormInvalid/formsetIncomplete}.
         * getNextMesssage returns {message: <error message>, data: <Som Expression>/<invalidForm having invalidField property>}
         * data is null if the operation is unsuccessful
         */
        validateFormset: function () {
            this.updateCurrentXML();
            var result = new formset.lib.FormsetResultObject(),
                formsList = this._getFormList(),
                loader = this._getFormLoader(),
                currentFormNumber = formsList.getCurrentFormNumber(),
                invalidForm = _.find(formsetJson.formsInfo, function (form) {
                    var formNumber = form.formNumber;
                    return formNumber !== currentFormNumber && loader.isFormEligible(formNumber) &&
                        (formsList.isFormRendered(formNumber) === false || formsList.isFormValid(formNumber) === false);
                }),
                valid;
            try {
                this.validateCurrentForm({
                    error: function (formsetResultObj) {
                        valid = false;
                        var msg = formsetResultObj.getNextMessage();
                        while (msg != null) {
                            result.addMessage({
                                message: msg.message,
                                data: msg.data
                            });
                            msg = formsetResultObj.getNextMessage();
                        }
                        result.setData({
                            reason: "currentFormInvalid",
                            valid: false
                        });
                    }
                });
                if (valid === false) {
                    return result;
                }
            } catch (exception) {
                result.setErrorCode("unexpectedError");
                result.addMessage({
                    message: exception
                });
            }
            if (invalidForm != null) {
                var invalidField = this._getFormList().getInvalidField(invalidForm.formNumber),
                    invalidFormName = "\"" + this._getFormName(invalidForm.formNumber) + "\"";
                result.addMessage({
                    message : formset.locale.Strings.inCompleteFormset,
                    data : _.extend({"invalidField": invalidField, "invalidFormName": invalidFormName}, invalidForm)
                });
                result.setData({
                    reason: "formsetIncomplete",
                    valid: false
                });
                return result;
            }
            result.setData({
                valid: true
            });
            return result;
        },

        /**
         * Register a callback to be executed after the form has been rendered. It registers the handler on the underlying
         * form bridge (formBridge/guideBridge) connect API.
         * @param callback
         */
        _onFormRender: function (callback) {
            currentFormBridge.connect(callback);
        },

        /**
         * Returns the url of the profile to be used to render a Mobile Form
         * @returns {string} Url of the profile to render the code
         */
        getFormProfileUrl : function () {
            return this._getContextPath() + formRenderProfile;
        },

        getDataRef: function () {
            return this.renderContext.dataRef;
        },

        destroyForm: function () {
            var fn = currentFormBridge[activatedFunctionsMap.destroyForm];
            if (_.isFunction(fn)) {
                return fn.apply(currentFormBridge, arguments);
            }
        },

        _setFocusToField: function (somExpression) {
            var fn = currentFormBridge[activatedFunctionsMap.setFocus];
            if (_.isFunction(fn)) {
                return fn.apply(currentFormBridge, [somExpression]);
            }
        },

        /**
         * Set focus to a field in a formset. if formUid is not passed, current form is assumed
         * @param somExpression
         * @param formUid
         */
        setFocus: function (somExpression, formUid) {
            var formNumber
            console.log("CRX >>>><<<<<:"+somExpression);
            if (formUid !== undefined) {
                formNumber = this.getFormNumberByUid(formUid);
                if (formNumber !== formset.constants.InvalidFormNumber) {
                    if (formNumber === this.getCurrentFormNumber()) {
                        this._setFocusToField(somExpression);
                    } else {
                        this.getNavigator().showForm(formNumber, {
                            success: function () {
                                this._setFocusToField(somExpression);
                            },
                            context: this
                        });
                    }
                } else {
                    throw xfalib.ut.Logger.prototype.resolveMessage(formset.locale.Strings.invalidFormUid, [formUid]);
                }
            } else {
                this._setFocusToField(somExpression);
            }
        },

        /**
         * Creates a new Document using the prefill XML. Removes the draft information from the prefill xml if present.
         * If the prefill xml doesn't contain the formset wrapper, it adds that in the document.
         * If there is no prefill xml it returns the document containing only the formset and fs_data element
         * @returns {*}
         * @private
         */
        _createDocumentFromPrefillXml: function (prefillXml) {
            var xml = prefillXml,
                impl    = document.implementation,
                xmlDoc, tmpXmlDoc, tmpElement, draftElement;
            if (_.isString(xml) && xml) {
                xml = xfalib.ut.XMLUtils.removeDefaultNamespace(xml);
                xmlDoc = $.parseXML(xml);

                if (xmlDoc.documentElement.nodeName !== "formset") {
                    tmpXmlDoc  = impl.createDocument("", 'formset', null);
                    tmpElement = tmpXmlDoc.createElement("fs_data");
                    tmpXmlDoc.documentElement
                        .appendChild(tmpElement)
                        .appendChild(tmpXmlDoc.importNode(xmlDoc.documentElement, true));
                    xmlDoc = tmpXmlDoc;
                } else {
                    draftElement = xfalib.ut.XMLUtils.evaluateXPath("/formset/fs_draft", xmlDoc, null,
                        XPathResult.ORDERED_NODE_ITERATOR_TYPE, null).iterateNext();
                    if (draftElement != null) {
                        xmlDoc.documentElement.removeChild(draftElement);
                    }
                }
				

                return xmlDoc;
            }
            xmlDoc  = impl.createDocument("", 'formset', null);
            tmpElement = xmlDoc.createElement("fs_data");
            xmlDoc.documentElement
                .appendChild(tmpElement);
            return xmlDoc;
        },

        /**
         * Updates the current XML by calling the bridge to generate data xml.
         * Merges the existing xml with the xml of the current rendered form
         * It updates the currentXMLDocument object.
         * TODO: for non "/" xmlRoot, this doesn't work
         * @returns currentXMLDocument Object
         */
        updateCurrentXML: function () {
            if (!document.evaluate) {
                wgxpath.install();
            }
            var xml = currentXMLDocument,
                fn = currentFormBridge[activatedFunctionsMap.getXML],
                formNumber = this._getFormList().getCurrentFormNumber(),
                dataRoot = formsetJson.formsInfo[formNumber].xmlRoot,
                xmlUtils = xfalib.ut.XMLUtils,
                currentFormXml,
                tmpXmlDoc,
                tmpElement,
                strXML;
            if (xml != null) {
                // get the xml subtree of the current form
                xml = this.getXMLElementForForm(xml, formNumber);
                strXML = new XMLSerializer().serializeToString(currentXMLDocument);
            }


            if (_.isFunction(fn)) {
                // call the bridge to get the xml of the current form.
                currentFormXml = fn.apply(currentFormBridge, [xml, (dataRoot === "/" && currentXMLDocument == null)]);
                if (currentFormXml == null) {
                    if (window.console && _.isFunction(window.console.error)) {
                        window.console.error("Unable to get the data of the current form [" + formNumber + "]");
                    }
                    if (strXML) {
                        currentXMLDocument = $.parseXML(strXML);
                    }
                    return currentXMLDocument;
                }
                if (xml == null) {
                    // xml is being generated for the first time for the current form
                    // get the rootElement. Passing 0 as the form Number to get the root tree.
                    var rootElement = this.getXMLElementForForm(currentXMLDocument, 0);
                    tmpElement = this.getFirstElement(currentXMLDocument.documentElement,
                                            "fs_data", XPathResult.ANY_TYPE, null);
                    tmpXmlDoc = _.isString(currentFormXml) ? $.parseXML(currentFormXml) : currentFormXml;
                    if (rootElement === null) {
                        // xml is being generated for the first time for the formset
                        // so we need to generate the XDP Tags as well.
                        var elementToAppend;
                        if (dataRoot === "/") {
                            var formElementToInsert = tmpXmlDoc instanceof Element ? tmpXmlDoc
                                                                                   : tmpXmlDoc.documentElement;
                            elementToAppend = currentXMLDocument.importNode(formElementToInsert, true);
                        } else {
                            var xdpElement = currentXMLDocument.createElementNS('http://ns.adobe.com/xdp/', 'xdp:xdp'),
                                datasets = tmpXmlDoc.createElementNS("http://www.xfa.org/schema/xfa-data/1.0/",
                                                                    "xfa:datasets"),
                                data = tmpXmlDoc.createElement("xfa:data");
                            rootElement = currentXMLDocument.createElement("fs_dummy_root");
                            xdpElement.appendChild(datasets)
                                .appendChild(data)
                                .appendChild(rootElement);
                            elementToAppend = xdpElement;
                        }
                        if (tmpElement.firstElementChild != null) {
                            // case when the prefill data doesn't have the root element
                            tmpElement.replaceChild(elementToAppend, tmpElement.firstElementChild);
                        } else {
                            tmpElement.appendChild(elementToAppend);
                        }
                    }
                    if (dataRoot !== "/") {
                        var formElement = xfalib.ut.XMLUtils.getXFARootFormElementFromXML(tmpXmlDoc),
                            formElementChildren = xmlUtils.evaluateXPath("*", formElement, null,
                                                                XPathResult.ORDERED_NODE_ITERATOR_TYPE, null),
                            newFormElement = xmlUtils.createElementsFromXPath(dataRoot.replace(/^\//, ""), rootElement),
                            child = formElementChildren.iterateNext();
                        while (child != null) {
                            newFormElement.appendChild(currentXMLDocument.importNode(child, true));
                            child = formElementChildren.iterateNext();
                        }
                    }
                }
            }
            return currentXMLDocument;
        },

        getCurrentXMLDocument: function () {
            return currentXMLDocument;
        },

        /**
         * Evaluates the XPATH relative to the xmlElement object and returns the first element from the result.
         * The function assumes that document.evaluate API exists in the system
         * @param xmlElement
         * @param xPath
         * @param resultType
         * @returns {Node}
         */
        getFirstElement: function (xmlElement, xPath, resultType) {
            if(xmlElement == null) {
                return null;
            }
            var xPathResult = xfalib.ut.XMLUtils.evaluateXPath(xPath, xmlElement, null, resultType, null);
            if (xPathResult) {
                switch (xPathResult.resultType) {
                case XPathResult.FIRST_ORDERED_NODE_TYPE:
                    return xPathResult.singleNodeValue;
                default:
                    return xPathResult.iterateNext();
                }
            }
            return null;
        },

        /**
         * Returns the Subtree from the xml of the form with the Form Number as formNumber. It works with the XML from
         * Mobile Form as well.
         * @param xml the xml from which the subtree has to be returned
         * @param formNumber Form Number of the form for which the subtree is required
         * @returns {Node}
         */
        getXMLElementForForm: function (xml, formNumber) {
            if (xml == null) {
                return null;
            }
            if (!document.evaluate) {
                wgxpath.install();
            }
            var xmlDocument = _.isString(xml) ? $.parseXML(xml) : xml,
                form = formsetJson.formsInfo[formNumber] || {},
                dataRoot = form.xmlRoot || '/',
                isElement  = xmlDocument instanceof Element,
                documentElement = isElement ? xmlDocument : xmlDocument.documentElement,
                documentElementName = documentElement.localName,
                fs_data = documentElementName === "formset" ? this.getFirstElement(xmlDocument,
                                                                        "formset/fs_data",
                                                                        XPathResult.FIRST_ORDERED_NODE_TYPE)
                                                                : null,
                fs_dataChild = fs_data === null ? documentElement : fs_data.firstElementChild,
                fsRootElement,
                rootElement,
                datasets,
                data;
            if (fs_dataChild === null) {
                return null;
            }
            if (fs_dataChild.localName === "xdp") {
                if (xfalib.ut.XfaUtil.prototype.isIE()) {
                    datasets = fs_dataChild.firstElementChild;
                    data = datasets.firstElementChild;
                    fsRootElement = data.firstElementChild;
                } else {
                    fsRootElement = this.getFirstElement(fs_dataChild, "*/*/*", XPathResult.FIRST_ORDERED_NODE_TYPE);
                }
            } else {
                fsRootElement = fs_dataChild;
            }
            if (dataRoot == "/") {
                //since we need to pass the fsRootElement.
                dataRoot = "";
            }
            rootElement = this.getFirstElement(fsRootElement, "." + dataRoot,  XPathResult.FIRST_ORDERED_NODE_TYPE);
            return rootElement;
        },


        /**
         * Merges the current Form with the current XML Document or prefill XML.
         * @param formNumber
         */
        playDataXML: function (formNumber) {
            var fn = currentFormBridge[activatedFunctionsMap.playDataXML],
                xml = currentXMLDocument;
            if (((xml instanceof Node) ||
                    (_.isString(xml) && xml.length)) &&
                    _.isFunction(fn)) {
                fn.apply(currentFormBridge, [
                    {
                        xmlDocument: this.getXMLElementForForm(xml, formNumber),
                        success: function () {
                            // Errors in the play data xml are ignored for now.
                            // Hence do not put any hard line on this success handler. It will not be called if there are
                            // errors and the form is rendered.
                        },
                        error: function (xfaResultObj) {
                            if (window.console && _.isFunction(window.console.error)) {
                                window.console.error("Unable to merge data xml into the form " + formNumber);
                                window.console.error(xfaResultObj.getNextMessage().message);
                            }
                        }
                    }
                ]);
            }
        },

        /**
         * Wrapper API to hide Submit and Save Buttons using the underlying form bridge API
         * @returns {boolean}
         */
        hideSaveSubmitButtons: function () {
            var fn = currentFormBridge[activatedFunctionsMap.hideSaveSubmitButtons];
            if (_.isFunction(fn)) {
                fn.apply(currentFormBridge);
                return true;
            }
            return false;
        },

        /**
         * Internal function to start the formset rendition with the first eligible form or if restoring from draft
         * current Form Number mentioned in the draft.
         * @private
         */
        _startFormset: function () {
            var success, error, context;
            if (started == false) {
                if (formsetDraft != null && formsetDraft.renderContext != null) {
                    formsetJson.renderContext = formsetDraft.renderContext;
                    success = formsetDraft.successHandler;
                    error = formsetDraft.errorHandler;
                    context = formsetDraft.context;
                }
                playFormset({
                    renderContext: formsetJson.renderContext,
                    success: success,
                    error: error,
                    context: context
                });
                started = true;
            }
        },

        /**
         * Returns renderContext containing information regarding the current formset instance. For optimization pass
         * the parameters accordingly
         * @param withClientXml {boolean} default is true
         * @returns {*}
         */
        getRenderContext: function (withClientXml) {
            var renderContext = _.extend({}, formsetJson.renderContext, this._getFormList().getFormsListData());
            renderContext.formsetUrl = this.getFormsetUrl();
            if (withClientXml !== false) {
                renderContext._clientXml = new XMLSerializer().serializeToString(this.updateCurrentXML());
            }
            return renderContext;
        },

        _postExternalMessage: function () {
            currentFormBridge && currentFormBridge._postExternalMessage.apply(currentFormBridge, arguments);
        }

    });

    /**
     * Function to play the formset with the formsetState provided as an argument.
     * @param options which contains the following keys
     *  formsetState
     *  success
     *  error
     *  context
     */
    var playFormset = function (options) {
        
        var _options = options || {},
            renderContext = _options.renderContext,
            prefillXml = renderContext._clientXml || renderContext.xml,
            success = _options.success,
            error = _options.error,
            context = _options.context,
            oldCurrentFormNumber = formsetBridge._getFormList().getCurrentFormNumber(),
            currentFormNumber = renderContext.currentFormNumber || formset.constants.FormNumberStart;
        formsetBridge._postExternalMessage({ name: "formsetstart"});
        try {
            if (!document.evaluate) {
                wgxpath.install();
            }
            currentXMLDocument = formsetBridge._createDocumentFromPrefillXml(prefillXml);
            if (oldCurrentFormNumber >= formset.constants.FormNumberStart &&
                    oldCurrentFormNumber !== formset.constants.InvalidFormNumber) {
                formsetBridge._getFormLoader().unloadForm(false);
            }
            formsetBridge._getFormList().restoreFormsList({
                currentFormNumber: renderContext.currentFormNumber,
                renderedFormsList: renderContext.renderedFormsList
            });
            formsetBridge.getNavigator().showForm(currentFormNumber, {
                success: function () {
                    if (success) {
                        success.apply(context);
                    }
                    //cleaning up memory
                    renderContext.renderedFormsList = undefined;
                    renderContext._clientXml = undefined;
                    renderContext.formsetUrl = undefined;
                    $(window).trigger("loadcomplete", [currentFormNumber]);
                },
                error : function () {

                }
            });
        } catch (exception) {
            if (error) {
                error.apply(context, [exception]);
            } else {
                throw exception;
            }
        }
    };

    window.formsetBridge = new FormsetBridge();
    try {
        var evnt = document.createEvent("CustomEvent");
        evnt.initCustomEvent("FormsetBridgeInitialized", true, true, {"formsetBridge": window.formsetBridge});
        window.dispatchEvent(evnt);
    } catch (exception) {
        // written for env rhino to execute(for server side validation)
        // todo: once env rhino implements CustomEvent and initCustomEvent remove this
        // this._guide.logger().log(exception);
    }

    var registerBridgeConfigurations = function(configuration) {
        if(_.isObject(configuration)) {
            _.each(configuration, function(configuration, configName) {
                currentFormBridge.registerConfig(configName, configuration);
            });
        }
    };

    /**
     * Method to initialize the Formset. It initializes the loader and calls all the handlers registered
     * using the connect method.
     * @param formsInfoList
     * @param formRenderProfileUrl
     */
    window.initializeFormset = function (formsInfoList, formRenderProfileUrl) {

        if(window.guideBridge) {
        // TODO : setup stuff here as well
        } else if(window.formBridge) {
            currentFormBridge = window.formBridge;
            activatedFunctionsMap = functionsMap.formBridge;
            registerBridgeConfigurations(bridgeConfiguration);
            bridgeConfiguration = null;
        }
        _.each(formsInfoList.formslist, function (form) {
            formsetJson.formsInfo[form.formNumber] = form;
        });
        formsetJson.renderContext = formsInfoList.renderContext;
        formRenderProfile = formRenderProfileUrl;
        formsetBridge._getFormLoader().initialize();
        formsetBridge.initialized();
        formsetBridge._postExternalMessage({ name: "formsetinit"});
    };

}(jQuery, _));
/*******************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by all applicable intellectual property
 * laws, including trade secret and copyright laws.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 ******************************************************************************/

/**
 * FormLoader implements methods to unload a form and load the next form.
 */
(function ($, _, formset) {
    var $formcontainer,
        formsList = null,
        formsInfo = null,
        configScriptsExecuted = false,
        FormLoader = {

            /**
             * Unload the current Form, removing all the existing event listeners, data, html, etc.
             * @param bSave whether to save the current form or not. If true it will save the state of the current form,
             * otherwise it will just unload the form. Default value is true.
             */
            unloadForm: function (bSave) {
                $(document.activeElement).blur();
                bSave = typeof bSave !== "boolean" ? true : bSave;
                if (bSave) {
                    formsList.addDiffJson(formsetBridge.getCurrentFormstate().getData());
                    formsetBridge.updateCurrentXML(formsList.getCurrentFormNumber());
                }
                $(window).off("scroll.xfaview");
                $(window).off('resize.xfa');
                formsetBridge.destroyForm(); // Move other functionality there as well LC-9918
                $formcontainer.children().remove();
                formsList.resetFormNumber();
            },
            /**
             * This function has been copied from Mobile Forms to attach Scrolling event on the window to render next
             * page. LC-9922
             */
            attachScrollEvents: function () {
                $(window).on("scroll.xfaview", handleScroll);
                renderNextPage(true);
                var pagingManager = window.formBridge ? window.formBridge.pagingManager() : null;
                if (pagingManager) {
                    pagingManager.on("newPageRender",
                        function (event) {
                            handleFooterLogic();
                        });
                    pagingManager.autoRenderPage();
                    pagingManager.setAutoRenderPageHandler(handleScroll);
                }
            },

            /**
             * LC-3910984 : Also copied from MF, to set toolbar width on resize.
             * @private
             */
            _setToolbarWidth: function () {
                function _getToolbarWidth() {
                    var _tbwidth = document.body.clientWidth;
                    if (window.formBridge && window.formBridge.userConfig["viewportWidth"]) {
                        _tbwidth = window.formBridge.userConfig["viewportWidth"];
                    }
                    $(".page").each(function () {
                        var tmpWidth = parseInt($(this).width());
                        if (tmpWidth > _tbwidth)
                            _tbwidth = tmpWidth;
                    });
                    return _tbwidth - 2;
                }

                var extent = {};
                extent.width = _getToolbarWidth();
                $(".toolbarheader").css(extent);
                $(".pagingfooter").css(extent);
                $(".toolbarheader").css("left", "0px");
                $(".toolbarheader").css("right", "0px");
            },

            /**
             * LC-3910984 : Remove Fixes for MF somehow from here and move them back to Mobile Form
             * @private
             */
            _fixMF: function () {
                var self = this;
                self.attachScrollEvents();
                //Bug#3605558: iPad doesn't give the width values instantaneously, hence putting a time out since we need
                // width of the pages rendered.
                var timeout = setTimeout(function () {
                    if (!xfalib.runtime.xfa) {
                        //Bug#3670373: In IE, doc.ready is called too early for some forms, so xfalib.runtime.xfa is
                        // undefined
                        $(window).one('xfaFirstPgLayoutComplete', function () {
                            self._setToolbarWidth();
                        });
                    } else {
                        self._setToolbarWidth();
                    }
                    $(window).on('resize.xfa', function () {
                        self._setToolbarWidth();
                    });
                }, 100);
                xfalib.ut.XfaUtil.prototype.clearTimeoutOnDestroy(timeout);
            },

            _startRenderingForm: function(formNumber, formData, prefillJson, successCallback, context) {
                formsetBridge._postExternalMessage({ name: "formprefilljsonloaded"});
                if(prefillJson != null) {
                    formsetBridge._restoreFormstate(prefillJson);
                }
                formsetBridge.playDataXML(formNumber);

				// Workaourd to set up a time out to make the spenning wheel works.
                var self = this;
                setTimeout(function() {


                    if(configScriptsExecuted === false) {
                        var configScripts = $(formData).filter("script#configscript");
                        if(configScripts.length > 0) {
                            configScripts.appendTo($formcontainer);
                            configScriptsExecuted = true;
                        }
                    }
 				 	$("#formLoadingDiv", $(formData)).appendTo($formcontainer);
                    $(formData).filter("script#formscript").appendTo($formcontainer);

                    formsetBridge._onFormRender(function () {
                        formsetBridge._postExternalMessage({ name: "forminitialized"});
                        formsetBridge.hideSaveSubmitButtons();
                        self._fixMF();
                        formsList.setFormNumber(formNumber);
                        if (successCallback) {
                            successCallback.apply(context, [formNumber]);
                        }
    
    
                    });
                }, 0);


            },

            /**
             * Load a form given its formNumber. This API uses the HTML of the Form to render the form. Executes the callback
             * function upon successful load. Object passed in context argument is used as the this object in the callback.
             * @param formNumber
             * @param options containing the success and error handler
             */
            loadForm: function (formNumber, options) {
                formsetBridge._postExternalMessage({ name: "formloadstart"});
                options = options || {};
                var formProvider = formsetBridge.getFormProvider(),
                    successCallback = options.success || null,
                    errorCallback = options.error || null,
                    context = options.context || formsetBridge,
                    errorFunction = function (errorCodeStr) {
                        return function (code, error) {
                            if (_.isFunction(errorCallback)) {
                                var resultObj = new formset.lib.FormsetResultObject();
                                resultObj.setErrorCode(errorCodeStr);
                                resultObj.addMessage({
                                    message: error,
                                    data: code
                                });
                                errorCallback.apply(context, [resultObj]);
                            }
                        };
                    };

                formProvider.getHTML(formNumber, {
                    context:this,
                    success: function (formData) {
                        formsetBridge._postExternalMessage({ name: "formhtmlloaded"});
                        formProvider.getPrefillJson(formNumber, {
                            context:this,
                            success: function (prefillJson) {
                                this._startRenderingForm(formNumber, formData, prefillJson, successCallback, context);
                            },
                            error: function (code, error) {
                                if(window.console && _.isFunction(window.console.warn)) {
                                    window.console.warn("data will not be merged for the form " + formNumber + " " + error);
                                }
                                this._startRenderingForm(formNumber, formData, null, successCallback, context);
                            }
                        });
                    },
                    error: errorFunction("invalidFormHtml")
                });
            },

            initialize: function () {
                $formcontainer = $("#formBody");
                formsList = formsetBridge._getFormList();
                formsInfo = formsetBridge._getFormSetJson().formsInfo;
                
            },

            /**
             * returns the Form Number of the next Eligible Form.
             */
            getNextEligibleForm: function () {
                formsetBridge.updateCurrentXML();
                var nextNumber = formsList.getCurrentFormNumber() + 1;
                while (formsInfo[nextNumber] != null) {
                    if (this.isFormEligible(nextNumber)) {
                        return nextNumber;
                    }
                    nextNumber += 1;
                }
                return formset.constants.InvalidFormNumber;
            },

            /**
             * returns the Form Number of the prev Eligible Form.
             */
            getPreviousEligibleForm: function () {
                formsetBridge.updateCurrentXML();
                var prevNumber = formsList.getCurrentFormNumber() - 1;
                while (prevNumber > 0 && formsInfo[prevNumber] != null) {
                    if (this.isFormEligible(prevNumber)) {
                        return prevNumber;
                    }
                    prevNumber -= 1;
                }
                return formset.constants.InvalidFormNumber;
            },

            getFormContainer: function () {
                return $formcontainer;
            },

            /**
             * Returns whether the form whose formNumber is provided is eligible or not.
             * @param formNumber {number} the formNumber which has to be checked for eligibility
             * @returns {boolean} true if the form is eligible otherwise false.
             */
            isFormEligible: function (formNumber) {
                if (formNumber === formset.constants.FormNumberStart) { return true; } // 1st form is always eligible
                var retVal = true;
                try {
                    var form = formsInfo[formNumber],
                        expression = form.compiledEligibilityExpression;
                    if (_.isString(expression) && expression.length > 0) {
                        retVal = !!eval("with(formset.runtime) {" + expression + "}");
                    }
                } catch (e) {
                    if (window.console && _.isFunction(window.console.error)) {
                        window.console.error('[FormSet] : Javascript Evaluation Error in "isFormEligible" : ' + expression , e);
                    }
                }
                return retVal;
            }
        };

    formset.runtime.FormLoader = FormLoader;
}(jQuery, _, formset));

/*******************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by all applicable intellectual property
 * laws, including trade secret and copyright laws.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 ******************************************************************************/

(function (_, formset) {

    /**
     * FormsList represents the List of Forms that have been rendered. The implementation has been done using
     * ArrayLinkedList
     * The advantage is fast access of Random, Next and Previous Forms.
     * @constructor
     */
    var validationStatus = [];
    var somExpressionList = [];
    var FormsList = function () {
            /**
             * an ordered array of formNumbers representing the form render history.
             * @type {Array}
             */
            this.formRenderOrder = [];

            /**
             * currentFormNumber points to the current Rendered Form.
             * @type {int}
             */
            this.currentFormNumber = formset.constants.InvalidFormNumber;

            /**
             * Returns whether a form is valid or not. Adding the API directly on the object so that nonone can
             * interfere with the private object validationStatus
             */
            this.isFormValid = function (formNumber) {
                return validationStatus[formNumber] || false;
            };

            /**
             * returns the somExpression of the field with validation errors in the form having the formNumber form
             * @param formNumber
             */
            this.getInvalidField = function (formNumber) {
                if (!this.isFormValid(formNumber)) {
                    return somExpressionList[formNumber];
                }
                return null;
            };

            /**
             * Sets the validity of the Current Rendered Form. Exposed here to make the validationStatus Field private
             * @param validity {boolean} indicating whether the current form is valid or not
             * @param somExpression {string} somExpression of the field which has validation error. In case validity is
             * false, passing somExpression is mandatory.
             */
            this.setCurrentFormValidity = function (validity, somExpression) {
                if (this.currentFormNumber != formset.constants.InvalidFormNumber) {
                    var formNumber = this.currentFormNumber;
                    validationStatus[formNumber] = validity;
                    if (validity === false) {
                        if (!_.isString(somExpression) && !somExpression.match(/^xfa\[0\]\.form\[0\]/)) {
                            throw "invalid field passed " + somExpression;
                        }
                        somExpressionList[formNumber] = somExpression;
                    }
                }
            };
        };

    _.extend(FormsList.prototype, {
        /**
         *
         * @param formNumber
         * @returns {boolean}
         */
        isFormRendered: function (formNumber) {
            return _.indexOf(this.formRenderOrder, formNumber) >= 0;
        },

        /**
         * update the form render order list.
         * remove the current form from the list if present then append at end.
         * this func. can be called only if the currentFormNumber is Invalid (i.e. form had been unloaded)
         * @param formNumber
         * @returns {*}
         */
        setFormNumber: function (formNumber) {
            if (formNumber < formset.constants.FormNumberStart ||
                formNumber == formset.constants.InvalidFormNumber ||
                this.currentFormNumber !== formset.constants.InvalidFormNumber) {
                return;
            }
            this.currentFormNumber = formNumber;
            this.formRenderOrder = _.without(this.formRenderOrder, formNumber);
            this.formRenderOrder.push(formNumber);
        },

        /**
         * Add a Diff JSON in the Form List for the current Rendered Form
         * @param diffJson
         * @returns {*}
         */
        addDiffJson: function (diffJson) {
            if (this.currentFormNumber != formset.constants.InvalidFormNumber) {
                formsetBridge.getFormProvider().savePrefillJson({
                    formNumber: this.currentFormNumber,
                    prefillJson: diffJson
                });
            }
        },

        /**
         * Return the form number of the current Rendered Form
         * @returns {*}
         */
        getCurrentFormNumber: function () {
            return this.currentFormNumber;
        },

        getLastFormNumber: function() {
            return _.keys(formsetBridge._getFormSetJson().formsInfo).length || formset.constants.InvalidFormNumber;
        },

        /**
         *
         * @returns {{currentFormNumber: *, renderedFormsList: Array}}
         */
        getFormsListData: function () {
            var formsetList = {
                currentFormNumber: this.currentFormNumber,
                renderedFormsList: []
            };
            // LC-3912278 LC-3913983 : must process forms in render order, including 'pre-rendered' forms present in fs_draft/fs_list
            _.each(this.formRenderOrder, function (formNumber) {
                var validity = this.isFormValid(formNumber),
                    form = {
                        formNumber: formNumber,
                        validationStatus: validity
                    };
                // for currentForm do not put the invalidField, since we do not execute the validations of
                // the currentForm
                if (validity === false && formNumber !== this.currentFormNumber) {
                    form.invalidField = this.getInvalidField(formNumber);
                }
                formsetList.renderedFormsList.push(form);
            }, this);
            return formsetList;
        },

        /**
         * Restores the forms List with the data provided. This input data should match exactly with the one returned by
         * getFormsListData
         * @param formsListData
         */
        restoreFormsList: function (formsListData) {
            if (formsListData == null) {
                return;
            }
            var currentFormNumber = formsListData.currentFormNumber,
                formsList = formsListData.renderedFormsList;

            this.currentFormNumber = formset.constants.InvalidFormNumber;

            _.each(formsList, function (form) {
                var formNumber = +form.formNumber;
                this.formRenderOrder.push(formNumber);  // LC-3914244 : must consider forms present in fs_draft/fs_list as 'pre-rendered'
                validationStatus[formNumber] = form.validationStatus || false;
                if (form.validationStatus === false) {
                    //an invalid form must have invalidField except for the case when it is the currentForm
                    //We also ignore this error if currentForm is not defined
                    if (form.invalidField == null && currentFormNumber != null && currentFormNumber !== formNumber) {
                        throw "Restoring with invalid XML. Missing invalid Field data";
                    }
                    somExpressionList[formNumber] = form.invalidField;
                }
            }, this);
        },

        resetFormNumber: function () {
            this.currentFormNumber = formset.constants.InvalidFormNumber;
        }

    });
    formset.lib.FormsList = FormsList;
    formset.runtime.formsList = new FormsList();
}(_, formset));

/*******************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by all applicable intellectual property
 * laws, including trade secret and copyright laws.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 ******************************************************************************/


(function ($, formset) {
    /**
     * Object to store all the navigators
     * @type {null}
     */
    var element;
    var navigators = {
        /**
         * Represents the jQuery object for all the Navigators
         */
        dom: null,
        /**
         * Array of objects, where each object holds the submit, next and previous button DOM.
         */
        elem: []
    },
        isSwipeEnabled = false,  // disabling swipe action for now
        isSwipeUnregistered = true;

    /**
     * Form Navigator object provides APIs to render the next and previous form
     * @type {{showNextForm: showNextForm, showPreviousForm: showPreviousForm}}
     */
    var FormNavigator = {

        /**
         * API to show the Next Form
         * @param options object containing error and success handlers and the context  object
         * {
         *   failOnValidation: true/false. Default Value is true. This will indicate whether to fail On ValidationErrors
         *                     or not
         *   skipValidations: true/false. Default Value is false. This will skip the validations altogether. If it is
         *                    passed as true, failOnValidations flag will be ignored. If this flag has been passed as
         *                    true, then we are making an assumption that somebody else is validating the form. If this
         *                    is passed as true without validating the form, then validateFormset will always return
         *                    false.
         *   success: function (formNumber) {},
         *   error : function (errorType, data) {
         *      errorType: validationsFailed/noMoreForms
         *      data: Som Expression/ undefined
         *   },
         *   context: {} // this object to be used in success and error handlers
         *   }
         */
        showNextForm: function (options) {

            var formNumber = this.getNextFormNumber();
            // FINESJO 20160617: Ommit forms for participants
            var lastNumber = formsetBridge._getFormList().getLastFormNumber();
            var sFormName = formsetBridge._getFormName(formNumber);
            while(sFormName.indexOf("-Participant") >= 0){
                formNumber++;
                var sFormName = formsetBridge._getFormName(formNumber);
                if(formNumber == lastNumber){
                    break;
                }
            }
            this._validateAndShowForm(formNumber, options);
        },

        _validateAndShowForm: function (formNumber, options) {
            var currFormNumber = formsetBridge._getFormList().getCurrentFormNumber(),
                _options = options || {},
                skipValidations = !!_options.skipValidations,
                failOnValidations = _options.failOnValidations !== false,
                error = _options.error,
                retVal,
                validationFailed = function (formsetResultObj) {
                    var firstValidationMessage = formsetResultObj.getNextMessage(),
                        som = firstValidationMessage.data || null,
                        resultObj = new formset.lib.FormsetResultObject();
                    if (error) {
                        resultObj.setErrorCode("validationsFailed");
                        resultObj.addMessage({
                            message: firstValidationMessage.message,
                            data: som
                        });
                        retVal = error.apply(_options.context, [resultObj]);
                    }
                    if (formNumber !== formset.constants.InvalidFormNumber && (failOnValidations === false || retVal === true)) {
                        this.showForm(formNumber, _options);
                    }
                },
                noValidationRequired = function () {
                    if (formNumber !== formset.constants.InvalidFormNumber) {
                        this.showForm(formNumber, _options);
                    } else {
                        if (error) {
                            var resultObj = new formset.lib.FormsetResultObject();
                            resultObj.setErrorCode("noMoreForms");
                            resultObj.addMessage({
                                message: formset.locale.Strings.noMoreFormsToFill
                            });
                            error.apply(_options.context, [resultObj]);
                        }
                    }
                },
                validationPassed = function () {
                    noValidationRequired.apply(this);
                };

            // the check is to make sure we do not call validate API
            // when this API is called for the first time
            if (currFormNumber >= formset.constants.FormNumberStart && skipValidations === false) {
                formsetBridge.validateCurrentForm({
                    success: validationPassed,
                    error: validationFailed,
                    context: this
                });
            } else {
                noValidationRequired.apply(this);
            }
        },

        /**
         * API to show the Previous Form
         * @param options object containing error and success handlers and the context  object
         * { success: function () {},
         *   error : function () {},
         *   context: {} // this object to be used in success and error handlers
         *   }
         */
        showPreviousForm: function (options) {
            var formNumber = this.getPreviousFormNumber(),
                currFormNumber = formsetBridge._getFormList().getCurrentFormNumber();
            if (currFormNumber < formset.constants.FormNumberStart) {
                return;
            }
            formsetBridge.validateCurrentForm();
            // FINESJO 20160617: Ommit forms for participants
            var firstNumber = formset.constants.FormNumberStart;
            var sFormName = formsetBridge._getFormName(formNumber);
            while(sFormName.indexOf("-Participant") >= 0){
                formNumber--;
                var sFormName = formsetBridge._getFormName(formNumber);
                if(formNumber == firstNumber){
                    break;
                }
            }
            if (formNumber != formset.constants.InvalidFormNumber && formNumber >= formset.constants.FormNumberStart) {
                this.showForm(formNumber, options);
            }
        },

        /**
         * Handler to be called after a successful form load. This functions manages the buttons in the navigator.
         * Toggles the disabled class on the next button on last form, previous button on first form
         * on last form
         * @private
         */

        _onFormLoad: function () {
			// Please wait progress message
			    var previousFormNumber = this.getPreviousFormNumber(),
                currentFormNumber = formsetBridge._getFormList().getCurrentFormNumber(),
                formName = formsetBridge._getFormName(currentFormNumber),
                showNextButton = currentFormNumber !== formsetBridge._getFormList().getLastFormNumber(),
                showPreviousButton = true,
                displayFormName = formName;

            if (previousFormNumber < formset.constants.FormNumberStart ||
                previousFormNumber == formset.constants.InvalidFormNumber) {
                showPreviousButton = false;
            }

            // Get the participant names
            var parser = new DOMParser();
            var xmlDoc = parser.parseFromString(formListXml.renderContext.xml,"text/xml");
            //console.log("xmlDoc " + xmlDoc);
            var arParticipants = xmlDoc.getElementsByTagName("Participants")[0].getElementsByTagName("LegalName");
            //console.log("participants " + arParticipants.length);

             console.log("XML parsed. Participants: " + arParticipants.length);
                for(var i = 0; i < arParticipants.length; i++){
                   console.log("Participant " + i + ": " + arParticipants[i].childNodes[0].nodeValue);
             }



            // FINESJO 20160617: Detect ListOfParticipant
            if(formName.indexOf("ListOfParticipant") > 0){
               // console.log("_onFormLoad: ListOfParticipant detected");
                displayFormName = "List of participants";
            }else if(formName.indexOf("-Participant") >= 0){
                var arNameParts = formName.split("_");
                if(arNameParts.length > 0){
                    var iNum = parseInt(arNameParts[arNameParts.length - 1], 10);
                    if(!isNaN(iNum)){
                        // First participant is stored in position 0 of the array
                        displayFormName = arParticipants[iNum - 1].childNodes[0].nodeValue;
                    }
                }
            }

            //console.log("Last Form Number: " + formsetBridge._getFormList().getLastFormNumber());
            _.each(navigators.elem, function (elem) {
                element = elem;
               // elem.next.prop("disabled", !showNextButton);
              //  elem.prev.prop("disabled", !showPreviousButton);
                elem.jump.html('');
                elem.jump.append($("<option />").attr("value", currentFormNumber).text(displayFormName));
                elem.jump.val(currentFormNumber);

                // JP: Populate the autojump data list
                var lookup = {};
                elem.autojumpData.html('');
                var formList = formsetBridge.getAllEligibleForms();
                _.each(formList, function(formNumber) {

                	var name = formsetBridge.getFormName(formNumber);
                   console.log("form number: " + formNumber + ", name: " + name);
                    if (name.indexOf("-Participant") >= 0)
                    {
                		var arNameParts = name.split("_");
                		if(arNameParts.length > 0)
                        {
                    		var iNum = parseInt(arNameParts[arNameParts.length - 1], 10);

                    		if(!isNaN(iNum) && iNum <= arParticipants.length) // Make sure the number is ok and not the wrong number of participants
                            {
                                //console.log("childNode count = " + arParticipants[iNum - 1].childNodes.length);
                        		// First participant is stored in position 0 of the array
                        		var displayFormName;
								if (arParticipants[iNum - 1].childNodes.length == 0)
                                {
                                    // If the text of the participant legal name is empty, put sa placeholder in
									displayFormName = "Participant " + iNum;
                                }
                                else
                                {
									 displayFormName = iNum +"  " + arParticipants[iNum - 1].childNodes[0].nodeValue;
                                   //   displayFormName = arParticipants[iNum - 1].childNodes[0].nodeValue;
                                }


                                elem.autojumpData.append($("<option />").attr("value", displayFormName)) ;
                               lookup[displayFormName] = formNumber;




                            }
                    	}
                	}
                    else if (name.indexOf("-ListOfParticipant") > 0)
                    {
                        // TODO: Something to make it translatable into other languages
                        var displayFormName = "List of participants";
						elem.autojumpData.append($("<option />").attr("value", displayFormName));
                        // lookup[displayFormName] = formNumber;
                    }

                });
                elem.autojumpInput.participantLookup = lookup;


                // If this is not a participant (participant or ListOfParticipant) form, hide the jump dropdown
                var currentFormName = formsetBridge._getFormName(currentFormNumber);
                if(currentFormName.indexOf("Participant") < 0){
                    elem.jump.hide();
                    elem.autojumpInput.hide();
                    elem.textSelect.hide();
                    elem.current.show();


                }else{
                    //elem.jump.show(); // Uncomment to show the original select control
                     elem.autojumpInput.show();
                     elem.textSelect.show();
                     elem.current.hide();
                }
               // console.log("_onFormLoad: " + currentFormNumber + " * " + formName);
                var previousFormName = "Exit form";
                var nextFormName = "Exit form";
                if(showPreviousButton){
					//previousFormName = formsetBridge._getFormName(currentFormNumber - 1);
                    //Search of non participant section
                    for(var i = currentFormNumber - 1; i > 0; i--){
						previousFormName = formsetBridge._getFormName(i);
                        if(previousFormName.indexOf("-Participant") < 0){
                            break;
                        }
                    }
                    var  arrayPrevName = previousFormName.split("-");
					previousFormName = arrayPrevName[arrayPrevName.length -1].replace(new RegExp("_", "g"), " ");
				}
                if(showNextButton){
					//nextFormName = formsetBridge._getFormName(currentFormNumber + 1);
                    for(var i = currentFormNumber + 1; i <= formsetBridge._getFormList().getLastFormNumber(); i++){
						nextFormName = formsetBridge._getFormName(i);
                        if(nextFormName.indexOf("-Participant") < 0){
                            break;
                        }
                    }
                    var  arrayNextName = nextFormName.split("-");
                    nextFormName =arrayNextName[arrayNextName.length -1].replace(new RegExp("_", "g"), " ");
                }
                //elem.prev.html(previousFormName);
                //elem.next.html(nextFormName);
                var elemPrev = document.getElementById("previousSection");
            	var elemNext = document.getElementById("nextSection");
                var elemCurrent = document.getElementById("currentSection");



               //ANDREA: Improvement the GeneralInfo and ListOfParticipant names and numbering the  'pre' and 'next' section

                var logicalPageTotal = 0;
                var totalFormsetParticipantContainers = 0;
                var nParticipants = arParticipants.length;
                var iFormName = 0;
				var checkBudgetPresence = false;

				//Calculate the effective total number used of participants
               // console.log("header getLastFormNumber:"+formsetBridge._getFormList().getLastFormNumber());
                for(var i = 1; i <= formsetBridge._getFormList().getLastFormNumber(); i++){

					iFormName = formsetBridge._getFormName(i);
                    // console.log("header _getFormName:"+iFormName);

                     if( iFormName.indexOf("GeneralInfo") > 0 ||
                         iFormName.indexOf("ListOfParticipant") > 0 ||
                         iFormName.indexOf("Budget") > 0 ||
                         iFormName.indexOf("Ethics") > 0 ||
                         iFormName.indexOf("Questionnaire") > 0 ){

                             logicalPageTotal++;
                         }

  					if(iFormName.indexOf("-Participant") >= 0){
							totalFormsetParticipantContainers++

                    }
					if( iFormName.indexOf("Budget") > 0 ){ 
						checkBudgetPresence = true;
					}
                    if( iFormName.indexOf("Ethics") > 0 ){
						checkEthicsPresence = true;
                    }
                    if( iFormName.indexOf("Questionnaire") > 0){
						checkQuestPresence = true;
                    }

                }



				var totalFormSetPages = logicalPageTotal + nParticipants;
                var emptyParticipantContainers = totalFormsetParticipantContainers - nParticipants;
                var prevNumber = formsetBridge._getFormLoader().getPreviousEligibleForm() -1;
                var nextNumber = formsetBridge._getFormLoader().getNextEligibleForm() -1;   // Improvement needed to jump the participants.


				//console.log("nextNumber before ptch for common participants" + nextNumber);

                //Patch for common participant nodes (+200 extra counting)

                var checkIfCommonParticipantCase = false;
                if(prevNumber > 200 ) prevNumber = 200 - prevNumber;
                if(nextNumber > 200 ) {
                    nextNumber = 200 - nextNumber;
                     checkIfCommonParticipantCase = true;


                  //console.log("checkIfCommonParticipantCase : " + checkIfCommonParticipantCase);
                }



                                                                // and patch  (+200 extra counting)


 				 //console.log("logicalPageTotal: " + logicalPageTotal);
                // console.log("nParticipants: " + nParticipants);
              	//console.log("totalFormSetPages: " + totalFormSetPages);
              	//console.log("prevNumber: " + prevNumber);
                //console.log("nextNumber: " + nextNumber);
              	 //console.log("totalFormsetParticipantContainers: " + totalFormsetParticipantContainers);
                // console.log("emptyParticipantContainers: " + emptyParticipantContainers);


                var finalTextPrev = "";
                var finalTextNext = "";
                var finalTextCurrent = "";


    			// PREV SCENARIO

                //The list of participant will be always at the third position plus the value of the first after the last participant
 				if(previousFormName.indexOf("Participant") > 0 &&  currentFormName.indexOf("-Participant") < 0){
                    prevNumber = 2;

                }

                if(currentFormName.indexOf("-ListOfParticipant") > 0){
                    prevNumber = 1;

                }



                 if(currentFormName.indexOf("-Participant") >= 0){
                    prevNumber = 2;


                }



                if (previousFormName.indexOf("Exit form") >= 0) {
                   finalTextPrev = "Exit form";
                }
                else{

					if( currentFormName.indexOf("Ethics")  >= 0 || currentFormName.indexOf("Questionnaire") >= 0 ){

						 //console.log("emptyParticipantContainers: " + emptyParticipantContainers);
               			 //console.log("nParticipants: " + nParticipants);
                      	 //console.log("prevNumber: " + prevNumber);


                        //If buget page exists execute this following line of code.
                        if(checkBudgetPresence){
                              if(totalFormsetParticipantContainers == 200 ){

                             		//prevNumber = Math.abs((-1) * - prevNumber);

                        		 }else{
									//prevNumber = Math.abs((emptyParticipantContainers + nParticipants) - prevNumber);
                                 }

                        }

                      //  if(!checkBudgetPresence && (totalFormsetParticipantContainers == 3  
                      //     || totalFormsetParticipantContainers == 1)) prevNumber = prevNumber + 1;
                      //  if(!checkBudgetPresence && totalFormsetParticipantContainers == 2 ) prevNumber = prevNumber + 2;


                         //finalTextPrev =  prevNumber + " - " +  previousFormName;
                        finalTextPrev = previousFormName;

                    }else if(currentFormName.indexOf("Validation") >=0 ){
                       //console.log("PREV SCENARIO prevNumber: " + prevNumber+",emptyParticipantContainers:"+emptyParticipantContainers+",nParticipants"+nParticipants);
                        /*If there is not Budget,Ethics and Questionnaire pages before validation
                          the participants list exists with prevNumber always to be 2 */
                        if(prevNumber != 2){
                           //  prevNumber = Math.abs((emptyParticipantContainers + nParticipants) - prevNumber);
                            //console.log("PREV SCENARIO prevNumber: " + prevNumber);
                            //if(!checkBudgetPresence) prevNumber = prevNumber + 1;
                        }

						//finalTextPrev =  prevNumber + " - " +  previousFormName;
						finalTextPrev =   previousFormName;
                    }else{

					   // finalTextPrev =  prevNumber + " - " +  previousFormName;
                        finalTextPrev =  previousFormName;
                   }


                 }

				  //console.log("PREV SCENARIO previousFormName: " + previousFormName+",currentFormName:"+currentFormName+",prevNumber:"+prevNumber+"finalTextPrev"+finalTextPrev);

                //NEXT SCENARIO
				// Jump the participants.

               if(currentFormName.indexOf("ListOfParticipant") > 0 || currentFormName.indexOf("-Participant") > 0){
                   nextNumber = 3;
               }


                 if(currentFormName.indexOf("-Participant") >= 0){
                    nextNumber = 3;


                }


                if (nextFormName.indexOf("Exit form") >= 0) {
                    finalTextNext = "Exit form";
                }
                else{

                   if(currentFormName.indexOf("Budget")  >= 0 || currentFormName.indexOf("Ethics")  >= 0 || currentFormName.indexOf("Questionnaire") >= 0 ){

                         if(totalFormsetParticipantContainers == 200 ){

                             // nextNumber = Math.abs((-1) * - nextNumber);

                         }else{

                        	  //nextNumber = Math.abs((emptyParticipantContainers + nParticipants) - nextNumber);
						}

                       //console.log("nextNumber BEFORE FIX : " + nextNumber);



						 //finalTextNext = nextNumber  + " - " + nextFormName;
                       finalTextNext =  nextFormName;

                   }else{

					    // finalTextNext = nextNumber + " - " + nextFormName;
                       finalTextNext = nextFormName;
                   }


                }


                if(previousFormName.indexOf("Cover") >= 0 ){  finalTextPrev = "Table of contents";  }

                if( nextFormName.indexOf("Validation") >=0 ) {finalTextNext = "Validation result"; }


				// Replace the string with spaces
				 finalTextPrev = finalTextPrev.replace("GeneralInfo", " General Information");
                 finalTextPrev = finalTextPrev.replace("ListOfParticipant", "Participants & contacts");

                 finalTextNext = finalTextNext.replace("GeneralInfo", " General Information");
                 finalTextNext = finalTextNext.replace("ListOfParticipant", "Participants & contacts");


				 finalTextNext = finalTextNext.replace("Questionnaire", "Call-specific questions");
                 finalTextPrev = finalTextPrev.replace("Questionnaire", "Call-specific questions");


                 // if the template is HEUROPA, then instead of Ethics, use Ethics & Security in next/previous text
				//Ashish Start

				if (currentFormName.includes("HEUROPA")) {
                    finalTextNext = finalTextNext.replace("Ethics", "Ethics & Security");
                 	finalTextPrev = finalTextPrev.replace("Ethics", "Ethics & Security");
                }

                //Ashish End

                // Clean current Form Name
				var  arrayCurrentName = currentFormName.split("-");
				currentFormName = arrayCurrentName[arrayCurrentName.length -1].replace(new RegExp("_", "g"), " ");


                if(currentFormName.indexOf("Validation") < 0 && currentFormName.indexOf("Cover") < 0){

					 // currentFormName = Math.abs(prevNumber + 1) + " - " + currentFormName.replace("GeneralInfo", " General Information");
                    currentFormName = currentFormName.replace("GeneralInfo", " General Information");
                }


                finalTextCurrent = currentFormName.replace("Questionnaire", "Call-specific questions");
				finalTextCurrent = currentFormName.replace("Questionnaire", "Call-specific questions");

                //Sid's code - Other Questions for New MFF

                var fieldNewMFF = formBridge._xfa.resolveNode("xfa.form.Proposal._sepControl.NewMFF");

				if (fieldNewMFF!=null) {

    				var valueNewMFF = formBridge.getFieldValue("xfa.form.Proposal._sepControl.NewMFF").data;

    				if (valueNewMFF == "true") {
        				finalTextCurrent = currentFormName.replace("Questionnaire", "Other questions");
        				finalTextCurrent = currentFormName.replace("Questionnaire", "Other questions");

                        finalTextNext = finalTextNext.replace("Call-specific questions", "Other questions");
                 		finalTextPrev = finalTextPrev.replace("Call-specific questions", "Other questions");
    				}
				}

                //End of Sid's code

                if(currentFormName.indexOf("Validation") >= 0 ){
					   finalTextCurrent = currentFormName.replace("Validation", "Validation result");
                	}
				if(currentFormName.indexOf("Cover") >= 0 ){
                		finalTextCurrent = currentFormName.replace("Cover", "Table of contents");
                    }

                 //eUI add > simbol
			  	//eUI adding <
				finalTextPrev = "< " + finalTextPrev;
                finalTextNext = finalTextNext + " >"; 

   			  // console.log("finalTextPrev " + finalTextPrev + " finalTextNext " + finalTextNext);
				// Final assignement

				 elemCurrent.innerHTML = finalTextCurrent;
                 elemPrev.innerHTML = finalTextPrev;
                 elemNext.innerHTML = finalTextNext;


              // End Andrea's CODE.
				//Ashish - start
                	$(document).ready(function () {
                        if ($("[name*='txtSecurityIssuesTable']").length){
                                     //console.log("CRX length"+ $("[name*='txtSecurityIssuesTable']").length)
										$('#currentSection').html('Ethics & Security');
                                 }

                        });



					// Below function update the text dynamically when scrolling thorugh Security section
					/*
                         $(document).ready(function () {        
                             $(window).scroll(function () {

                                    var p = $("[name*='txtSecurityIssuesTable']").last();
                                    var offset = p.offset();
                                    //console.log( "CRX ashish left: " + offset.left + ", top: " + offset.top );
                                    //console.log( "CRX ashish scrolltop: " + $(this).scrollTop());

                                    if ($(this).scrollTop() > offset.top-600) { 
                                        //change 4 - Ethics to 4 - Security
                                        $('#currentSection').html('4 - Security');
                                    } else {
                                        //change 4 - Security to 4 - Ethics
                                       $('#currentSection').html('4 - Ethics');
                                    }
                              });
                        });
					*/            

				//Ashish - end

            });
        },
        /**
         * API to show a Form having the Form Number/Form Uid as formNumber
         * @param options object containing error and success handlers and the context  object
         * {
         *   success: function (formsetResultObj) {
         *       formsetResultObj.getData returns the object {
         *          formNumber: <form number being shown>,
         *          formId: <form ID being shown>
         *        }
         *   },
         *   error : function () {},
         *   context: {} // this object to be used in success and error handlers
         * }
         */
        showForm: function (formNumber, options) {

            var isUid = _.isString(formNumber),
                _formNumber = isUid ? formsetBridge.getFormNumberByUid(formNumber) : formNumber,
                loader = formsetBridge._getFormLoader(),
                currentFormNumber = formsetBridge._getFormList().getCurrentFormNumber(),
                _options = options || {},
                context = _options.context || window,
                success =  _options.success,
                error = _options.error;

            if (currentFormNumber >= formset.constants.FormNumberStart) {
                loader.unloadForm();
            }
            if (_formNumber >= formset.constants.FormNumberStart && _formNumber !== formset.constants.InvalidFormNumber) {
                xfalib.globals.highlight = false; // reset highlight levels on form load, to prevent an extra click

                loader.loadForm(_formNumber, {
                    success: function () {
                        this._onFormLoad();
                        if (success) {
                            var resultObj = new formset.lib.FormsetResultObject();
                            resultObj.setData({
                                formNumber: _formNumber,
                                formId: formsetBridge._getForm(_formNumber).uid
                            });
                            success.apply(context, [resultObj]);
                        }
                        formsetBridge._postExternalMessage({ name: "formrendered"});
                    },
                    error: function (result) {
                        if (error) {
                            error.apply(context, [result]);
                        }
                    },
                    context: this
                });
            } else {
                var resultObj = new formset.lib.FormsetResultObject();
                resultObj.addMessage({
                    message: (isUid ? "Invalid Form Uid passed " : " Invalid Form Number passed "),
                    data: formNumber
                });
                resultObj.setErrorCode("invalidFormID")
                if (error) {
                    error.apply(context, [resultObj]);
                }
            }
        },

        /**
         * API to return the next Form Number. Returns InvalidFormNumber constant if there is no next form
         * @returns {*}
         */
        getNextFormNumber: function () {
            return formsetBridge._getFormLoader().getNextEligibleForm();
        },

        /**
         * API to return the Previous Form Number
         * @returns {*}
         */
        getPreviousFormNumber: function () {
            return formsetBridge._getFormLoader().getPreviousEligibleForm();
        },

        /**
         * API to hide the navigators in the Formset Profile
         */
        hideNavigator: function () {
            if (navigators !== null) {
                navigators.dom.hide();
            }
        },

        /**
         * API to disable swipe left/right actions in formbody.
         */
        disableSwipe: function () {
            $("#formBody").off("swipeleft swiperight");
            isSwipeEnabled = false;
        }
    };

    /**
     * Adding a FormNavigator jQuery plugin which exposes data-APIs that the designer can use to add next or previous
     * functionality in their html markup. The Assumption is that FormNavigator will have descendants with these
     * data-APIs.
     *
     * data-formset-navigate : next/prev/<valid number>
     * options:
     *
     * onFormShow: function (type,  formsetResultObj) {
     *  type: prev/next/random
     *  formsetResultObj.getData() returns the formnumber of the form.
     * }
     *
     * onError: function (type, formsetResultObj) {
     *   type: prev/next/random/submit
     *   formsetResultObj.getErrorCode: when type is next: validationsFailed/noMoreForms/<other error codes>
     *              when type is submit: currentFormInvalid/UnexpectedError/FormsetIncomplete/serverConnectionFailed
     *   formsetResultObj.getNextMessage:
     *      {
     *        message: Error Message,
     *        data: can be either of
     *             a. Som Expression (for currentFormInvalid/validationsFailed)
     *             b. form (for FormsetIncomplete)
     *             c. null
     *      }
     * }
     *
     * context: object as the this parameter to be used in the functions
     */
    $.fn.formNavigator = function (options) {
        navigators = {
            dom: this,
            elem: []
        };

        var _options = options || {},
            onFormShow = _options.onFormShow,
            context = _options.context || null,
            onError = _options.onError,
            showFormOptions = function (type) {
                return {
                    success: function (formResultObj) {
                        if (onFormShow) {
                            onFormShow.apply(this, [type, formResultObj]);
                        }
                    },
                    context: context,
                    error : function (formResultObj) {
                        if (onError) {
                            return onError.apply(this, [type, formResultObj]);
                        }
                    }
                };
            };

        if (isSwipeEnabled && isSwipeUnregistered) {
            $("#formBody").on({
                "swipeleft": function () {
                    FormNavigator.showNextForm(showFormOptions.next);
                },
                "swiperight": function () {
                    FormNavigator.showPreviousForm(showFormOptions.prev);
                }
            });

            isSwipeUnregistered = false;
        }

        var currentFormBridge = formsetBridge._getCurrentFormBridge();
        if (!currentFormBridge.userConfig["postExternalMessageConfig"]) {
            try {
                window.parent.document.getElementById(window.name);
                //We are here means no cross domain issue. So if user has not defined custom postExternalMessageConfig and
                // then we'll create one which would just send event on parent.
                currentFormBridge.registerConfig("postExternalMessageConfig", {
                    "postExternalHandler": function (message) {
                        var tmpEvent = document.createEvent("CustomEvent");
                        tmpEvent.initCustomEvent(message.name, true, true, message.data);
                        window.parent.dispatchEvent(tmpEvent);
                    }
                });
            } catch (e) {
                //ignore the error
            }
        }


        if(_.isFunction(_options.showFormLoading) && _.isFunction(_options.hideFormLoading)) {
            $(window).on("formloadstart", _options.showFormLoading)
                     .on("forminitialized", _options.hideFormLoading);
        }

        function highlightFields() {
            $(".widget:not(.buttonfieldwidget,.submitfieldwidget)")
                .toggleClass("widgetBackGroundColorHighlight", xfalib.globals.highlight);
            $(".widget[data-mandatory='true'],.exclgroup[data-mandatory='true']")
                .toggleClass("widgetMandatoryBorder", xfalib.globals.highlight);
        }

        $(currentFormBridge).on("xfaNextPageRendered xfaLayoutComplete", highlightFields);

        this.each(function () {
            var $self = $(this),
                elem = {
                    submit : $("[data-formset-submit]", $self),
                    next: $('[data-formset-navigate="next"]', $self),
                    prev: $('[data-formset-navigate="prev"]', $self),
                    jump: $('select[data-formset-navigate="jump"]', $self),
                    // JP: New autocomplete control and data
                    autojumpInput: $('input[data-formset-navigate="autojump"]', $self),
                    autojumpData: $('datalist[data-formset-navigate="autojump"]', $self),
                    highlight: $('[data-formset-highlight="highlight"]', $self),
					textSelect: $('[data-formset-textSelect="textSelect"]', $self),
                    current:$('[data-formset-current="current"]', $self)
                };

            navigators.elem.push(elem);
            $self.on("click", "[data-formset-submit]", function () {
                formsetBridge.submitForm({
                    error: function (result) {
                        if (_.isFunction(onError)) {
                            onError.apply(context, ["submit", result]);
                        }
                    }
                });
            }).on("click", "[data-formset-navigate]", function () {
                var navType = $(this).attr("data-formset-navigate"),
                    formNumber;
                switch (navType) {
                case "next":
						formBridge.setFieldValue("xfa.form.Proposal._sepControl.validatePageCode","triggerValidateCode");
                        //console.log(formBridge.setFieldValue("xfa.form.Proposal._sepControl.validatePageCode","triggerValidateCode");.getFieldValue("xfa.Proposal._sepControl.validatePageCode"));
                    FormNavigator.showNextForm(showFormOptions("next"));
                    break;
                case "prev":
					formBridge.setFieldValue("xfa.form.Proposal._sepControl.validatePageCode","triggerValidateCode");
                       // console.log(formBridge.getFieldValue("xfa.Proposal._sepControl.validatePageCode"));
                    FormNavigator.showPreviousForm(showFormOptions("prev"));
                    break;
                default:
                	//console.log("navType: "+navType);
                	formNumber = parseInt(navType, 10);
                	//console.log("go to participant page : "+formNumber);
					if (!isNaN(formNumber)) {
						//console.log("go to page start");
                        FormNavigator.showForm(formNumber, showFormOptions("random"));
                        //console.log("go to page finish");
                    }
                }
            }).on("click", "[data-formset-highlight]", function () {
                xfalib.globals.highlight = !xfalib.globals.highlight;
                highlightFields();

            }).on("click", "[data-formset-textSelect]", function () {
                var navType = $(this).attr("data-formset-navigate"), formNumber;
                    //console.log("Exit form the go participant button");
                	//clean the value in data-formset-navigate
					element.jump.text("");
                    element.autojumpInput.text("");

					formNumber = parseInt(navType, 10);
					if (!isNaN(formNumber)) {
                        FormNavigator.showForm(formNumber, showFormOptions("random"));
                    }
             });

            elem.autojumpInput.on("change", function() {
                if (typeof elem.autojumpInput.participantLookup === 'undefined' || elem.autojumpInput.participantLookup == null)
                {
                    //console.log("autojump has no participant lookup");
                }
                else{
                	console.log("autojumpInput on change start");
                    var lookup = elem.autojumpInput.participantLookup;
					currentValue = elem.autojumpInput.val();
                    if (typeof lookup[currentValue] !== 'undefined')
                    {
                    	if($(document.activeElement).parent().hasClass("widget"))
                        {
                            // must blur out current input field, so that it's commit event is triggered for updating of xml
                            $(document.activeElement).blur();
                        }
                        var formNumber = lookup[currentValue];
                    	console.log("autojumpInput _validateAndShowForm start");
						FormNavigator._validateAndShowForm(formNumber, showFormOptions("random"));
						console.log("autojumpInput _validateAndShowForm finish");
                        $('#formBody').trigger('click');
                    }
                }
            });

            elem.jump.on("mousedown keydown", function () {
                        // FINESJO 20160617:
                        // Get the participant name from the XML Data.
                        // formListXml is a global variable defined in formBody.jsp
                		//console.log("Form Navigator Get XML:" + formListXml.renderContext.xml);
                	//	console.log("jump::mousedown keydown: ");
                        var parser = new DOMParser();
                        var xmlDoc = parser.parseFromString(formListXml.renderContext.xml,"text/xml");
                        var arParticipants = xmlDoc.getElementsByTagName("Participants")[0].getElementsByTagName("LegalName");
                		var iNumParticipants = arParticipants.length;

                        console.log("XML parsed. Participants: " + arParticipants.length);
                        for(var i = 0; i < arParticipants.length; i++){
                            console.log("Participant " + i + ": " + arParticipants[i].childNodes[0].nodeValue);
                        }

                        if($(document.activeElement).parent().hasClass("widget")) {
                            $(document.activeElement).blur(); // must blur out current input field, so that it's commit event is triggered for updating of xml
                        }
                        var $jumpList = $(this),
                            eligibleForms = formsetBridge.getAllEligibleForms(),
                            currentForms = $jumpList.children("option").map(function () {
                                return parseInt($(this).val());
                            }).get();

                        if(!_.isEqual(currentForms, eligibleForms)) {
                            $jumpList.html('');
                            // Change the formName for the Participant name
                            var iPartIndex = 0;
                            $.each(eligibleForms, function (index, formNumber) {
                                var formName = formsetBridge._getFormName(formNumber);
                                //$jumpList.append($("<option />").val(formNumber).text(formName));

                                // FINESJO 20160617:
                                //Fill the dropdown only with the participants
                                if(formName.indexOf("ListOfParticipant") > 0){
                                    $jumpList.append($("<option />").val(formNumber).text("List of participants"));
                                    //$jumpList.append($("<option />").val(formNumber).text(formName));
                                }else if(formName.indexOf("-Participant") >= 0){
                                    if(iPartIndex < iNumParticipants)
                                    {
                                        var displayFormName;
										//if (arParticipants[iPartIndex].childNodes.length == 0)
                                		//{
                                    		// If the text of the participant legal name is empty, put a placeholder in
										//	displayFormName = "Participant " + iNum;
                                		//}
                                		//else
                                		//{
											displayFormName = arParticipants[iPartIndex].childNodes[0].nodeValue;
                                		//}

										$jumpList.append($("<option />").val(formNumber).text(displayFormName));
 										 //console.log("DEBUG:: When you load the page again");
                                        //$jumpList.append($("<option />").val(formNumber).text(formName));
	                                    iPartIndex++;
                                    }
                                }

                            });
                        }

                        $jumpList.val(formsetBridge._getFormList().getCurrentFormNumber());
                     })
                     .change(function () {
                        var formNumber = parseInt($(this).val(), 10);
                        console.log("jump::change: " + formNumber);
                         if (!isNaN(formNumber)) {
                        	 console.log("jump _validateAndShowForm start");
                            FormNavigator._validateAndShowForm(formNumber, showFormOptions("random"));
                            console.log("jump _validateAndShowForm finish");
                        }
                    });

        });
    };

    formset.runtime.FormNavigator = FormNavigator;

    $(function () {
        formsetBridge._startFormset();
    });
}(jQuery, formset));
/*******************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 * Copyright 2015 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by all applicable intellectual property
 * laws, including trade secret and copyright laws.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 ******************************************************************************/

(function (_) {
    var fs = {
        /**
         * The API returns the value of the field whose dataSom is provided.
         * fs.valueOf now accepts 1 arg (data som exp itself) or 2 args (formUid and field som exp)
         *
         * For subforms it returns null.
         * @param dataSom
         */
        valueOf: function () {
            var dataSom = null,
                formUid = null;

            if(arguments.length === 1) {
                dataSom = arguments[0];
            } else if(arguments.length === 2) {
                formUid = arguments[0];
                dataSom = arguments[1];
            } else {
                if (window.console && _.isFunction(window.console.error)) {
                    window.console.error('[FormSet] : Invalid Arguments to fs.valueOf : ', arguments);
                }
                return null;
            }

            if(dataSom == null || dataSom.length === 0 || !_.isString(dataSom) || dataSom === "INVALID_DATA_SOM") {
                if (window.console && _.isFunction(window.console.error)) {
                    window.console.error('[FormSet] : Invalid dataSOM argument to fs.valueOf');
                }
                return null;
            }

            var formNumber = formsetBridge.getFormNumberByUid(formUid);
            if(formNumber == formset.constants.InvalidFormNumber && arguments.length > 1) {
                if (window.console && _.isFunction(window.console.error)) {
                    window.console.error('[FormSet] : Invalid form UID argument to fs.valueOf : ', formUid);
                }
                return null;
            }

            var xml = formsetBridge.getCurrentXMLDocument(),
                xPathSuffix = dataSom.split(/\[(?:\d+|\*)\]\.?/).slice(4).join("/");
                // split by "[ ]" followed by "." and remove constant prefix "xfa[0].datasets[0].data[0]" and form root name, then join using '/'
            if (xPathSuffix[xPathSuffix.length - 1] == '/') { xPathSuffix = xPathSuffix.slice(0, -1); }

            if (xml instanceof Document && xPathSuffix) {
                var formXml = formsetBridge.getXMLElementForForm(xml, formNumber),
                    dataSomValue = formsetBridge.getFirstElement(formXml, xPathSuffix, XPathResult.FIRST_ORDERED_NODE_TYPE);

                if (dataSomValue) {
                    if(dataSomValue.hasChildNodes()) {
                        var dataSomValueStr = "";
                        for (var childNode = dataSomValue.firstChild; childNode; childNode = childNode.nextSibling) {
                            dataSomValueStr += childNode.textContent +'\n';
                        }
                        dataSomValue = dataSomValueStr.slice(0, -1);
                    } else {
                        dataSomValue = dataSomValue.textContent;
                    }
                } else {
                    if (window.console && _.isFunction(window.console.info)) {
                        window.console.info('[FormSet] : Failed to fetch value in fs.valueOf with arguments : ', arguments);
                    }
                }
                return dataSomValue;
            } else {
                if (window.console && _.isFunction(window.console.error)) {
                    window.console.error('[FormSet] : Failed to fetch current XML in fs.valueOf with arguments : ', arguments);
                }
                return null;
            }
        },

        /**
         * Returns the count of the number of instances of a subform whose dataSOM matches this value
         * If the dataSOM is of a Field, it returns 1.
         * @param dataSOM
         */
        instances: function (dataSOM) {

        },

        /**
         * Returns a flat array of Strings containing the result, extracted from the render context xml.
         * 1 arg passed implies evaluate the xpath from form root.
         * 2 args formUid followed by xpath. Evaluate the xpath from the form context root.
         * @param xPath
         * @param formUid
         * Form uid is optional. In that case xmlRoot is assumed to be "/".
         *
         */
        evaluateXpath: function () {
            var xPath,
                formUid;

            if (arguments.length === 1) {
                xPath = arguments[0];
            } else if (arguments.length === 2) {
                formUid = arguments[0];
                xPath = arguments[1];
            } else {
                if (window.console && _.isFunction(window.console.error)) {
                    window.console.error('[FormSet] : Invalid Arguments to fs.evaluateXpath : ', arguments);
                }
                return null;
            }

            var formNumber = formsetBridge.getFormNumberByUid(formUid),
                xml = formsetBridge.updateCurrentXML(),
                xPathValue = [];

            if (formNumber == formset.constants.InvalidFormNumber && arguments.length > 1) {
                if (window.console && _.isFunction(window.console.error)) {
                    window.console.error('[FormSet] : Invalid form UID argument to fs.evaluateXpath : ', formUid);
                }
                return null;
            }

            if (xml) {
                var formXml = formsetBridge.getXMLElementForForm(xml, formNumber),
                    xPathQueryResult = xfalib.ut.XMLUtils.evaluateXPath(xPath, formXml, null,
                                                                XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
                    // used node snapshot instead of ordered node type as render xml should not change
                    // TODO : cross browser issues with document.evaluate

                if (xPathQueryResult == null) {
                    if (window.console && _.isFunction(window.console.error)) {
                        window.console.error('[FormSet] : Failed to resolve Arguments to fs.evaluateXpath with arguments : ', arguments);
                    }
                    return null;
                }

                if(xPathQueryResult.snapshotLength) {
                    for (var i = 0; i < xPathQueryResult.snapshotLength; ++i) {
                        xPathValue.push(xPathQueryResult.snapshotItem(i).textContent);
                    }
                } else {
                    if (window.console && _.isFunction(window.console.error)) {
                        window.console.error('[FormSet] : Failed to resolve Xpath in fs.evaluateXpath with arguments : ', arguments);
                    }
                    return null;
                }
            }
            return xPathValue;
        }
    };

    formset.runtime.fs = fs;
}(_));

/*  Remove the ghost texts before saving
	Implemented by Swalim
*/
(function ($) {
    var FormCustomObject = function () {
        var ghostTexts;

        this.processXmlData = function ($xmlDoc) {


            var $str = "";        
            var $xml=$.parseXML($xmlDoc);

            var $xmlAcronymVal = $($xml).find('Acronym').text();
            var $xmlDurationVal = $($xml).find('Duration').text();
            var $xmlAbstractVal = $($xml).find('Abstract').text();
            var $xmlTitleVal = $($xml).find('ProposalTitle').text();
            var $xmlFreeKeywords = $($xml).find('FreeKeywords').text();
            var $xmlFixedKeywords = $($xml).find('Keyword');
            var $xmlPersonIdentification = $($xml).find('IdentificationNumber');
            var $xmlPersonIdentificationType = $($xml).find('IdentificationType');
            var $xmlProjectIDVal = $($xml).find('RelatedProjectID').text();
			var $xmlNoOfDaysVal = $($xml).find('NoOfDays').text();
            var $xmlRelatedProjectIDVal = $($xml).find('RelatedProjectID').text();

            var $acronymGT = this.getGhostText("acronym");
            var $abstractGT = this.getGhostText("abstract");
            var $proposalTitleGT = this.getGhostText("proposal-title");
            var $durationGT = this.getGhostText("duration");
            var $freeKeywordsGT = this.getGhostText("free-keywords");
            var $fixedKeywordGT = this.getGhostText("fixed-keyword");
            var $deptNameGT = this.getGhostText("dept_name");
            var $streetNameGT = this.getGhostText("streetname");
            var $townNameGT = this.getGhostText("town");
            var $websiteGT = this.getGhostText("website");
            var $postcodeGT = this.getGhostText("postcode");
            var $countryGT = this.getGhostText("country");
            var $positionGT = this.getGhostText("positionOrg");
            var $phoneNoGT = this.getGhostText("phoneNo");
            var $orcidGT = this.getGhostText("ORCID");
            var $otherResearcherIDGT = this.getGhostText("otherResearcherID");
            var $researcherIDGT = this.getGhostText("researcherID");
            var $ethicsGT = this.getGhostText("ethics");
            var $legitimateReasonGT = this.getGhostText("legitimateReason");
            var $projectIDGT = this.getGhostText("projectID");
            var $eligibilityAdditionalGT = this.getGhostText("callSpeciicQuestions");
			var $ethicalPricipleGT = this.getGhostText("ethicalPriciple");
            var $ethicalDimensionGT = this.getGhostText("ethicalDimension");
			var $noOfDaysGT = this.getGhostText("noOfDays");
            var $secCResourcesGT = this.getGhostText("budgetResource");


            var $preRegistrationData = $($xml).find('PreRegistrationData').children();



            $xmlFixedKeywords.each(function() {

                var $id = $(this).find("Id").text();
                if($id == $fixedKeywordGT){
					$(this).find("Id").text($(this).find("Id").text().replace($fixedKeywordGT, $str));
                }
            });

            if($xmlNoOfDaysVal == $noOfDaysGT){

                $($xml).find('NoOfDays').text($($xml).find('NoOfDays').text().replace($noOfDaysGT, $str));
                $xmlNoOfDaysVal = $str;
            }

            if($xmlAcronymVal == $acronymGT){

                $($xml).find('Acronym').text($($xml).find('Acronym').text().replace($acronymGT, $str));
                $xmlAcronymVal = $str;
            }

             if($xmlProjectIDVal == $projectIDGT){

                $($xml).find('RelatedProjectID').text($($xml).find('RelatedProjectID').text().replace($projectIDGT, $str));
                $xmlProjectIDVal = $str;
            }

            if($xmlDurationVal == $durationGT){

                $($xml).find('Duration').text($($xml).find('Duration').text().replace($durationGT, $str));
            }
            var $tempAbstract = exists( $abstractGT,$xmlAbstractVal); 

			if($tempAbstract > -1){  
                $($xml).find('Abstract').text($($xml).find('Abstract').text().replace($abstractGT[$tempAbstract], $str));
                $xmlAbstractVal = $str;
            }

             var $tempTitle = exists($proposalTitleGT,$xmlTitleVal); 


            if($tempTitle > -1){
                $($xml).find('ProposalTitle').text($($xml).find('ProposalTitle').text().replace($proposalTitleGT[$tempTitle], $str));
            }

            var $tempFreeKeywords = exists($freeKeywordsGT,$xmlFreeKeywords); 

            if($tempFreeKeywords > -1){
                $($xml).find('FreeKeywords').text($($xml).find('FreeKeywords').text().replace($freeKeywordsGT[$tempFreeKeywords], $str));
            }

            $preRegistrationData.each(function() {

               if($(this).attr("name") == "abstract"){
                   $(this).attr("value", $xmlAbstractVal);
               }
               if($(this).attr("name") == "acronym"){
                   $(this).attr("value", $xmlAcronymVal);
               }
            });


   		    var $xmlPreviousProposalsDataNode = $($xml).find('PreviousProposals').children();
			var $previousproposalGT = "";
            $previousproposalGT = this.getGhostText("previous-proposals");

            $xmlPreviousProposalsDataNode.find('*').each(function(index, Element) {     

				var $tempPreviousProposal = exists($previousproposalGT,$(this).text()); 

                if($tempPreviousProposal > -1){ 
                     $(this).text($(this).text().replace( $previousproposalGT[$tempPreviousProposal], $str));

                } 
            });

			var $tempRelatedProjectIDVal = exists($previousproposalGT,$xmlRelatedProjectIDVal); 

            if($tempRelatedProjectIDVal > -1){
                    $($xml).find('RelatedProjectID').text($($xml).find('RelatedProjectID').text().replace($previousproposalGT[$tempRelatedProjectIDVal], $str));
                    $xmlRelatedProjectIDVal = $str;
             }

             $($xml).find('Department').each(function(){

                var $deptName = $(this).find("Name").text();
                var $streetName = $(this).find("PostalAddress").find("Street").text();
                var $townName = $(this).find("PostalAddress").find("City").text();
                var $postalCode = $(this).find("PostalAddress").find("PostalCode").text();
                var $countryCode = $(this).find("PostalAddress").find("CountryCode").find("Id").text();

                if($deptName == $deptNameGT){
                    $(this).find("Name").text($(this).find("Name").text().replace($deptName, $str));
                }
                if($streetName == $streetNameGT){
                    $(this).find("PostalAddress").find("Street").text($(this).find("PostalAddress").find("Street").text().replace($streetName, $str));
                } 
                if($townName == $townNameGT){
                    $(this).find("PostalAddress").find("City").text($(this).find("PostalAddress").find("City").text().replace($townName, $str));
                }
                if($postalCode == $postcodeGT){
                    $(this).find("PostalAddress").find("PostalCode").text($(this).find("PostalAddress").find("PostalCode").text().replace($postalCode, $str));
                }
                if($countryCode == $countryGT){
                    $(this).find("PostalAddress").find("CountryCode").find("Id").text($(this).find("PostalAddress").find("CountryCode").find("Id").text().replace($countryCode, $str));
                }

            });

            $($xml).find('MainContact').each(function(){

                var $position = $(this).find("PersonalDetails").find("Position").text();
                var $department = $(this).find("PersonalDetails").find("Department").text();
                var $streetName = $(this).find("PersonalDetails").find("Address").find("PostalAddress").find("Street").text();
                var $townName = $(this).find("PersonalDetails").find("Address").find("PostalAddress").find("City").text();
                var $website = $(this).find("PersonalDetails").find("Address").find("WebLink").text();
                var $postalCode = $(this).find("PersonalDetails").find("Address").find("PostalAddress").find("PostalCode").text();
                var $countryCode = $(this).find("PersonalDetails").find("Address").find("PostalAddress").find("CountryCode").find("Id").text();
                var $phoneNo = $(this).find("PersonalDetails").find("Address").find("AdditionalContactInformation").find("Phone").text();
                var $mobileNo = $(this).find("PersonalDetails").find("Address").find("AdditionalContactInformation").find("Mobile").text();
                var $faxNo = $(this).find("PersonalDetails").find("Address").find("AdditionalContactInformation").find("Fax").text();

                if($position == $positionGT){
                    $(this).find("PersonalDetails").find("Position").text($(this).find("PersonalDetails").find("Position").text().replace($position, $str));
                }

                if($department == $deptNameGT){
                    $(this).find("PersonalDetails").find("Department").text($(this).find("PersonalDetails").find("Department").text().replace($department, $str));
                }
                if($streetName == $streetNameGT){
                    $(this).find("PersonalDetails").find("Address").find("PostalAddress").find("Street").text($(this).find("PersonalDetails").find("Address").find("PostalAddress").find("Street").text().replace($streetName, $str));
                } 
                if($townName == $townNameGT){
                    $(this).find("PersonalDetails").find("Address").find("PostalAddress").find("City").text($(this).find("PersonalDetails").find("Address").find("PostalAddress").find("City").text().replace($townName, $str));
                }
                if($website == $websiteGT){
                    $(this).find("PersonalDetails").find("Address").find("WebLink").text($(this).find("PersonalDetails").find("Address").find("WebLink").text().replace($website, $str));
                }
                if($postalCode == $postcodeGT){
                    $(this).find("PersonalDetails").find("Address").find("PostalAddress").find("PostalCode").text($(this).find("PersonalDetails").find("Address").find("PostalAddress").find("PostalCode").text().replace($postalCode, $str));
                }
                if($countryCode == $countryGT){
                    $(this).find("PersonalDetails").find("Address").find("PostalAddress").find("CountryCode").find("Id").text($(this).find("PersonalDetails").find("Address").find("PostalAddress").find("CountryCode").find("Id").text().replace($countryCode, $str));
                }
				if($phoneNo ==  $phoneNoGT){
                    $(this).find("PersonalDetails").find("Address").find("AdditionalContactInformation").find("Phone").text($(this).find("PersonalDetails").find("Address").find("AdditionalContactInformation").find("Phone").text().replace($phoneNo, $str));
                }
                if($mobileNo ==  $phoneNoGT){
                    $(this).find("PersonalDetails").find("Address").find("AdditionalContactInformation").find("Mobile").text($(this).find("PersonalDetails").find("Address").find("AdditionalContactInformation").find("Mobile").text().replace($mobileNo, $str));
                }
                if($faxNo ==  $phoneNoGT){
                    $(this).find("PersonalDetails").find("Address").find("AdditionalContactInformation").find("Fax").text($(this).find("PersonalDetails").find("Address").find("AdditionalContactInformation").find("Fax").text().replace($faxNo, $str));
                }



            });

            $($xml).find('Fellow').each(function(){

               var $streetName = $(this).find("PersonalDetails").find("Address").find("PostalAddress").find("Street").text();
               var $phoneNo = $(this).find("PersonalDetails").find("Address").find("AdditionalContactInformation").find("Phone").text();
               var $mobileNo = $(this).find("PersonalDetails").find("Address").find("AdditionalContactInformation").find("Mobile").text();

                if($streetName == $streetNameGT){
                    $(this).find("PersonalDetails").find("Address").find("PostalAddress").find("Street").text($(this).find("PersonalDetails").find("Address").find("PostalAddress").find("Street").text().replace($streetName, $str));
                } 
				if($phoneNo ==  $phoneNoGT){
                    $(this).find("PersonalDetails").find("Address").find("AdditionalContactInformation").find("Phone").text($(this).find("PersonalDetails").find("Address").find("AdditionalContactInformation").find("Phone").text().replace($phoneNo, $str));
                }
                if($mobileNo ==  $phoneNoGT){
                    $(this).find("PersonalDetails").find("Address").find("AdditionalContactInformation").find("Mobile").text($(this).find("PersonalDetails").find("Address").find("AdditionalContactInformation").find("Mobile").text().replace($phoneNo, $str));
                }

            });

            $($xml).find('Contact').each(function(){

                var $phoneNo = $(this).find("PersonalDetails").find("Address").find("AdditionalContactInformation").find("Phone").text();

               	if($phoneNo ==  $phoneNoGT){
               	    $(this).find("PersonalDetails").find("Address").find("AdditionalContactInformation").find("Phone").text($(this).find("PersonalDetails").find("Address").find("AdditionalContactInformation").find("Phone").text().replace($phoneNo, $str));
             	}
            });


             $($xml).find('TotalBudget').find('BudgetQuestionnaire').find('Question').find('Answer').each(function(){
                 var $xmlSecCResources = $(this).find('Text').text();
                 if($xmlSecCResources ==  $secCResourcesGT){
                     $(this).find('Text').text($(this).find('Text').text().replace($xmlSecCResources, $str));
                 }

            });

            $($xml).find('Ethical').find('Section').find('Question').find('BaseQuestion').each(function(){
                var $xmlEthicsVal = $(this).find('Explanation').text();
                var $tempEthics = exists($ethicsGT,$xmlEthicsVal); 

                if($tempEthics > -1){
					$(this).find('Explanation').text($(this).find('Explanation').text().replace($ethicsGT[$tempEthics], $str));

                }
                if($xmlEthicsVal ==  $ethicalPricipleGT){
                     $(this).find('Explanation').text($(this).find('Explanation').text().replace($xmlEthicsVal, $str));
                 }
               	if($xmlEthicsVal ==  $ethicalDimensionGT){
                     $(this).find('Explanation').text($(this).find('Explanation').text().replace($xmlEthicsVal, $str));
                 }

            });

            $($xml).find('Security').find('Section').find('Question').find('BaseQuestion').each(function(){
                var $xmlEthicsVal = $(this).find('Explanation').text();
                var $tempEthics = exists($ethicsGT,$xmlEthicsVal); 
                if($tempEthics > -1){
                     $(this).find('Explanation').text($(this).find('Explanation').text().replace($ethicsGT[$tempEthics], $str));
                 }
            });


            $($xml).find('OpenResearchData').find('Question').each(function(){
                 var $xmlLegitimateReasonsVal = $(this).find('Explanation').text(); 

                if($xmlLegitimateReasonsVal == $legitimateReasonGT){
                     $(this).find('Explanation').text($(this).find('Explanation').text().replace($xmlLegitimateReasonsVal, $str));
                 }

            });

              $($xml).find('CallSpecificSections').find('Eligibility').find('AdditionalDataList').find('DataItem').each(function(){
                 var $xmlEligibilityAdditionalVal = $(this).find('Value').text(); 

                if(exists($eligibilityAdditionalGT, $xmlEligibilityAdditionalVal) > -1){
                     $(this).find('Value').text($(this).find('Value').text().replace($xmlEligibilityAdditionalVal, $str));
                 }

            });

             $($xml).find('CallSpecificSections').find('Previously_submitted').find('AdditionalDataList').find('DataItem').each(function(){
                 var $xmlPreviousSubmittedVal = $(this).find('Value').text(); 

                if(exists($eligibilityAdditionalGT, $xmlPreviousSubmittedVal) > -1){
                     $(this).find('Value').text($(this).find('Value').text().replace($xmlPreviousSubmittedVal, $str));
                 }

            });

			$($xml).find('CallSpecificSections').find('Previously_submitted').find('AdditionalDataList').find('DataItem').each(function(){
                 var $xmlPreviousSubmittedDsc = $(this).find('Description').text(); 

                if(exists($eligibilityAdditionalGT, $xmlPreviousSubmittedDsc) > -1){
                     $(this).find('Description').text($(this).find('Description').text().replace($xmlPreviousSubmittedDsc, $str));
                 }

            });

            $($xml).find('CallSpecificSections').find('AcademicTraining').find('ExtensionDays').each(function(){
                 var $xmlEligibilityAdditionalVal = $(this).find('NoOfDays').text(); 

                if(exists($eligibilityAdditionalGT, $xmlEligibilityAdditionalVal) > -1){
                     $(this).find('NoOfDays').text($(this).find('NoOfDays').text().replace($xmlEligibilityAdditionalVal, $str));
                 }

            });

            $($xml).find('CallSpecificSections').find('AcademicTraining').find('ExtensionDays').each(function(){
                 var $xmlEligibilityAdditionalVal = $(this).find('Explanation').text(); 

                if(exists($eligibilityAdditionalGT, $xmlEligibilityAdditionalVal) > -1){
                     $(this).find('Explanation').text($(this).find('Explanation').text().replace($xmlEligibilityAdditionalVal, $str));
                 }

            });

            $xmlPersonIdentification.each(function() {

                var $text = $(this).text();
                if($text == $orcidGT || $orcidGT.indexOf($text) > -1){
                    $(this).text($(this).text().replace($text, $str));
                }else if(exists($otherResearcherIDGT,$text) > -1){
					$(this).text($(this).text().replace($text, $str));
                }
            });

            $xmlPersonIdentificationType.each(function() {
                var $text = $(this).text();
				if(exists($otherResearcherIDGT,$text) > -1){
					$(this).text($(this).text().replace($text, $str));
                }
            });

            xmlDoc = new XMLSerializer().serializeToString($xml);
			return xmlDoc;

        };

        this.getGhostText = function ($field){

            for(var $count = 0; $count < ghostTexts.length; $count ++){
				var $key = ghostTexts[$count][0];
				if($key == $field){			 
					return ghostTexts[$count][1];
				}		
			}
			return 0;
        };


        this.setGhostTexts = function ($data){
            ghostTexts = $data;
        };

        exists = function($data, $GHtext){
            for(var $count = 0; $count < $data.length; $count ++){
                if($data[$count] == $GHtext){
                    return $count;
                }
            }
            return -1;

        };

    };
    

    formset.runtime.FormCustomObject = new FormCustomObject();
}(jQuery));
